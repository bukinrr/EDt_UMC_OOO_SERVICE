#Область ПрограммныйИнтерфейс





#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

Функция ОтправитьПоHTTP(Хост, АдресРесурса, ТекстЗапроса, ИспользоватьHttps) Экспорт
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Content-Type", "application/soap+xml;charset=UTF-8");
	Заголовки.Вставить("SOAPAction", "sendDocument");
	
	HTTPЗапрос = Новый HTTPЗапрос(АдресРесурса, Заголовки);
	HTTPЗапрос.УстановитьТелоИзСтроки(ТекстЗапроса, "UTF-8");
	
	Протокол = ?(ИспользоватьHttps, "HTTPS", "HTTP"); 
	ИнтернетПрокси = ПолучениеФайловИзИнтернетаКлиентСервер.ПолучитьПрокси(Протокол);
	
	Если ИспользоватьHttps Тогда
		HTTPСоединение = Новый HTTPСоединение(Хост,,,,ИнтернетПрокси,, Новый ЗащищенноеСоединениеOpenSSL);
	Иначе
		HTTPСоединение = Новый HTTPСоединение(Хост,,,,ИнтернетПрокси);
	КонецЕсли;
	
	ИнтеграцияЕГИСЗВызовСервера.ЗаписатьВЖурналРегистрации("ИнтеграцияЕГИСЗ.HTTPЗапрос","Информация",,,HTTPЗапрос.ПолучитьТелоКакСтроку());

	HTTPОтвет = HTTPСоединение.ОтправитьДляОбработки(HTTPЗапрос);
	
	ИнтеграцияЕГИСЗВызовСервера.ЗаписатьВЖурналРегистрации("ИнтеграцияЕГИСЗ.HTTPОтвет", "Информация",,,HTTPОтвет.ПолучитьТелоКакСтроку());
	
	Возврат HTTPОтвет;
	
КонецФункции

Функция ПоместитьСообщениеВSOAPКонверт(URI, ТелоСообщения, ИдентификаторКлиента, УИДСообщения, ТипПакета) Экспорт
	Результат = ТекстXMLSOAPКонверт(?(ЗначениеЗаполнено(ТипПакета), Ложь, Истина));
	
	Результат = стрШаблон(
					Результат,
					ИдентификаторКлиента, // Идентификатор клиента
					ТипПакета,
					УИДСообщения, // Идентификатор сообщения
					URI,
					ТелоСообщения
				);
	
	Возврат Результат;
КонецФункции

// SOAP конверт.
Функция ТекстXMLSOAPКонверт(СокращенныйЗаголовок = Ложь)
	
	Текст =
		"<soap:Envelope xmlns:soap=""http://www.w3.org/2003/05/soap-envelope"" xmlns:urn=""urn:hl7-org:v3"" xmlns:a=""http://www.w3.org/2005/08/addressing"">
		|<soap:Header>

		|<transportHeader xmlns=""http://egisz.rosminzdrav.ru"">
		|<authInfo>
		|<clientEntityId>%1</clientEntityId>
		|</authInfo>
		|</transportHeader>"

		+ ?(Не СокращенныйЗаголовок, "
		|<!--Тип запроса (идентификатор операции сервиса).-->
		|<a:Action>%2</a:Action>
		|<!--Уникальный ID сообщения. Должен быть указан в ответе на данный запрос-->
		|<a:MessageID>urn:uuid:%3</a:MessageID>
		|<!--При асинхронном запросе – URI сервиса обратного вызова (МИС), для отправки ответного сообщения-->
		|<a:ReplyTo>
		|<a:Address>http://www.w3.org/2005/08/addressing/anonymous</a:Address>
		|</a:ReplyTo>
		|<!--Адрес конечной точки, куда отправляется данное сообщение-->
		|<a:To>%4</a:To>","") + "

		|</soap:Header>
		|<soap:Body>
		|%5
		|</soap:Body>
		|</soap:Envelope>";
	
	Возврат Текст;

КонецФункции

Функция ПолучитьТекстОшибкиSoap(ТелоОтветаСервера) Экспорт

	//XML = ТелоОтветаСервера;
	XML = ТелоОтветаСервера.ПолучитьТелоКакСтроку();

	Попытка
		ЧитаемXML = Новый ЧтениеXML;
		ЧитаемXML.УстановитьСтроку(XML);

		ПостроительDOM = Новый ПостроительDOM;
		DOM = ПостроительDOM.Прочитать(ЧитаемXML);
		
		FaultТэги = DOM.ПолучитьЭлементыПоИмени("Fault");
		
		Результат = Неопределено;
		Если FaultТэги.Количество() > 0 Тогда
			TextТэги = FaultТэги[0].ПолучитьЭлементыПоИмени("Text");
			
			Если TextТэги.Количество() > 0 Тогда
				Результат = TextТэги[0].ТекстовоеСодержимое;
			КонецЕсли;
		КонецЕсли;
		
		Возврат Результат;
		
	Исключение
		Возврат XML;
	КонецПопытки;
	
КонецФункции

// Добавляет в soap конверт тэги необходимые для хранения ЭП.
Функция ДобавитьВПодписываемыйXmlТэгиДляХраненияПодписи(ПодписываемыйXml) Экспорт 
	
	ДокументDOM = ПостроитьDOM(ПодписываемыйXml);
	КорневойЭлемент = ДокументDOM.ЭлементДокумента;
	
	// Добавим в конверт тег soap:Header, если его не было.
	Если Не "Header" = КорневойЭлемент.ПервыйДочерний.ЛокальноеИмя Тогда
		Header = ДокументDOM.СоздатьЭлемент(КорневойЭлемент.URIПространстваИмен, "Header");
		КорневойЭлемент.ВставитьПеред(Header, КорневойЭлемент.ПервыйДочерний);
	КонецЕсли;
	
	// Извлечем или добавим в тело сообщения атрибут wsu:Id.
	ПИ = РазыменовательПИSOAP(КорневойЭлемент.URIПространстваИмен);
	XPath = "/soap:Envelope/soap:Body/@wsu:Id";
	wsuId = ПолучитьСтрокуПоXPath(ДокументDOM, ПИ, XPath);
	Если Не ЗначениеЗаполнено(wsuId) Тогда
		// Добавляем атрибут wsu:Id.
		wsuId = "uuid:" + Строка(Новый УникальныйИдентификатор);
		Атрибут_wsuId = ДокументDOM.СоздатьАтрибут(ПространстваИмен.wsu(), "wsu:Id");
		Атрибут_wsuId.Значение = wsuId;
		КорневойЭлемент.ПоследнийДочерний.Атрибуты.УстановитьИменованныйЭлемент(Атрибут_wsuId);
	КонецЕсли;
	
	// Добавим в заголовок сообщения тэг Security.
	Security = ШаблонТэгаSecurity(wsuId);
	SecurityDOM = ПостроитьDOM(Security);
	wsseSecurity = ДокументDOM.ИмпортироватьУзел(SecurityDOM.ПервыйДочерний, Истина);
	КорневойЭлемент.ПервыйДочерний.ДобавитьДочерний(wsseSecurity);
	ПодписываемыйXml = РаботаСDOMКлиентСервер.СтрокаXMLИзDOM(ДокументDOM);
	
	ДокументСТэгамиДляПодписи = Новый Структура;
	ДокументСТэгамиДляПодписи.Вставить("ПодписываемыйXml",	ПодписываемыйXml);
	ДокументСТэгамиДляПодписи.Вставить("wsuId",				wsuId);
	
	Возврат ДокументСТэгамиДляПодписи;
	
КонецФункции

// Построение документа DOM из стоки XML
//
// Параметры:
//  СтрокаXML	 - Строка	 - Строка XML, по которой нужно построить DOM.
// 
// Возвращаемое значение:
//  ДокументDOM - Построенный по строке XML документ DOM.
//
Функция ПостроитьDOM(СтрокаXML) Экспорт
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);
	
	ПостроительDOM = Новый ПостроительDOM;
	ДокументDOM = ПостроительDOM.Прочитать(ЧтениеXML);
	
	Возврат ДокументDOM;
	
КонецФункции

Функция ПолучитьСтрокуПоXPath(ДокументDOM, Знач Разыменователь = Неопределено, XPath) Экспорт
	
	Если Неопределено = Разыменователь Тогда
		Разыменователь = ДокументDOM.СоздатьРазыменовательПИ();
	КонецЕсли;
	
	ТипРезультата = ТипРезультатаDOMXPath.Строка;
	
	РезультатXPath = ДокументDOM.ВычислитьВыражениеXPath(
		XPath, ДокументDOM, Разыменователь, ТипРезультата
	);
	
	Возврат РезультатXPath.СтроковоеЗначение;
	
КонецФункции

Функция РазыменовательПИSOAP(URIПространстваИменSOAP) Экспорт
	
	СоответствиеПИ = Новый Соответствие;
	Если ЗначениеЗаполнено(URIПространстваИменSOAP) Тогда
		СоответствиеПИ.Вставить("soap", URIПространстваИменSOAP);
	Иначе 
		СоответствиеПИ.Вставить("soap", ПространстваИмен.soap());
	КонецЕсли;
	СоответствиеПИ.Вставить("wsa",	ПространстваИмен.wsa());
	СоответствиеПИ.Вставить("wsse",	ПространстваИмен.wsse());
	СоответствиеПИ.Вставить("wsu",	ПространстваИмен.wsu());
	
	Возврат Новый РазыменовательПространствИменDOM(СоответствиеПИ);
	
КонецФункции

Функция ШаблонТэгаSecurity(wsuId) Экспорт
	
	Шаблон =
		"<wsse:Security xmlns:wsse=""%1"" xmlns:wsu=""%2"">
		|	<wsse:BinarySecurityToken
		|			EncodingType=""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary""
		|			ValueType=""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3""
		|			wsu:Id=""%4"">%6</wsse:BinarySecurityToken>
		|	<ds:Signature xmlns:ds=""%3"">
		|		<ds:SignedInfo>
		|			<ds:CanonicalizationMethod Algorithm=""http://www.w3.org/2001/10/xml-exc-c14n#""/>
		|			<ds:SignatureMethod Algorithm=""%9""/>
		|			<ds:Reference URI=""#%5"">
		|				<ds:Transforms>
		|					<ds:Transform Algorithm=""http://www.w3.org/2001/10/xml-exc-c14n#""/>
		|				</ds:Transforms>
		|				<ds:DigestMethod Algorithm=""%10""/>
		|				<ds:DigestValue>%7</ds:DigestValue>
		|			</ds:Reference>
		|		</ds:SignedInfo>
		|		<ds:SignatureValue>%8</ds:SignatureValue>
		|		<ds:KeyInfo>
		|			<wsse:SecurityTokenReference>
		|				<wsse:Reference URI=""#%4"" ValueType=""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3""/>
		|			</wsse:SecurityTokenReference>
		|		</ds:KeyInfo>
		|	</ds:Signature>
		|</wsse:Security>";
	
	Результат = СтрШаблон(
		Шаблон,
		ПространстваИмен.wsse(),
		ПространстваИмен.wsu(),
		ПространстваИмен.xmldsig(),
		"uuid:" + Строка(Новый УникальныйИдентификатор), // [SOAP_ACTOR]
		wsuId, // [WSU_ID]
		"%BinarySecurityToken%",
		"%DigestValue%",
		"%SignatureValue%",
		"%SignatureMethod%",
		"%DigestMethod%"
		
	);
	
	Возврат Результат;
	
КонецФункции

Функция ПолучитьСодержимоеЭлемента(РодительскийУзелDOM, ИмяЭлемента, Индекс = 0) Экспорт
	
	Если РодительскийУзелDOM <> Неопределено Тогда
		Результат = РодительскийУзелDOM.ПолучитьЭлементыПоИмени(ИмяЭлемента);

		Если Результат.Количество() > Индекс Тогда
			Возврат Результат[Индекс].ТекстовоеСодержимое;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

Функция ПолучитьИЗаполнитьПараметрыXMLDSig(ДокументСТэгамиДляПодписи) Экспорт	
	
	ПараметрыXMLDSig = ЭлектроннаяПодписьКлиентСервер.ПараметрыXMLDSig();
	ПараметрыXMLDSig.XPathSignedInfo		= "(//. | //@* | //namespace::*)[ancestor-or-self::*[local-name()='SignedInfo']]";
	ПараметрыXMLDSig.XPathПодписываемыйТег	= СтрШаблон("(//. | //@* | //namespace::*)[
														|	ancestor-or-self::*[
														|		attribute::*[
														|			local-name()='Id'
														|			and string()='%1'
														|			and namespace-uri()='%2'
														|		]
														|	]
														|]",
														ДокументСТэгамиДляПодписи.wsuId,
														ПространстваИмен.wsu());
														
	ПараметрыXMLDSig.ИмяАлгоритмаПодписи		= "GOST R 34.10-2001" + Символы.ПС + "GOST R 34.10-2012-256" + Символы.ПС + "GOST R 34.10-2012-512";
	ПараметрыXMLDSig.OIDАлгоритмаПодписи 		= "1.2.643.2.2.3" + Символы.ПС + "1.2.643.7.1.1.3.2" + Символы.ПС + "1.2.643.7.1.1.3.3";
	ПараметрыXMLDSig.АлгоритмПодписи 			= "urn:ietf:params:xml:ns:cpxmlsec:algorithms:gostr34102001-gostr3411" + Символы.ПС
												+ "urn:ietf:params:xml:ns:cpxmlsec:algorithms:gostr34102012-gostr34112012-256" + Символы.ПС
												+ "urn:ietf:params:xml:ns:cpxmlsec:algorithms:gostr34102012-gostr34112012-512";
	
	ПараметрыXMLDSig.ИмяАлгоритмаХеширования 	= "GOST R 34.11-94" + Символы.ПС + "GOST R 34.10-2012-256" + Символы.ПС + "GOST R 34.10-2012-512";
	ПараметрыXMLDSig.OIDАлгоритмаХеширования	= "1.2.643.2.2.9" + Символы.ПС + "1.2.643.7.1.1.2.2" + Символы.ПС + "1.2.643.7.1.1.2.3";
	ПараметрыXMLDSig.АлгоритмХеширования		= "urn:ietf:params:xml:ns:cpxmlsec:algorithms:gostr3411" + Символы.ПС
												+ "urn:ietf:params:xml:ns:cpxmlsec:algorithms:gostr34112012-256" + Символы.ПС
												+ "urn:ietf:params:xml:ns:cpxmlsec:algorithms:gostr34112012-512";
	Возврат ПараметрыXMLDSig;
	
КонецФункции

Функция ПодставитьДанныеВШаблон(Шаблон, Данные) Экспорт
	
	Результат = Шаблон;
	Для Каждого Поле Из Данные Цикл
		Если ТипЗнч(Поле.Ключ) = Тип("Строка") Тогда
			Если ЗначениеЗаполнено(Поле.Значение) Тогда
				Результат = стрЗаменить(Результат, Поле.Ключ, Поле.Значение);
			Иначе
				УдалитьПараметрИзШаблона(Результат, Поле.Ключ);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Результат = стрЗаменить(Результат, "{{", "");
	Результат = стрЗаменить(Результат, "}}", "");
	
	Возврат Результат;
КонецФункции

// Удаляет часть строки между скобками {{ }}, внутри которых встречается, переданный в аргументах,
// параметр шаблона, к примеру [ИМЯ_ПАРАМЕТРА].
Функция УдалитьПараметрИзШаблона(Шаблон, ИмяПараметра) экспорт

	ПозицияКлюча = стрНайти(Шаблон, ИмяПараметра);
	
	Если ПозицияКлюча > 0 Тогда
		ОткрСкобка = стрНайти(Шаблон, "{{", НаправлениеПоиска.СКонца, ПозицияКлюча);
		ЗакрСкобка = стрНайти(Шаблон, "}}", НаправлениеПоиска.СНачала, ПозицияКлюча);
		Если ОткрСкобка > 0 И ЗакрСкобка > 0 И ПозицияКлюча > ОткрСкобка И ПозицияКлюча < ЗакрСкобка Тогда
			
			УдаляемаяЧасть = Сред(Шаблон, ОткрСкобка, (ЗакрСкобка - ОткрСкобка) + 2);
			
			Если стрНайти(УдаляемаяЧасть, "{{", НаправлениеПоиска.СНачала, 3) = 0
				И стрНайти(УдаляемаяЧасть, "}}", НаправлениеПоиска.СКонца, стрДлина(УдаляемаяЧасть) - 2) = 0
			Тогда
				Шаблон = стрЗаменить(Шаблон, УдаляемаяЧасть, "");
			Иначе
				Шаблон = стрЗаменить(Шаблон, ИмяПараметра, "");
			КонецЕсли;
			
		Иначе
			Шаблон = стрЗаменить(Шаблон, ИмяПараметра, "");
		КонецЕсли;
	КонецЕсли;
	
	Возврат Шаблон;
КонецФункции

Функция ЭкранироватьЗначение(Строка) Экспорт
	
	Если Не ЗначениеЗаполнено(Строка) Тогда
		Возврат "";
	КонецЕсли;
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	ЗаписьXML.ЗаписатьНачалоЭлемента("q");
	ЗаписьXML.ЗаписатьАтрибут("s", Строка(Строка));
	ЗаписьXML.ЗаписатьКонецЭлемента();
	XML = ЗаписьXML.Закрыть();
	
	Длина = стрДлина(XML);
	Если Длина > 8 Тогда
		Результат = Сред(XML, 7, Длина - 9);
	Иначе
		Результат = "";
	КонецЕсли;
	
	Возврат Результат;

КонецФункции

Функция РазобратьРезультатЗапросаДанныхДокумента(ОтветОтСервера) Экспорт
	
	Результат = Новый Структура("Предупреждения, emdrId, registrationDate, storeTillDate", Новый Массив);
	
	XML = ОтветОтСервера.ПолучитьТелоКакСтроку();

	ЧитаемXML = Новый ЧтениеXML;
	ЧитаемXML.УстановитьСтроку(XML);
	
	ПостроительDOM = Новый ПостроительDOM;
	DOM = ПостроительDOM.Прочитать(ЧитаемXML);
	
	Результат.emdrId			= ПолучитьСодержимоеЭлемента(DOM, "emdrId");
	Результат.registrationDate	= ПолучитьСодержимоеЭлемента(DOM, "registrationDate");
	Результат.storeTillDate		= ПолучитьСодержимоеЭлемента(DOM, "storeTillDate");

	ТэгиRegistrationWarnings = DOM.ПолучитьЭлементыПоИмени("http://egisz.rosminzdrav.ru/iehr/emdr/service/","registrationWarnings");
	
	Если ТэгиRegistrationWarnings.Количество() > 0 Тогда
		RegistrationWarnings  = ТэгиRegistrationWarnings[0];
		
		ТэгиItem = RegistrationWarnings.ПолучитьЭлементыПоИмени("item");
		
		Для Каждого Item Из ТэгиItem Цикл
			Деталь = Новый Структура("Код, Сообщение");
			Деталь.Код			= ПолучитьСодержимоеЭлемента(Item, "code");
			Деталь.Сообщение	= ПолучитьСодержимоеЭлемента(Item, "message");
			
			Результат.Предупреждения.Добавить(Деталь);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

Функция РазобратьРезультатЗапросаМетаданныхДокумента(ТелоОтветаОтСервера) Экспорт
	
	Результат = Новый Структура;
	
	XML = ТелоОтветаОтСервера;

	ЧитаемXML = Новый ЧтениеXML;
	ЧитаемXML.УстановитьСтроку(XML);
	
	ПостроительDOM = Новый ПостроительDOM;
	DOM = ПостроительDOM.Прочитать(ЧитаемXML);
	
	Найденные = DOM.ПолучитьЭлементыПоИмени("http://egisz.rosminzdrav.ru/iehr/emdr/service/","metadata");
	
	Если Найденные.Количество() > 0 Тогда
		ТэгMetadata = Найденные[0];
		Dom2Структура(ТэгMetadata, Результат);
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

Функция РазобратьРезультатПоискаДокументов(ТелоОтветаОтСервера) Экспорт
	
	Результат = Новый Структура("Найденные, КоличествоЭлементовНаСтранице, ЕстьЕщеСтраницы", Новый Массив);
	
	XML = ТелоОтветаОтСервера;

	ЧитаемXML = Новый ЧтениеXML;
	ЧитаемXML.УстановитьСтроку(XML);
	
	ПостроительDOM = Новый ПостроительDOM;
	DOM = ПостроительDOM.Прочитать(ЧитаемXML);
	
	ТэгиItem = DOM.ПолучитьЭлементыПоИмени("http://egisz.rosminzdrav.ru/iehr/emdr/service/","item");
	
	Для Каждого item Из ТэгиItem Цикл
		Документ = Новый Структура;
		
		Для Каждого Узел Из item.ДочерниеУзлы Цикл
			ИмяУзла = УбратьПрефиксИзИмени(Узел.ИмяУзла);
			Документ.Вставить(ИмяУзла, Узел.ТекстовоеСодержимое);
		КонецЦикла;
		
		Результат.Найденные.Добавить(Документ);
	КонецЦикла;
	
	Результат.КоличествоЭлементовНаСтранице	= ПолучитьСодержимоеЭлемента(DOM, "itemsPerPage");
	Результат.ЕстьЕщеСтраницы				= ПолучитьСодержимоеЭлемента(DOM, "hasNext");
	
	Возврат Результат;
КонецФункции



#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция УбратьПрефиксИзИмени(ИмяУзла)
	
	Номер = стрНайти(ИмяУзла, ":");
	Если Номер > 0 Тогда
		Возврат Прав(ИмяУзла, стрДлина(ИмяУзла) - Номер);
	Иначе
		Возврат ИмяУзла;
	КонецЕсли;
	
КонецФункции

Процедура Dom2Структура(Dom, Результат) Экспорт
	
	Для Каждого Узел Из Dom.ДочерниеУзлы Цикл
		ИмяУзла = УбратьПрефиксИзИмени(Узел.ИмяУзла);
		Если Узел.ДочерниеУзлы.Количество() > 0 И Узел.ДочерниеУзлы[0].ИмяУзла <> "#text" Тогда			
			Результат.Вставить(ИмяУзла, Новый Структура);
			Dom2Структура(Узел, Результат[ИмяУзла]);		
		Иначе
			Результат.Вставить(ИмяУзла, Узел.ТекстовоеСодержимое);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры



#КонецОбласти