#Область ПрограммныйИнтерфейс

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ПЕРЕЧИСЛЕНИЯМИ

// Функция формирует имя файла выбрасывая из первоначально предложенного имени все запрещенные символы.
//
// Параметры:
//  ИмяФайла - Строка	 - содержащая имя файла, без каталога.
// 
// Возвращаемое значение:
//  Строка - имя файла, которое может быть использовано в файловой системе.
//
Функция УдалитьЗапрещенныеСимволыИмени(Знач ИмяФайла) Экспорт

	ИтоговоеИмяФайла = СокрЛП(ИмяФайла);
	
	Если ПустаяСтрока(ИтоговоеИмяФайла) Тогда
		
		Возврат ИтоговоеИмяФайла;
		
	КонецЕсли;
	
	СписокСимволов = ПолучитьСписокЗапрещенныхСимволовВИменахФайлов();
	
	Для Каждого СтрокаЗапретногоСимвола  Из СписокСимволов Цикл
		
		ИтоговоеИмяФайла = СтрЗаменить(ИтоговоеИмяФайла,  СтрокаЗапретногоСимвола.Значение, "");			
		
	КонецЦикла;
	
	Возврат ИтоговоеИмяФайла;

КонецФункции // УдалитьЗапрещенныеСимволыИмени()

// Функция возвращает список запрещенных символов в именах файлов.
//
// Возвращаемое значение:
//   СписокЗначений - Список значений в котором хранится список всех запрещенных символов в именах файлов.
//
Функция ПолучитьСписокЗапрещенныхСимволовВИменахФайлов()
	
	СписокСимволов = Новый СписокЗначений();
	
	СписокСимволов.Добавить("\");
	СписокСимволов.Добавить("/");
	СписокСимволов.Добавить(":");
	СписокСимволов.Добавить("*");
	СписокСимволов.Добавить("&");
	СписокСимволов.Добавить("""");
	СписокСимволов.Добавить("<");
	СписокСимволов.Добавить(">");
	СписокСимволов.Добавить("|");
	
	Возврат СписокСимволов;
	
КонецФункции

// Позволяет определить есть ли среди реквизитов шапки документа
//  реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - Строка - строковое имя искомого реквизита, 
//  МетаданныеДокумента - Неопределено - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Булево - Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитДокумента(ИмяРеквизита, МетаданныеДокумента) Экспорт

	Если МетаданныеДокумента.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли; 

КонецФункции // ЕстьРеквизитДокумента()

// Функция ПрочитатьXMLВТаблицу преобразует текст формата XML в таблицу значений,
// при этом колонки таблицы формируются на основе описания в XML.
//
// Параметры:
//  ТекстXML     - текст формата XML.
//
// Возвращаемое значение:
//  ТаблицаЗначений.
//
Функция ПрочитатьXMLВТаблицу(ТекстXML) Экспорт
	
	Чтение = Новый ЧтениеXML;
	Чтение.УстановитьСтроку(ТекстXML);
	
	// Прочитаем первый узел и проверим его.
	Если Не Чтение.Прочитать() Тогда
		ВызватьИсключение("Пустой XML");
	ИначеЕсли Чтение.Имя <> "Items" Тогда
		ВызватьИсключение("Ошибка в структуре XML");
	КонецЕсли;
	
	// Получим описание таблицы и создадим ее.
	ИмяТаблицы = Чтение.ПолучитьАтрибут("Description");
	ИменаКолонок = СтрЗаменить(Чтение.ПолучитьАтрибут("Columns"), ",", Символы.ПС);
	Колонок = СтрЧислоСтрок(ИменаКолонок);
	
	ТаблицаЗначений = Новый ТаблицаЗначений;
	Для Сч = 1 По Колонок Цикл
		ТаблицаЗначений.Колонки.Добавить(СтрПолучитьСтроку(ИменаКолонок, Сч), Новый ОписаниеТипов("Строка"));
	КонецЦикла;
	
	// Заполним значения в таблице.
	Пока Чтение.Прочитать() Цикл
		
		Если Чтение.ТипУзла <> ТипУзлаXML.НачалоЭлемента Тогда
			Продолжить;
		ИначеЕсли Чтение.Имя <> "Item" Тогда
			ВызватьИсключение("Ошибка в структуре XML");
		КонецЕсли;
		
		новСтр = ТаблицаЗначений.Добавить();
		Для Сч = 1 По Колонок Цикл
			ИмяКолонки = СтрПолучитьСтроку(ИменаКолонок, Сч);
			новСтр[Сч-1] = Чтение.ПолучитьАтрибут(ИмяКолонки);
		КонецЦикла;
		
	КонецЦикла;
	
	// Заполним результат
	Результат = Новый Структура;
	Результат.Вставить("ИмяТаблицы", ИмяТаблицы);
	Результат.Вставить("Данные", ТаблицаЗначений);
	
	Возврат Результат;
	
КонецФункции // ПрочитатьXMLВТаблицу()

// Вызывается в серверном контексте и удаляет временные файлы на сервере 1С:Предприятие.
//
// Параметры:
//  Путь - Строка.
//
Процедура УдалитьФайлыНаСервере1СПредприятие(Путь) Экспорт
	
	ОбщегоНазначенияКлиентСервер.УдалитьКаталогСФайлами(Путь);
	
КонецПроцедуры

// Процедура обновляет номер переданного документа.
// Параметры:
//  ДокументОбъект - ДокументОбъект.
//  ТекНомер - Число.
//
Процедура СброситьУстановленныйНомерОбъекта(ДокументОбъект, ТекНомер) Экспорт

	МетаданныеДокумента = ДокументОбъект.Метаданные();
	ИмяДокумента = МетаданныеДокумента.Имя;
	
	Если НЕ (ИмяДокумента="ПриходныйКассовыйОрдер" ИЛИ ИмяДокумента="РасходныйКассовыйОрдер") Тогда
		ДокументОбъект.Номер = "";
	Иначе		
		Префикс = ДокументОбъект.Касса.Префикс;
		ОбщегоНазначенияСервер.ДобавитьПрефиксУзла(Префикс);
		ДлинаПрефикса = СтрДлина(Префикс);
		Если ДлинаПрефикса = 0 ИЛИ Лев(ТекНомер, ДлинаПрефикса) <> Префикс Тогда
			ПолныеПрава.ОбновитьНумерациюОбъекта(МетаданныеДокумента);
			ДокументОбъект.УстановитьНовыйНомер();
			ПолныеПрава.ОбновитьНумерациюОбъекта(МетаданныеДокумента);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Добавляет к префиксу номера/кода объекта префикс узла распределенной базы данных.
// Параметры:
//  Префикс - Строка - префикс для добавления.
//
Процедура ДобавитьПрефиксУзла(Префикс) Экспорт
	
	Если ПараметрыСеанса.ИспользованиеРИБ Тогда
		Префикс = ПараметрыСеанса.ПрефиксУзлаРаспределеннойИнформационнойБазы + Префикс;
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////
// 	Получение данных из БД

// Функция ПолучитьРеквизитСсылки.
//
// Параметры:
//  СсылкаНаОбъект - ЛюбаяСсылка - ссылка.
//  ИмяРеквизита - Строка - реквизит.
//
// Возвращаемое значение:
//  Произвольный.
//
Функция ПолучитьРеквизитСсылки(СсылкаНаОбъект, ИмяРеквизита) Экспорт
	
	Возврат СсылкаНаОбъект[ИмяРеквизита];
	
КонецФункции

// Функция ПолучитьРеквизитыСсылки.
//
// Параметры:
//  СсылкаНаОбъект - ЛюбаяСсылка - ссылка.
//
// Возвращаемое значение:
//  Структура.
//
Функция ПолучитьРеквизитыСсылки(СсылкаНаОбъект) Экспорт
	
	Результат = Новый Структура;
	
	МетаданныеОбъекта = СсылкаНаОбъект.Метаданные();
	Для Каждого Реквизит Из МетаданныеОбъекта.Реквизиты Цикл
		Результат.Вставить(Реквизит.Имя, СсылкаНаОбъект[Реквизит.Имя]);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Формирует структуру, содержащую значения реквизитов шапки документа.
//
// Параметры: 
//  ДокументОбъект - ДокументОбъект - объект документа для формирования структуры шапки, 
//
// Возвращаемое значение:
//  Структура - Сформированная структура.
//
Функция СформироватьСтруктуруШапкиДокумента(ДокументОбъект) Экспорт
	
	СтруктураШапкиДокумента = ПолучитьРеквизитыСсылки(ДокументОбъект);
	СтруктураШапкиДокумента.Вставить("Ссылка", ДокументОбъект.Ссылка);
	СтруктураШапкиДокумента.Вставить("Дата", ДокументОбъект.Дата);
	Попытка
		СтруктураШапкиДокумента.Вставить("МоментВремени", ДокументОбъект.МоментВремени());
	Исключение
		// Формирование структуры по пустой ссылке.
		СтруктураШапкиДокумента.Вставить("МоментВремени", ДокументОбъект.Дата);
	КонецПопытки;
	ИмяДокумента = ДокументОбъект.Метаданные().Имя;
	СтруктураШапкиДокумента.Вставить("ВидДокумента",  ИмяДокумента);

	Возврат СтруктураШапкиДокумента;
	
КонецФункции // СформироватьСтруктуруШапкиДокумента()

// Считывает из БД и возвращает значение константы.
// Параметры:
//  ИмяКонстанты - Строка
//
// Возвращаемое значение:
//  Произвольный.
//
Функция ПолучитьЗначениеКонстанты(ИмяКонстанты) Экспорт
	
	Возврат Константы[ИмяКонстанты].Получить();
	
КонецФункции

// Функция формирует представление заголовка документа.
//
// Параметры:
//  Документ			 - ДокументСсылка - документ.
//  НазваниеДокумента	 - Строка	 - название для подстановки в представление документа.
// 
// Возвращаемое значение:
//  Строка - представление номера документа.
//
&НаСервере
Функция СформироватьЗаголовокДокумента(Документ, НазваниеДокумента = "") Экспорт

	Возврат НазваниеДокумента + " № " + ПолучитьНомерНаПечать(Документ)
	                          + " от " + Формат(Документ.Дата, "ДФ='дд ММММ гггг'") + " г.";

КонецФункции // СформироватьЗаголовокДокумента()

// Процедура предназначена для преобразования номера документа.
//
// Параметры:
//  Документ - ДокументСсылка - документ, чей номер надо получить для печати.
//
// Возвращаемое значение.
//  Строка - номер документа для печати.
//
&НаСервере
Функция ПолучитьНомерНаПечать(Документ, МассивПрефиксов = Неопределено) Экспорт

	Если Документ = Неопределено Тогда 
		Возврат 0;
	КонецЕсли;

	Номер   = СокрЛП(Документ.Номер);
	Префикс = "";
	Если МассивПрефиксов = Неопределено Тогда
		
		МассивПрефиксовДляОбхода = Новый Массив;
		ПрефиксРИБ = Константы.ПрефиксУзлаРаспределеннойИнформационнойБазы.Получить();
		Если ЗначениеЗаполнено(ПрефиксРИБ) Тогда
			МассивПрефиксовДляОбхода.Добавить(ПрефиксРИБ);
		КонецЕсли;
		
	Иначе
		
		МассивПрефиксовДляОбхода = МассивПрефиксов;
		
	КонецЕсли;
	
	Для Каждого ТекущийПрефикс Из МассивПрефиксовДляОбхода Цикл
		
		// Удаление префикса из номера документа.
		Если Найти(Номер, ТекущийПрефикс)=1 Тогда 
			Номер = Сред(Номер, СтрДлина(ТекущийПрефикс)+1);
		КонецЕсли;
		
		// Так же, может остаться "минус" впереди.
		Если Лев(Номер, 1) = "-" Тогда
			Номер = Сред(Номер, 2);
		КонецЕсли;
		
		// Удаление ведущих нулей
		Пока Лев(Номер, 1)="0" Цикл
			Номер = Сред(Номер, 2);
		КонецЦикла;
	КонецЦикла;

	Номер = СокрЛП(Номер);
	Возврат Номер	

КонецФункции // ПолучитьНомерНаПечать()

// Стандартная процедура проверки корректности заполнения элемента
// по заполненности обязательных реквизитов и уникальности уникальных.
// Параметры:
//  ЭтотОбъект - СправочникОбъект.
//  Ошибки - Строка - текст ошибки.
//  ДопРеквизиты - Структура - дополнительные реквизиты.
//  Заполнение - Булево - По умолчанию Истина
//  Уникальность - Булево - По умолчанию Истина
//
// Возвращаемое значение:
//  Булево.
//
Функция ПроверитьКорректностьЗаполненияСправочника(ЭтотОбъект, Ошибки="", ДопРеквизиты=Неопределено, Заполнение=Истина, Уникальность=Истина) Экспорт
	Результат=Истина;
	
	// Определимся, это элемент или группа (для плана счетов всегда элемент).
	Попытка  
		ЭтоГруппа = ЭтотОбъект.ЭтоГруппа;
	Исключение 
		ЭтоГруппа = Ложь;
	КонецПопытки;
	// Список обязательных реквизитов объекта.
	Реквизиты = ЭтотОбъект.ПолучитьОбязательныеРеквизиты(НЕ ЭтоГруппа, ЭтоГруппа);

	ЭтотОбъектМетаданные=ЭтотОбъект.Метаданные();
	
	// Добавим дополнительные реквизиты.
	Если ДопРеквизиты<>Неопределено Тогда
		Для каждого ДопРеквизит Из ДопРеквизиты Цикл
			Реквизиты.Вставить(ДопРеквизит.Ключ,ДопРеквизит.Значение);
		КонецЦикла;
	КонецЕсли;
	
	// Проверим установим заранее владельца, чтобы ниже в циклах этим не заниматься.
	ЭтоСправочник=Ложь; Владелец=Неопределено;
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(ЭтотОбъект.Ссылка)) Тогда // Владелец только у справочнков бывает.
		ЭтоСправочник=Истина;
		Если ЗначениеЗаполнено(ЭтотОбъект.Владелец) Тогда
			Владелец=ЭтотОбъект.Владелец;
		КонецЕсли;
	КонецЕсли;
	
	Для каждого Реквизит Из Реквизиты Цикл
		Если ТипЗнч(Реквизит.Значение)=Тип("Структура") Тогда
			// Проверяем табличную часть
			ТабличнаяЧасть=ЭтотОбъект[Реквизит.Ключ];
			СписокНайденныхДублей=Новый СписокЗначений();
			Для каждого СтрокаТаблицы Из ТабличнаяЧасть Цикл
				// Создадим структуру отбора для проверки уникальности реквизитов.
				Если Уникальность Тогда СтруктураОтбора=Новый Структура(); КонецЕсли;
				// Переберем обязательные реквизиты.
				Для каждого РеквизитТаблицы Из Реквизит.Значение Цикл
					Если (Заполнение) И (РеквизитТаблицы.Значение<>2) И (РеквизитТаблицы.Значение>0) И Не ЗначениеЗаполнено(СтрокаТаблицы[РеквизитТаблицы.Ключ]) Тогда
						Результат=Ложь;
						Ошибки=Ошибки+"Таблица <"+ОбщегоНазначения.ПолучитьСинонимРеквизита(ЭтотОбъектМетаданные,,Реквизит.Ключ)+"> значение колонки <"+ОбщегоНазначения.ПолучитьСинонимРеквизита(ЭтотОбъектМетаданные,РеквизитТаблицы.Ключ,Реквизит.Ключ)+"> не заполнено ! Строка номер "+СокрЛП(СтрокаТаблицы.НомерСтроки)+Символы.ПС;
						Продолжить; // Если реквизит таблицы не заполнен, проверять его уникальность нет смысла.
					КонецЕсли;
					// Заполнение структуры отбора для проверки уникальности реквизитов.
					Если Уникальность И РеквизитТаблицы.Значение>1 Тогда
						СтруктураОтбора.Вставить(СокрЛП(РеквизитТаблицы.Ключ),СтрокаТаблицы[РеквизитТаблицы.Ключ]);
					КонецЕсли;
				КонецЦикла;
				// Проверка уникальности
				Если Уникальность И СтруктураОтбора.Количество()>0 И СписокНайденныхДублей.НайтиПоЗначению(СтрокаТаблицы)=Неопределено Тогда
					// Поиск строки удовлетворяющие структуре отбора.
					НайденныеСтроки=ТабличнаяЧасть.НайтиСтроки(СтруктураОтбора);
					// Если нашли и их болше 1, то строки не уникальные.
					Если НайденныеСтроки.Количество()>1 Тогда
						// Добавим строку в список найденных дублей, что бы не сообщать о ней еще раз.
						Результат=Ложь;
						ДублирующиесяСтроки=""; 
						// Выведем строку сообщения
						Для каждого НайденнаяСтрока Из НайденныеСтроки Цикл 
							ДублирующиесяСтроки=ДублирующиесяСтроки+","+СокрЛП(НайденнаяСтрока.НомерСтроки);
							// Добавим строку в список найденных дублей, что бы не сообщать о ней еще раз.
							СписокНайденныхДублей.Добавить(НайденнаяСтрока);
						КонецЦикла;
						СтрокаРеквизитов="";
						Для каждого РеквизитТаблицы Из СтруктураОтбора Цикл
							СтрокаРеквизитов=СтрокаРеквизитов+?(ПустаяСтрока(СтрокаРеквизитов),"",",")+РеквизитТаблицы.Ключ;
						КонецЦикла;
						Ошибки=Ошибки+"Таблица <"+ОбщегоНазначения.ПолучитьСинонимРеквизита(ЭтотОбъектМетаданные,,Реквизит.Ключ)+"> значения колонки <"+ОбщегоНазначения.ПолучитьСинонимРеквизита(ЭтотОбъектМетаданные,РеквизитТаблицы.Ключ,Реквизит.Ключ)+"> не уникальны ! Строки: "+Сред(ДублирующиесяСтроки,2)+Символы.ПС;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			
		Иначе // Обычный реквизит справочника / ПВХ (не табличная часть).
			// Сначала проверим заполнение (параметры структуры 1 или 3).
			Если Заполнение 
				и ((Реквизит.Значение=1) Или (Реквизит.Значение=3) Или (Реквизит.Значение=Неопределено))
				И Не ЗначениеЗаполнено(ЭтотОбъект[Реквизит.Ключ]) Тогда
				Результат=Ложь;
				Ошибки=Ошибки+"Реквизит """+ОбщегоНазначения.ПолучитьСинонимРеквизита(ЭтотОбъектМетаданные,Реквизит.Ключ)+""" не заполнен !"+Символы.ПС;
				Продолжить; 
			КонецЕсли;
			// Теперь проверим уникальность (параметры структуры 2 или 3)
			// проверку сделаем прямым сравнением (а не >2) во избежании ошибки при нечисловом типе значения.
			Если (Уникальность) И ((Реквизит.Значение=2)ИЛИ(Реквизит.Значение=3)) Тогда
				ИмяОбъекта = ЭтотОбъект.Метаданные().Имя;
				Если Метаданные.Справочники.Найти(ИмяОбъекта) <> Неопределено Тогда
					// Справочник
					Менеджер=Справочники[ЭтотОбъект.Метаданные().Имя];
				ИначеЕсли Метаданные.ПланыВидовХарактеристик.Найти(ИмяОбъекта) <> Неопределено Тогда
					// ПВХ
					Менеджер=ПланыВидовХарактеристик[ЭтотОбъект.Метаданные().Имя];
				ИначеЕсли Метаданные.ПланыВидовРасчета.Найти(ИмяОбъекта) <> Неопределено Тогда
					// ПВР
					Менеджер=ПланыВидовРасчета[ЭтотОбъект.Метаданные().Имя];
				Иначе
				КонецЕсли;
				
				Если Реквизит.Ключ="Наименование" Тогда
					Если ЭтоСправочник Тогда
						НайденнаяСсылка=Менеджер.НайтиПоНаименованию(ЭтотОбъект.Наименование,Истина,,Владелец);
					Иначе
						НайденнаяСсылка=Менеджер.НайтиПоНаименованию(ЭтотОбъект.Наименование,Истина);
					КонецЕсли;
				ИначеЕсли Реквизит.Ключ="Код" Тогда
					Если ЭтоСправочник Тогда
						НайденнаяСсылка=Менеджер.НайтиПоКоду(ЭтотОбъект.Код,,,Владелец);
					Иначе
						НайденнаяСсылка=Менеджер.НайтиПоКоду(ЭтотОбъект.Код);
					КонецЕсли;
				Иначе // Реквизит.
					Если ЭтоСправочник Тогда
						НайденнаяСсылка=Менеджер.НайтиПоРеквизиту(Реквизит.Ключ,ЭтотОбъект[Реквизит.Ключ],,Владелец);
					Иначе
						НайденнаяСсылка=Менеджер.НайтиПоРеквизиту(Реквизит.Ключ,ЭтотОбъект[Реквизит.Ключ]);
					КонецЕсли;
				КонецЕсли;
				
				Если (ЗначениеЗаполнено(НайденнаяСсылка)) И (НайденнаяСсылка<>ЭтотОбъект.Ссылка) Тогда
					Результат=Ложь;
					Ошибки=Ошибки+"Реквизит """+ОбщегоНазначения.ПолучитьСинонимРеквизита(ЭтотОбъектМетаданные,Реквизит.Ключ)+""" не уникален !";
					Если ЗначениеЗаполнено(Владелец) Тогда
						Ошибки=Ошибки+" (В пределах владельца: "+СокрЛП(Владелец)+")";
					КонецЕсли;
					Ошибки=Ошибки+Символы.ПС;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции 

// Функция ЗапуститьОбработкуОбновления.
//
// Возвращаемое значение:
//  Структура.
//
Функция ЗапуститьОбработкуОбновления() Экспорт
	Возврат БИТ_ОбновлениеИнформационнойБазы.ВыполнитьОбновление();
КонецФункции

// Функция ПолучитьОписаниеТипаПоНаименованию.
//
// Параметры:
//  ИмяТипа - Строка
//
// Возвращаемое значение:
//  Массив.
//
Функция ПолучитьОписаниеТипаПоНаименованию(ИмяТипа) Экспорт
	
	мас = Новый Массив;
	мас.Добавить(Тип(ИмяТипа));
	Возврат Новый ОписаниеТипов(мас);		
	
КонецФункции	

// Получает состав комплектующих для номенклатуры типа набор по переданной ссылке на номенклатуру.
// Параметры:
//  Ном - СправочникСсылка.Номенклатура - номенклатура.
//
// Возвращаемое значение:
//  Массив.
//
Функция ПолучитьСоставНабора(Ном) Экспорт
	
	Комплектующие = Новый Массив;

	Запрос = Новый Запрос("ВЫБРАТЬ
	                      |	НоменклатураКомплектующиеНоменклатуры.Комплектующая КАК Комплектующая,
	                      |	НоменклатураКомплектующиеНоменклатуры.ХарактеристикаКомплектующей,
	                      |	НоменклатураКомплектующиеНоменклатуры.Количество,
	                      |	НоменклатураКомплектующиеНоменклатуры.ЕдиницаИзмерения,
	                      |	ВЫБОР
	                      |		КОГДА НоменклатураКомплектующиеНоменклатуры.Комплектующая.ВидНоменклатуры = ЗНАЧЕНИЕ(Перечисление.Видыноменклатуры.Услуга)
	                      |			ТОГДА ИСТИНА
	                      |		ИНАЧЕ ЛОЖЬ
	                      |	КОНЕЦ КАК ЭтоУслуга,
	                      |	ВЫБОР
	                      |		КОГДА НоменклатураКомплектующиеНоменклатуры.Комплектующая.ВидНоменклатуры = ЗНАЧЕНИЕ(Перечисление.Видыноменклатуры.Материал)
	                      |			ТОГДА ИСТИНА
	                      |		ИНАЧЕ ЛОЖЬ
	                      |	КОНЕЦ КАК ЭтоТовар
	                      |ИЗ
	                      |	Справочник.Номенклатура.КомплектующиеНоменклатуры КАК НоменклатураКомплектующиеНоменклатуры
	                      |		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Номенклатура КАК Номенклатура
	                      |		ПО НоменклатураКомплектующиеНоменклатуры.Ссылка = Номенклатура.Ссылка
	                      |ГДЕ
	                      |	Номенклатура.ВидНоменклатуры = ЗНАЧЕНИЕ(Перечисление.ВидыНоменклатуры.Набор)
	                      |	И Номенклатура.Ссылка = &Ном");
						  
	Запрос.УстановитьПараметр("Ном", Ном);
	
	выборка = Запрос.Выполнить().Выбрать();
	
	Пока выборка.Следующий() Цикл
		
		нс = Новый Структура;
		нс.Вставить("Комплектующая", выборка.Комплектующая);
		нс.Вставить("ХарактеристикаКомплектующей", выборка.ХарактеристикаКомплектующей);
		нс.Вставить("Количество", выборка.Количество);
		нс.Вставить("ЕдиницаИзмерения", выборка.ЕдиницаИзмерения);
		нс.Вставить("ЭтоУслуга"	, выборка.ЭтоУслуга);
		нс.Вставить("ЭтоТовар"	, выборка.ЭтоТовар);
		комплектующие.Добавить(нс);
		
	КонецЦикла;
	
	Возврат комплектующие;
	
КонецФункции 

// Процедура ИнвертироватьПометкуУдаления.
//
// Параметры:
//  Свойство - ЛюбаяСсылка.
//
Процедура ИнвертироватьПометкуУдаления(Свойство) Экспорт
	
	ОбъектОбр =  Свойство.ПолучитьОбъект();
    ОбъектОбр.УстановитьПометкуУдаления(НЕ ОбъектОбр.ПометкаУдаления);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// 	РАБОТА С СКД

// Функция подготавливает структуру данных из исходной таблицы значений по переданным параметрам и схеме компоновки.
//
// Параметры:
//  СтруктураНастроек - Структура
//  СхемаКомпоновкиДанных - СхемаКомпоновкиДанных
//
// Возвращаемое значение:
//  Стрруктура - данные, результат выполнения переданной схемы компоновки.
//
Функция ПодготовитьСтруктуруДанных(СтруктураНастроек, СхемаКомпоновкиДанных, ВнешниеНаборыДанныхДоп = Неопределено) Экспорт
	
	СтруктураРезультата = ПолучитьПустуюСтруктуруРезультата();
	
	////////////////////////////////////////////////////////////////////////////////
	// ПОДГОТОВКА СХЕМЫ КОМПОНОВКИ ДАННЫХ И КОМПОНОВЩИКА НАСТРОЕК СКД.
	
	// Подготовка компоновщика макета компоновки данных.
	Компоновщик = Новый КомпоновщикНастроекКомпоновкиДанных;
	Компоновщик.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаКомпоновкиДанных));
	Компоновщик.ЗагрузитьНастройки(СхемаКомпоновкиДанных.НастройкиПоУмолчанию);
	// Компоновщик.Настройки.Отбор.Элементы.Очистить();
	
	// Отбор компоновщика настроек.
	Если СтруктураНастроек.КомпоновщикНастроек <> Неопределено Тогда
		СкопироватьЭлементы(Компоновщик.Настройки.Отбор, СтруктураНастроек.КомпоновщикНастроек.Настройки.Отбор);
		
		Для Каждого ПараметрДанных Из СтруктураНастроек.КомпоновщикНастроек.Настройки.ПараметрыДанных.Элементы Цикл
			Компоновщик.Настройки.ПараметрыДанных.УстановитьЗначениеПараметра(ПараметрДанных.Параметр, ПараметрДанных.Значение);
		КонецЦикла;
	КонецЕсли;
	
	// Выбранные поля компоновщика настроек.
	Для Каждого ОбязательноеПоле Из СтруктураНастроек.ОбязательныеПоля Цикл
		ПолеСКД = НайтиПолеСКДПоПолномуИмени(Компоновщик.Настройки.Выбор.ДоступныеПоляВыбора.Элементы, ОбязательноеПоле);
		Если ПолеСКД <> Неопределено Тогда
			ВыбранноеПоле = Компоновщик.Настройки.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
			ВыбранноеПоле.Поле = ПолеСКД.Поле;
		КонецЕсли;
	КонецЦикла;
	
	// Компоновка макета компоновки данных.
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	МакетКомпоновкиДанных = КомпоновщикМакета.Выполнить(СхемаКомпоновкиДанных, Компоновщик.Настройки,,,Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"));
	
	////////////////////////////////////////////////////////////////////////////////
	// ПОДГОТОВКА ВСПОМОГАТЕЛЬНЫХ ДАННЫХ ДЛЯ СОПОСТАВЛЕНИЯ ПОЛЕЙ ШАБЛОНА И СКД.
	
	Для каждого Поле Из МакетКомпоновкиДанных.НаборыДанных.НаборДанных.Поля Цикл
		СтруктураРезультата.СоответствиеПолейСКДКолонкамТаблицыРезультата.Вставить(СтрЗаменить(ПолучитьИмяПоляВШаблоне(Поле.ПутьКДанным),".",""), Поле.Имя);
	КонецЦикла;
	
	////////////////////////////////////////////////////////////////////////////////
	// ВЫПОЛНЕНИЕ ЗАПРОСА
	ТаблицаРезультата = Новый ТаблицаЗначений;
	
	ВнешниеНаборыДанных = Новый Структура("Данные",СтруктураНастроек.ИсходныеДанные);
	Если ТипЗнч(ВнешниеНаборыДанныхДоп) = Тип("Структура") Тогда
		Для Каждого Набор Из ВнешниеНаборыДанныхДоп Цикл
			Если Набор.Ключ <> "Данные" Тогда
				ВнешниеНаборыДанных.Вставить(Набор.Ключ, Набор.Значение);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ПроцессорКомпоновки = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновки.Инициализировать(МакетКомпоновкиДанных, ВнешниеНаборыДанных,,Истина);
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	ПроцессорВывода.УстановитьОбъект(ТаблицаРезультата);
	ПроцессорВывода.Вывести(ПроцессорКомпоновки);
	
	Для Каждого Колонка Из ТаблицаРезультата.Колонки Цикл
		ИмяПоля = СтруктураРезультата.СоответствиеПолейСКДКолонкамТаблицыРезультата.Получить(Колонка.Имя);
		Если ИмяПоля <> Неопределено И ИмяПоля <> Колонка.Имя Тогда
			Колонка.Имя = ИмяПоля;
		КонецЕсли;
	КонецЦикла;
	
	СтруктураРезультата.Вставить("ТаблицаРезультат", ТаблицаРезультата);
	Возврат СтруктураРезультата;
	
КонецФункции

// Найти поле СКД по полному имени.
//
// Параметры:
//  Элементы - ВсеЭлементыФормы - элементы формы.
//  ПолноеИмя - Строка.
//
// Возвращаемое значение:
//  ПолеКомпоновкиДанных.
//
Функция НайтиПолеСКДПоПолномуИмени(Элементы, ПолноеИмя) Экспорт
	
	масЧастейИмен = ИзПолногоИмениПоляПолучитьЧасти(ПолноеИмя);
	колЧастей = масЧастейИмен.Количество();
	
	текИмя = масЧастейИмен[0];
	Поле = НайтиПолеСКДПоИмени(Элементы, текИмя);
	Если Поле = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Для Сч = 2 По колЧастей Цикл
		текИмя = текИмя +"." + масЧастейИмен[Сч-1];
		Поле = НайтиПолеСКДПоИмени(Поле.Элементы, текИмя);
		Если Поле = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Поле;
	
КонецФункции // НайтиПолеСКДПоПолномуИмени()

// Среди элементов полей СКД найти поле по имени.
//
// Параметры:
//  Элементы - Массив	 - произвольна
//  Имя		 - Строка	 - имя поля.
// 
// Возвращаемое значение:
//  ПолеКомпоновкиДанных.
//
Функция НайтиПолеСКДПоИмени(Элементы, Имя)
	
	Для Каждого Элемент Из Элементы Цикл
		Если ВРЕГ(Строка(Элемент.Поле)) = ВРЕГ(Имя) Тогда
			Возврат Элемент;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции // НайтиПолеСКДПоИмени()

// Полное имя поля разделить по частям.
//
// Параметры:
//  ПолноеИмя	 - Строка	 - полное имя.
// 
// Возвращаемое значение:
//  Массив.
//
Функция ИзПолногоИмениПоляПолучитьЧасти(ПолноеИмя)
	
	масЧастей = Новый Массив;
	СтрИмя = ПолноеИмя;
	
	Пока Не ПустаяСтрока(СтрИмя) Цикл
		Если Лев(СтрИмя, 1) = "[" Тогда
			
			Поз = Найти(СтрИмя, "]");
			Если Поз = 0 Тогда
				масЧастей.Добавить(Сред(СтрИмя, 2));
				СтрИмя = "";
			Иначе
				масЧастей.Добавить(Сред(СтрИмя, 1, Поз));
				СтрИмя = Сред(СтрИмя, Поз + 2);
			КонецЕсли;
			
		Иначе
			
			Поз = Найти(СтрИмя, ".");
			Если Поз = 0 Тогда
				масЧастей.Добавить(СтрИмя);
				СтрИмя = "";
			Иначе
				масЧастей.Добавить(Лев(СтрИмя, Поз - 1));
				СтрИмя = Сред(СтрИмя, Поз + 1);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат масЧастей;
	
КонецФункции // ИзПолногоИмениПоляПолучитьЧасти()

// Функция выполняет получение имени поля из доступных полей компоновки данных.
//
// Параметры:
//  ИмяПоля - Строка
//
// Возвращаемое значение:
//  Строка.
//
Функция ПолучитьИмяПоляВШаблоне(Знач ИмяПоля) Экспорт
	
	ИмяПоля = СтрЗаменить(ИмяПоля, ".DeletionMark", ".ПометкаУдаления");
	ИмяПоля = СтрЗаменить(ИмяПоля, ".Owner", ".Владелец");
	ИмяПоля = СтрЗаменить(ИмяПоля, ".Code", ".Код");
	ИмяПоля = СтрЗаменить(ИмяПоля, ".Parent", ".Родитель");
	ИмяПоля = СтрЗаменить(ИмяПоля, ".Predefined", ".Предопределенный");
	ИмяПоля = СтрЗаменить(ИмяПоля, ".IsFolder", ".ЭтоГруппа");
	ИмяПоля = СтрЗаменить(ИмяПоля, ".Description", ".Наименование");
	Возврат ИмяПоля;
	
КонецФункции // ПолучитьИмяПоляВШаблоне()

// Копирует элементы из одной коллекции в другую.
// Параметры:
//  ПриемникЗначения - Неопределено
//  ИсточникЗначения - Неопределено
//  ПроверятьДоступность - Булево - По умолчанию Ложь
//  ОчищатьПриемник - Булево - По умолчанию Истина
//
Процедура СкопироватьЭлементы(ПриемникЗначения, ИсточникЗначения, ПроверятьДоступность = Ложь, ОчищатьПриемник = Истина) Экспорт
	
	Если ТипЗнч(ИсточникЗначения) = Тип("УсловноеОформлениеКомпоновкиДанных")
		ИЛИ ТипЗнч(ИсточникЗначения) = Тип("ВариантыПользовательскогоПоляВыборКомпоновкиДанных")
		ИЛИ ТипЗнч(ИсточникЗначения) = Тип("ОформляемыеПоляКомпоновкиДанных")
		ИЛИ ТипЗнч(ИсточникЗначения) = Тип("ЗначенияПараметровДанныхКомпоновкиДанных") Тогда
		СоздаватьПоТипу = Ложь;
	Иначе
		СоздаватьПоТипу = Истина;
	КонецЕсли;
	ПриемникЭлементов = ПриемникЗначения.Элементы;
	ИсточникЭлементов = ИсточникЗначения.Элементы;
	Если ОчищатьПриемник Тогда
		ПриемникЭлементов.Очистить();
	КонецЕсли;
	
	Для каждого ЭлементИсточник Из ИсточникЭлементов Цикл
		
		Если ТипЗнч(ЭлементИсточник) = Тип("ЭлементПорядкаКомпоновкиДанных") Тогда
			// Элементы порядка добавляем в начало.
			Индекс = ИсточникЭлементов.Индекс(ЭлементИсточник);
			ЭлементПриемник = ПриемникЭлементов.Вставить(Индекс, ТипЗнч(ЭлементИсточник));
		Иначе
			Если СоздаватьПоТипу Тогда
				ЭлементПриемник = ПриемникЭлементов.Добавить(ТипЗнч(ЭлементИсточник));
			Иначе
				ЭлементПриемник = ПриемникЭлементов.Добавить();
			КонецЕсли;
		КонецЕсли;
		
		ЗаполнитьЗначенияСвойств(ЭлементПриемник, ЭлементИсточник);
		// В некоторых коллекциях необходимо заполнить другие коллекции.
		Если ТипЗнч(ИсточникЭлементов) = Тип("КоллекцияЭлементовУсловногоОформленияКомпоновкиДанных") Тогда
			СкопироватьЭлементы(ЭлементПриемник.Поля, ЭлементИсточник.Поля);
			СкопироватьЭлементы(ЭлементПриемник.Отбор, ЭлементИсточник.Отбор);
			ЗаполнитьЭлементы(ЭлементПриемник.Оформление, ЭлементИсточник.Оформление); 
		ИначеЕсли ТипЗнч(ИсточникЭлементов)	= Тип("КоллекцияВариантовПользовательскогоПоляВыборКомпоновкиДанных") Тогда
			СкопироватьЭлементы(ЭлементПриемник.Отбор, ЭлементИсточник.Отбор);
		КонецЕсли;
		
		// В некоторых элементах коллекции необходимо заполнить другие коллекции.
		Если ТипЗнч(ЭлементИсточник) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
			СкопироватьЭлементы(ЭлементПриемник, ЭлементИсточник);
		ИначеЕсли ТипЗнч(ЭлементИсточник) = Тип("ГруппаВыбранныхПолейКомпоновкиДанных") Тогда
			СкопироватьЭлементы(ЭлементПриемник, ЭлементИсточник);
		ИначеЕсли ТипЗнч(ЭлементИсточник) = Тип("ПользовательскоеПолеВыборКомпоновкиДанных") Тогда
			СкопироватьЭлементы(ЭлементПриемник.Варианты, ЭлементИсточник.Варианты);
		ИначеЕсли ТипЗнч(ЭлементИсточник) = Тип("ПользовательскоеПолеВыражениеКомпоновкиДанных") Тогда
			ЭлементПриемник.УстановитьВыражениеДетальныхЗаписей (ЭлементИсточник.ПолучитьВыражениеДетальныхЗаписей());
			ЭлементПриемник.УстановитьВыражениеИтоговыхЗаписей(ЭлементИсточник.ПолучитьВыражениеИтоговыхЗаписей());
			ЭлементПриемник.УстановитьПредставлениеВыраженияДетальныхЗаписей(ЭлементИсточник.ПолучитьПредставлениеВыраженияДетальныхЗаписей ());
			ЭлементПриемник.УстановитьПредставлениеВыраженияИтоговыхЗаписей(ЭлементИсточник.ПолучитьПредставлениеВыраженияИтоговыхЗаписей ());
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Процедура ЗаполнитьЭлементы.
//
// Параметры:
//  ПриемникЗначения - Неопределено
//  ИсточникЗначения - Неопределено
//  ПервыйУровень - Неопределено - По умолчанию Неопределено
//
Процедура ЗаполнитьЭлементы(ПриемникЗначения, ИсточникЗначения, ПервыйУровень = Неопределено) Экспорт
	
	Если ТипЗнч(ПриемникЗначения) = Тип("КоллекцияЗначенийПараметровКомпоновкиДанных") Тогда
		КоллекцияЗначений = ИсточникЗначения;
	Иначе
		КоллекцияЗначений = ИсточникЗначения.Элементы;
	КонецЕсли;
	
	Для каждого ЭлементИсточник Из КоллекцияЗначений Цикл
		Если ПервыйУровень = Неопределено Тогда
			ЭлементПриемник = ПриемникЗначения.НайтиЗначениеПараметра(ЭлементИсточник.Параметр);
		Иначе
			ЭлементПриемник = ПервыйУровень.НайтиЗначениеПараметра(ЭлементИсточник.Параметр);
		КонецЕсли;
		Если ЭлементПриемник = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(ЭлементПриемник, ЭлементИсточник);
		Если ТипЗнч(ЭлементИсточник) = Тип("ЗначениеПараметраКомпоновкиДанных") Тогда
			Если ЭлементИсточник.ЗначенияВложенныхПараметров.Количество() <> 0 Тогда
				ЗаполнитьЭлементы(ЭлементПриемник.ЗначенияВложенныхПараметров, ЭлементИсточник.ЗначенияВложенныхПараметров, ПриемникЗначения);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Функция ПолучитьПустуюСтруктуруРезультата.
//
// Возвращаемое значение:
//  Структура.
//
Функция ПолучитьПустуюСтруктуруРезультата() Экспорт
	
	Структура = Новый Структура;
	Структура.Вставить("ТаблицаРезультат" , Неопределено);
	Структура.Вставить("СоответствиеПолейСКДКолонкамТаблицыРезультата", Новый Соответствие);
	
	Возврат Структура;
	
КонецФункции // ПолучитьПустуюСтруктуруРезультата()

// Функция ПолучитьПустуюСтруктуруНастроек.
//
// Возвращаемое значение:
//  Структура.
//
Функция ПолучитьПустуюСтруктуруНастроек() Экспорт
	
	СтруктураНастроек = Новый Структура;
	СтруктураНастроек.Вставить("ИсходныеДанные"     , Неопределено); // Таблица с произвольными данными.
	СтруктураНастроек.Вставить("ОбязательныеПоля"   , Новый Массив); //
	СтруктураНастроек.Вставить("СоответствиеШаблоновИСтруктурыШаблонов" , Новый Соответствие); //
	СтруктураНастроек.Вставить("ПараметрыДанных"    , Новый Структура);
	СтруктураНастроек.Вставить("КомпоновщикНастроек", Неопределено); // Отбор
	СтруктураНастроек.Вставить("ИмяМакетаСхемыКомпоновкиДанных" , Неопределено);
	
	Возврат СтруктураНастроек;
	
КонецФункции

// Функция ТипСвойстваЗначениеСвойствОбъекта.
//
// Параметры:
//  мСвойство - ПланВидовХарактеристикСсылка.
//
// Возвращаемое значение:
//  Булево.
//
Функция ТипСвойстваЗначениеСвойствОбъекта(мСвойство) Экспорт
	текСвойство = мСвойство.ПолучитьОбъект();
	Если текСвойство.ТипЗначения.СодержитТип(ТипЗнч(Справочники.ЗначенияСвойствОбъектов.ПустаяСсылка())) Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
КонецФункции

// Есть характеристики у номенклатуры.
//
// Параметры:
//  Номенклатура - СправочникСсылка.Номенклатура.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЕстьХарактеристики(Номенклатура) Экспорт
	
	Характеристики = Справочники.ХарактеристикиНоменклатуры.Выбрать(, Номенклатура);
	
	Вернуть = Ложь;
	
	Пока Характеристики.Следующий() Цикл
		
		Вернуть = Истина;
		
	КонецЦикла; 
	
	Возврат Вернуть;
	
КонецФункции

// Есть серии у номенклатуры.
//
// Параметры:
//  Номенклатура - СправочникСсылка.Номенклатура.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЕстьСерии(Номенклатура) Экспорт
	
	Серии = Справочники.СерииНоменклатуры.Выбрать(, Номенклатура);
	
	Вернуть = Ложь;
	
	Пока Серии.Следующий() Цикл
		
		Вернуть = Истина;
		
	КонецЦикла; 
	
	Возврат Вернуть;
	
КонецФункции

// День недели или время.
//
// Параметры:
//  ДатаВремя - Дата
//  Тип - Строка - "Время" или "Дата".
//
// Возвращаемое значение:
//  ПеречислениеСсылка.ДниНедели, Структура.
//
Функция ПолучитьДатуВремя(ДатаВремя, Тип) Экспорт
	
	Если Тип = "Время" Тогда
		Часов = 0;
		Минут = 0;
		Разница = ДатаВремя - НачалоДня(ДатаВремя);
		Минут = Цел(Окр((Разница / 60), 2)%60);
		Часов = Цел(Окр((Разница / 60),2)/60);
		ВремяЧ = Новый Структура;
		ВремяЧ.Вставить("Часов",Часов);
		ВремяЧ.Вставить("Минут",Минут);
		Возврат ВремяЧ;
	ИначеЕсли Тип = "День" Тогда
		ДеньЧ = ДеньНедели(ДатаВремя);
		Если ДеньЧ = 1 Тогда
			ДеньС = Перечисления.ДниНедели.Понедельник;
		ИначеЕсли ДеньЧ = 2 Тогда	
			ДеньС = Перечисления.ДниНедели.Вторник;
		ИначеЕсли ДеньЧ = 3 Тогда	
			ДеньС = Перечисления.ДниНедели.Среда;
		ИначеЕсли ДеньЧ = 4 Тогда	
			ДеньС = Перечисления.ДниНедели.Четверг;
		ИначеЕсли ДеньЧ = 5 Тогда	
			ДеньС = Перечисления.ДниНедели.Пятница;
		ИначеЕсли ДеньЧ = 6 Тогда	
			ДеньС = Перечисления.ДниНедели.Суббота;
		ИначеЕсли ДеньЧ = 7 Тогда	
			ДеньС = Перечисления.ДниНедели.Воскресенье;		
		КонецЕсли; 
	    Возврат ДеньС;
	КонецЕсли; 	

КонецФункции // ПолучитьДатуВремя()

// Позволяет подключить внешнюю  обработку.
//
// Параметры:
//  АдресХранилища - Строка.
//  БезопасныйРежим - Булево - необходимо ли подключить в безопасном режиме.
//
// Возвращаемое значение:
//  Строка - имя подключенной обработки.
//
Функция ПодключитьВнешнююОбработку(АдресХранилища, БезопасныйРежим = Неопределено) Экспорт
	
	Если БезопасныйРежим = Неопределено Тогда
		Возврат ВнешниеОбработки.Подключить(АдресХранилища,,, ОбщегоНазначения.ОписаниеЗащитыБезПредупреждений());
	Иначе
		Возврат ВнешниеОбработки.Подключить(АдресХранилища,, БезопасныйРежим, ОбщегоНазначения.ОписаниеЗащитыБезПредупреждений());
	КонецЕсли;
	
КонецФункции

///////////////////////////////////////////////////////////////
// Прочие процедуры и функции

// Преобразует таблицу значений в массив структур.
//
// Параметры:
//  Таблица - ТаблицаЗначений.
//
// Возвращаемое значение:
//  Массив - строки таблицы в виде структур.
//
Функция ПреобразоватьТаблицуЗначенийВМассивСтруктур(Таблица) Экспорт
	
	Если ТипЗнч(Таблица) = Тип("ТаблицаЗначений") Тогда
		
		Результат = Новый Массив;
		
		Для Каждого СтрокаТаблицы Из Таблица Цикл
			Структурастроки = Новый Структура;
			Для Каждого Колонка Из Таблица.Колонки Цикл
				СтруктураСтроки.Вставить(Колонка.Имя, СтрокаТаблицы[Колонка.Имя]);
			КонецЦикла;
			Результат.Добавить(СтруктураСтроки);
		КонецЦикла;
		
		Возврат Результат;
	Иначе
		Возврат Таблица;
	КонецЕсли;
	
КонецФункции

// Формирует кеш адресов филиалов базы.
//
// Возвращаемое значение:
//  Массив.
//
Функция ПолучитьАдресаФилиалов() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ЮридическийАдрес",Справочники.ВидыКонтактнойИнформации.АдресЮридический);
	Запрос.УстановитьПараметр("ФактическийАдрес",Справочники.ВидыКонтактнойИнформации.АдресФактический);
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	КонтактнаяИнформация.Объект КАК Объект,
	|	КонтактнаяИнформация.Поле2,
	|	КонтактнаяИнформация.Поле4,
	|	КонтактнаяИнформация.Вид КАК Вид,
	|	ВЫБОР
	|		КОГДА КонтактнаяИнформация.Вид = &ФактическийАдрес
	|			ТОГДА 1
	|		КОГДА КонтактнаяИнформация.Вид = &ЮридическийАдрес
	|			ТОГДА 2
	|		ИНАЧЕ 3
	|	КОНЕЦ КАК Приоритет,
	|	КонтактнаяИнформация.ЗначенияПолей
	|ИЗ
	|	РегистрСведений.КонтактнаяИнформация КАК КонтактнаяИнформация
	|ГДЕ
	|	КонтактнаяИнформация.Объект ССЫЛКА Справочник.Филиалы
	|	И КонтактнаяИнформация.Тип = ЗНАЧЕНИЕ(перечисление.типыконтактнойинформации.адрес)
	|
	|УПОРЯДОЧИТЬ ПО
	|	Объект,
	|	Приоритет";
	Контакты = Запрос.Выполнить().Выгрузить();
	Граница=Контакты.Количество();
	// Если в ТЗАдресов записей больше чем 1, то проверяем и удаляем адреса, имеющие меньший приоритет.
	Если Граница>1 Тогда
		инд=0;
		Пока инд<=(Граница-2) Цикл
			Если Контакты[инд+1].Объект=Контакты[инд].Объект И Контакты[инд+1].Приоритет>=Контакты[инд].Приоритет Тогда
				Контакты.Удалить(инд+1);
				Граница=Граница-1;
			Иначе
				инд=инд+1;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	рез=ОбщегоНазначенияКлиентСервер.ТаблицуЗначенийВМассивСтруктур(Контакты);
	Возврат рез; 
	
КонецФункции

// Процедура НастройкиВХранилище.
//
// Параметры:
//  КлючОбъекта - Строка
//  КлючНастроек - Строка
//  Настройки - Произвольный.
//
Процедура НастройкиВХранилище(КлючОбъекта, КлючНастроек, Настройки) Экспорт
	ХранилищеОбщихНастроек.Сохранить(КлючОбъекта, КлючНастроек, Настройки);
КонецПроцедуры

// Функция НастройкиИзХранилища.
//
// Параметры:
//  КлючОбъекта - Строка
//  КлючНастроек - Строка
//
// Возвращаемое значение:
//  Произвольный.
//
Функция НастройкиИзХранилища(КлючОбъекта, КлючНастроек) Экспорт
	Возврат ХранилищеОбщихНастроек.Загрузить(КлючОбъекта, КлючНастроек);
КонецФункции

// Загружает переданные данные универсальным обменом в формате xml.
//
// Параметры:
//  ДвоичныеДанныеВыгрузки - ДвоичныеДанные.
//  ДанныеСжаты - Булево - архив ли передан.
//  ИнтерактивныйРежим - Булево - флаг ЭтоИнтерактивныйРежим в обработке обмена.
//  КлючМакета - Строка - ключ макета.
//
Процедура ВыполнитьЗагрузкуУниверсальнымОбменомXML(ДвоичныеДанныеВыгрузки, ДанныеСжаты = Ложь, ИнтерактивныйРежим = Ложь, КлючМакета = "") Экспорт
	
	РазрешениеФайла = ?(ДанныеСжаты,"zip","xml");
	
	ПутьКФайлуВыгрузки = ПолучитьИмяВременногоФайла(РазрешениеФайла);
	УниверсальныйОбмен = Обработки.УниверсальныйОбменДаннымиXML.Создать();
	УниверсальныйОбмен.ИмяФайлаОбмена = ПутьКФайлуВыгрузки;
	УниверсальныйОбмен.РежимОтладкиАлгоритмов = Истина;
	УниверсальныйОбмен.РежимОбмена = "Загрузка";
	УниверсальныйОбмен.ПарольДляРаспаковкиФайлаОбмена = КлючМакета;
	УниверсальныйОбмен.ЭтоИнтерактивныйРежим = ИнтерактивныйРежим;
	
	ДвоичныеДанныеВыгрузки.Записать(ПутьКФайлуВыгрузки);
	
	УниверсальныйОбмен.ВыполнитьЗагрузку();
	
КонецПроцедуры

// Выгружает данные универсальным обменом в формате xml.
//
// Параметры:
//  ПравилаОбмена			 - Строка	 - путь к файлу правил.
//  ПутьКФайлу				 - Строка	 - путь к файлу выгрузки.
//  ВернутьДвоичныеДанные	 - Булево	 - нужно ли вернуть данные выгрузки.
//  ПараметрыОбмена			 - Строка	 - По умолчанию Неопределено
// 
// Возвращаемое значение:
//  ДвоичныеДанныеВыгрузки.
//
Функция ВыполнитьВыгрузкуУниверсальнымОбменомXML(ПравилаОбмена, ПутьКФайлу = Неопределено, ВернутьДвоичныеДанные = Ложь, ПараметрыОбмена = Неопределено) Экспорт
	
	РазрешениеФайла = "xml";
	
	ПутьКПравиламОбмена = ПолучитьИмяВременногоФайла(РазрешениеФайла);
	ТипПравил = ТипЗнч(ПравилаОбмена);
	ФайлПравил = Неопределено;
	УдалятьПравилаОбменаПослеВыгрузки = Истина;
	Если ТипПравил = Тип("ДвоичныеДанные") Или ТипПравил = Тип("ТекстовыйДокумент") Тогда
		ПравилаОбмена.Записать(ПутьКПравиламОбмена);
	Иначе
		Попытка // Если передали путь к правилам обмена.
			ФайлПравил = Новый Файл(ПравилаОбмена);
			УдалятьПравилаОбменаПослеВыгрузки = Ложь;
		Исключение КонецПопытки;
		Если ФайлПравил = Неопределено Или Не ФайлПравил.Существует() Тогда // Передали строку
			ЗаписьТекста = Новый ЗаписьТекста(ПутьКПравиламОбмена);
			ЗаписьТекста.Записать(ПравилаОбмена);
			ЗаписьТекста.Закрыть();	
		КонецЕсли;
	КонецЕсли;
	
	Если ФайлПравил = Неопределено Тогда 
		ФайлПравил = Новый Файл(ПутьКПравиламОбмена);
		Если Не ФайлПравил.Существует() Тогда 
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	ПутьКФайлуВыгрузки = ?(ПутьКФайлу = Неопределено, ПолучитьИмяВременногоФайла(РазрешениеФайла), ПутьКФайлу);
	
	УниверсальныйОбмен = Обработки.УниверсальныйОбменДаннымиXML.Создать();
	УниверсальныйОбмен.ИмяФайлаПравилОбмена = ПутьКПравиламОбмена;
	УниверсальныйОбмен.ИмяФайлаОбмена = ПутьКФайлуВыгрузки;
	УниверсальныйОбмен.РежимОтладкиАлгоритмов = Истина;
	УниверсальныйОбмен.РежимОбмена = "Выгрузка";
	УниверсальныйОбмен.ЗагрузитьПравилаОбмена();
	
	Если ПараметрыОбмена <> Неопределено Тогда
		Для Каждого СтрокаПараметра Из УниверсальныйОбмен.ТаблицаНастройкиПараметров Цикл
			Если ПараметрыОбмена.Свойство(СтрокаПараметра.Имя) Тогда
				СтрокаПараметра.Значение = ПараметрыОбмена[СтрокаПараметра.Имя];
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	УниверсальныйОбмен.ВыполнитьВыгрузку();
	
	Если УдалятьПравилаОбменаПослеВыгрузки Тогда 
		УдалитьФайлы(ФайлПравил.ПолноеИмя);
	КонецЕсли;
		
	Если ВернутьДвоичныеДанные Или ПутьКФайлу = Неопределено Тогда 
		Возврат Новый ДвоичныеДанные(ПутьКФайлуВыгрузки);
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Функция СоздатьХешированиеДанных.
//
// Параметры:
//  ФункцияХеш - ХешФункция - функция.
//
// Возвращаемое значение:
//  ХешированиеДанных.
//
Функция СоздатьХешированиеДанных(ФункцияХеш = Неопределено) Экспорт
	
	Если ФункцияХеш = Неопределено Тогда 
		ФункцияХеш = ХешФункция.SHA256;
	КонецЕсли;
	
	Возврат Новый ХешированиеДанных(ФункцияХеш);
	
КонецФункции

// Нужно ли открыть помощник первоначального заполенния при начале работы.
//
// Параметры:
//  ПервыйЗапуск - Булево - первый ли это запуск базы.
//
// Возвращаемое значение:
//  Булево.
//
Функция НужноОткрытьПомощникПервоначальногоЗаполнения(ПервыйЗапуск = Ложь) Экспорт
	
	МетаданныеОбработки = Метаданные.Обработки.Найти("ПомощникПервоначальногоЗаполнения");
	
	Возврат	МетаданныеОбработки <> Неопределено
			И ПравоДоступа("Просмотр", МетаданныеОбработки)
			И ПравоДоступа("СохранениеДанныхПользователя", Метаданные)
			И (ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить("ПомощникПервоначальногоЗаполнения", "Показывать", Ложь) Или ПервыйЗапуск);

КонецФункции

// Устанавливает Компактный режим Такси.
//
// Возвращаемое значение:
//  Булево - Требуется перезапуск.
//
Функция УстановитьКомпактныйРежимТакси() Экспорт
                
	ТребуетсяПерезапуск = Ложь;
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	Если Лев(СистемнаяИнформация.ВерсияПриложения,3) >= "8.3" Тогда
		
		Пользователь = ПользователиИнформационнойБазы.ТекущийПользователь();
		
		Если Пользователь <> Неопределено Тогда
			
			Настройка = ХранилищеСистемныхНастроек.Загрузить("Общее/НастройкиКлиентскогоПриложения", "",, Пользователь.Имя);
			
			Если Не ТипЗнч(Настройка) = Тип("НастройкиКлиентскогоПриложения") Тогда
				
				Настройка = Новый НастройкиКлиентскогоПриложения;
				Настройка.ВариантМасштабаФормКлиентскогоПриложения = ВариантМасштабаФормКлиентскогоПриложения.Компактный;
				Настройка.ВариантИнтерфейсаКлиентскогоПриложения  = ВариантИнтерфейсаКлиентскогоПриложения.Такси;
				ХранилищеСистемныхНастроек.Сохранить("Общее/НастройкиКлиентскогоПриложения", "", Настройка,, Пользователь.Имя);
				ТребуетсяПерезапуск = Истина;
				
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	Возврат ТребуетсяПерезапуск;
                
КонецФункции

// Получает текущий вариант интерфейса приложения с учётом текущего релиза платформы (8.3.10 или более старый).
// Возвращаемое значение:
//  ВариантИнтерфейсаКлиентскогоПриложения.
//
Функция ТекущийВариантИнтерфейса() Экспорт
	
	Перем ВариантИнтерфейса;
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	Если ОбщегоНазначенияКлиентСервер.СравнитьВерсии(СистемнаяИнформация.ВерсияПриложения, "8.3.10.0") < 0 Тогда
		
		Пользователь = ПользователиИнформационнойБазы.ТекущийПользователь();
		Если Пользователь <> Неопределено Тогда
			
			Настройка = ХранилищеСистемныхНастроек.Загрузить("Общее/НастройкиКлиентскогоПриложения", "",, Пользователь.Имя);
			Если ТипЗнч(Настройка) = Тип("НастройкиКлиентскогоПриложения") Тогда
				ВариантИнтерфейса = Настройка.ВариантИнтерфейсаКлиентскогоПриложения;
			Иначе
				// У пользователя еще нет сохраненной настройки.
				ВариантИнтерфейса = ВариантИнтерфейсаКлиентскогоПриложения.Такси;
			КонецЕсли;
		КонецЕсли;
	Иначе
		Выполнить("ВариантИнтерфейса = КлиентскоеПриложение.ТекущийВариантИнтерфейса()");
	КонецЕсли;
	
	Возврат ВариантИнтерфейса;
	
КонецФункции

// Группирует таблицу значений в дерево значений.
//
// Параметры:
//  Таблица				 - ТаблицаЗначений	 - исходная таблица
//  КолонкиГруппировки	 - Массив - массив строка и именами колононк таблицы значений.
// 
// Возвращаемое значение:
//  ДеревоЗначений.
//
Функция ТаблицуЗначенийВДеревоЗначений(Таблица, КолонкиГруппировки, ПодниматьУровеньПустыхГрупп = Ложь) Экспорт
	
	Перем мКолонкиГруппировки;
	
	Если ТипЗнч(КолонкиГруппировки) = Тип("Строка") Тогда
		мКолонкиГруппировки = ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(КолонкиГруппировки, ",");
	Иначе
		мКолонкиГруппировки = КолонкиГруппировки;	
	КонецЕсли;
	
	// Создание дерева
	Дерево = Новый ДеревоЗначений;
	Для Каждого Колонка Из Таблица.Колонки Цикл
		Дерево.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения, Колонка.Заголовок);
	КонецЦикла;
	
	ВерхниеЗначения = Новый Структура;
	Уровень = 0;
	СоздатьУровеньДереваПоТаблице(Таблица, мКолонкиГруппировки, Дерево.Строки, ВерхниеЗначения, Уровень, ПодниматьУровеньПустыхГрупп);
	
	Возврат Дерево;
	
КонецФункции

Процедура СоздатьУровеньДереваПоТаблице(Таблица, КолонкиГруппировки, УровеньДерева, ВерхниеЗначения, Уровень, ПодниматьУровеньПустыхГрупп)
	
	Если ВерхниеЗначения.Количество() = 0 Тогда
		СтрокиТаблицы = Таблица;
	Иначе
		СтрокиТаблицы = Таблица.НайтиСтроки(ВерхниеЗначения);
	КонецЕсли;
	
	Если Уровень <= КолонкиГруппировки.Количество() - 1 Тогда
		
		ГруппирующаяКолонка = СокрЛП(КолонкиГруппировки[Уровень]);
		ЗначенияКолонкиУровня = Новый Соответствие;
		Для Каждого СтрокаТаблицы Из СтрокиТаблицы Цикл
			ЗначенияКолонкиУровня.Вставить(СтрокаТаблицы[ГруппирующаяКолонка]);
		КонецЦикла;
		
		Для Каждого кзЗначениеГруппировки Из ЗначенияКолонкиУровня Цикл
			
			ЗначениеГруппировки = кзЗначениеГруппировки.Ключ;
			
			ВерхниеЗначенияКопия = ОбщегоНазначенияКлиентСервер.СкопироватьСтруктуру(ВерхниеЗначения);
			ВерхниеЗначенияКопия.Вставить(ГруппирующаяКолонка, ЗначениеГруппировки);
			
			Если ЗначениеЗаполнено(ЗначениеГруппировки) Или Не ПодниматьУровеньПустыхГрупп Тогда
				СтрокаДерева = УровеньДерева.Добавить();
				ЗаполнитьЗначенияСвойств(СтрокаДерева, ВерхниеЗначения);
				СтрокаДерева[ГруппирующаяКолонка] = ЗначениеГруппировки;
				
				УровеньДляПодчиненных = СтрокаДерева.Строки;
			Иначе
				// Если текущая группировка пустая и Не ПодниматьУровеньПустыхГрупп, то добавляем строки подчиненных
				//	не в пустую подгруппу, а прямо в родительский уровень дерева.
				УровеньДляПодчиненных = УровеньДерева;
			КонецЕсли;
			
			СоздатьУровеньДереваПоТаблице(Таблица, КолонкиГруппировки, УровеньДляПодчиненных, ВерхниеЗначенияКопия, Уровень + 1, ПодниматьУровеньПустыхГрупп);
			
		КонецЦикла;
	Иначе
		Для Каждого СтрокаТаблицы Из СтрокиТаблицы Цикл
			ЗаполнитьЗначенияСвойств(УровеньДерева.Добавить(), СтрокаТаблицы);
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// Возвращает значение параметра сеанса.
//
// Параметры:
//  ИмяПараметра - Строка - имя параметра.
// 
// Возвращаемое значение:
//  Произвольный.
//
Функция ПараметрСеанса(ИмяПараметра) Экспорт
	
	Возврат ПараметрыСеанса[ИмяПараметра];
	
КонецФункции

// Возвращает Истина, если в конфигурации есть объект метаданных с указанным полным именем.
//
// Параметры:
//  ПолноеИмяМетаданных	 - Строка - полное имя объекта метаданных.
// 
// Возвращаемое значение:
//  Булево
//
Функция ЕстьОбъектМетаданных(ПолноеИмяМетаданных) Экспорт
	
	Возврат Метаданные.НайтиПоПолномуИмени(ПолноеИмяМетаданных) <> Неопределено;
	
КонецФункции

// Выполнить процедуру менеджера объекта. Параметры передаются по значению! Результат выполнения в параметры не идет!
//
// Параметры:
//  ИмяОбъекта	 - Строка - полное имя объекта, например: Перечисления.КлассификацииДиагнозов.
//  ИмяМетода	 - Строка - имя экспортной процедуры модуля менеджера объекта.
//  Параметр1	 - Произвольный  - параметр, передаваемый в процедуру <ИмяМетода>. Не разрешено значение Null
//  Параметр2	 - Произвольный  - параметр, передаваемый в процедуру <ИмяМетода>. Не разрешено значение Null
//  Параметр3	 - Произвольный  - параметр, передаваемый в процедуру <ИмяМетода>. Не разрешено значение Null
//  Параметр4	 - Произвольный  - параметр, передаваемый в процедуру <ИмяМетода>. Не разрешено значение Null
//  Параметр5	 - Произвольный  - параметр, передаваемый в процедуру <ИмяМетода>. Не разрешено значение Null
//  Параметр6	 - Произвольный  - параметр, передаваемый в процедуру <ИмяМетода>. Не разрешено значение Null
//  Параметр7	 - Произвольный  - параметр, передаваемый в процедуру <ИмяМетода>. Не разрешено значение Null
//  Параметр8	 - Произвольный  - параметр, передаваемый в процедуру <ИмяМетода>. Не разрешено значение Null
Процедура ПроцедураМенеджера(Знач ИмяОбъекта, Знач ИмяМетода,
	Знач Параметр1 = Null, Знач Параметр2 = Null, Знач Параметр3 = Null, Знач Параметр4 = Null,
	Знач Параметр5 = Null, Знач Параметр6 = Null, Знач Параметр7 = Null, Знач Параметр8 = Null) Экспорт
	
	// Проверка имени метода на корректность.
	Попытка
		Тест = Новый Структура(ИмяМетода, ИмяМетода);
	Исключение
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Некорректное значение параметра ИмяМетода (%1) в ОбщегоНазначенияСервер.ВыполнитьМетодОбъекта'"), ИмяМетода);
	КонецПопытки;
		
	Параметры = Новый Массив;
	Параметры.Добавить(Параметр1);
	Параметры.Добавить(Параметр2);
	Параметры.Добавить(Параметр3);
	Параметры.Добавить(Параметр4);
	Параметры.Добавить(Параметр5);
	Параметры.Добавить(Параметр6);
	Параметры.Добавить(Параметр7);
	Параметры.Добавить(Параметр8);
	
	ПараметрыСтрока = ""; 
	Индекс = 7;
	Вставлять = Ложь;
	Пока Индекс >= 0 Цикл		
		Если Вставлять Или Параметры[Индекс] <> Null Тогда
			ПараметрыСтрока = ",Параметры[" + Индекс + "]" + ПараметрыСтрока;	
			Вставлять = Истина;
		КонецЕсли;
		Индекс = Индекс - 1;
	КонецЦикла;
	Если Вставлять Тогда
		ПараметрыСтрока = Сред(ПараметрыСтрока, 2, СтрДлина(ПараметрыСтрока));	
	КонецЕсли;
	
	Если Лев(ИмяОбъекта, СтрДлина("Перечисления")) <> "Перечисления" Тогда  // Обход недочёта БСП в Функция СерверныйМодульМенеджера для менеджера перечисления.
		МодульМенеджера = ОбщегоНазначения.ОбщийМодуль(ИмяОбъекта); // Проверяем существование такого модуля менеджера.
	КонецЕсли;
	     
	Выполнить(ИмяОбъекта+ "." + ИмяМетода + "(" + ПараметрыСтрока + ")");
	
КонецПроцедуры 

// Выполнить функцию менеджера объекта. Параметры передаются по значению! Результат выполнения в параметры не попадет!
//
// Параметры:
//  ИмяОбъекта	 - Строка	 - полное имя объекта, Например: Перечисления.КлассификацииДиагнозов.
//  ИмяМетода	 - Строка	 - имя экспортной функции модуля менеджера объекта.
//  Параметр1	 - Произвольный  - параметр, передаваемый в процедуру <ИмяМетода>. Не разрешено значение Null
//  Параметр2	 - Произвольный  - параметр, передаваемый в процедуру <ИмяМетода>. Не разрешено значение Null
//  Параметр3	 - Произвольный  - параметр, передаваемый в процедуру <ИмяМетода>. Не разрешено значение Null
//  Параметр4	 - Произвольный  - параметр, передаваемый в процедуру <ИмяМетода>. Не разрешено значение Null
//  Параметр5	 - Произвольный  - параметр, передаваемый в процедуру <ИмяМетода>. Не разрешено значение Null
//  Параметр6	 - Произвольный  - параметр, передаваемый в процедуру <ИмяМетода>. Не разрешено значение Null
//  Параметр7	 - Произвольный  - параметр, передаваемый в процедуру <ИмяМетода>. Не разрешено значение Null
//  Параметр8	 - Произвольный  - параметр, передаваемый в процедуру <ИмяМетода>. Не разрешено значение Null
// 
// Возвращаемое значение:
//	Произвольный - Результат выполнения функции.
//
Функция ФункцияМенеджера(Знач ИмяОбъекта, Знач ИмяМетода,
	Знач Параметр1 = Null, Знач Параметр2 = Null, Знач Параметр3 = Null, Знач Параметр4 = Null,
	Знач Параметр5 = Null, Знач Параметр6 = Null, Знач Параметр7 = Null, Знач Параметр8 = Null) Экспорт
	
	// Проверка имени метода на корректность.
	Попытка
		Тест = Новый Структура(ИмяМетода, ИмяМетода);
	Исключение
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Некорректное значение параметра ИмяМетода (%1) в ОбщегоНазначенияСервер.ВыполнитьМетодОбъекта'"), ИмяМетода);
	КонецПопытки;
		
	Параметры = Новый Массив;
	Параметры.Добавить(Параметр1);
	Параметры.Добавить(Параметр2);
	Параметры.Добавить(Параметр3);
	Параметры.Добавить(Параметр4);
	Параметры.Добавить(Параметр5);
	Параметры.Добавить(Параметр6);
	Параметры.Добавить(Параметр7);
	Параметры.Добавить(Параметр8);
	
	ПараметрыСтрока = ""; 
	Индекс = 7;
	Вставлять = Ложь;
	Пока Индекс >= 0 Цикл		
		Если Вставлять Или Параметры[Индекс] <> Null Тогда
			ПараметрыСтрока = ",Параметры[" + Индекс + "]" + ПараметрыСтрока;	
			Вставлять = Истина;
		КонецЕсли;
		Индекс = Индекс - 1;
	КонецЦикла; 
	Если Вставлять Тогда
		ПараметрыСтрока = Сред(ПараметрыСтрока, 2, СтрДлина(ПараметрыСтрока));	
	КонецЕсли; 
	
	Если Лев(ИмяОбъекта, СтрДлина("Перечисления")) <> "Перечисления" Тогда  // Обход недочёта БСП в Функция СерверныйМодульМенеджера для менеджера перечисления.
		МодульМенеджера = ОбщегоНазначения.ОбщийМодуль(ИмяОбъекта); // Проверяем существование такого модуля менеджера.
	КонецЕсли;
	
	Возврат Вычислить(ИмяОбъекта + "." + ИмяМетода + "(" + ПараметрыСтрока + ")");
	
КонецФункции 

Процедура ХранилищеОбщихНастроекСохранитьМассивДляСканирования(НесколькоНастроек,
			ОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
			
	УстановитьПривилегированныйРежим(Истина);
	
	Если Не ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Элемент Из НесколькоНастроек Цикл
		ЭлементНастройка = ОбщегоНазначения.СократитьСтрокуКонтрольнойСуммой(Элемент.Настройка,128);
		ХранилищеОбщихНастроек.Сохранить(Элемент.Объект, ЭлементНастройка, Элемент.Значение,,"НастройкиСканера");
	КонецЦикла;
	
	Если ОбновитьПовторноИспользуемыеЗначения Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;
	УстановитьПривилегированныйРежим(Ложь);

	
КонецПроцедуры

// Загружает настройку из хранилища общих настроек, как метод платформы Загрузить,
// объектов СтандартноеХранилищеНастроекМенеджер или ХранилищеНастроекМенеджер.<Имя хранилища>,
// но с поддержкой длины ключа настроек более 128 символов путем хеширования части,
// которая превышает 96 символов.
// Кроме того, возвращает указанное значение по умолчанию, если настройки не найдены.
// Если нет права СохранениеДанныхПользователя, возвращается значение по умолчанию без ошибки.
//
// В возвращаемом значении очищаются ссылки на несуществующий объект в базе данных, а именно
// - возвращаемая ссылка заменяется на указанное значение по умолчанию;
// - из данных типа Массив ссылки удаляются;
// - у данных типа Структура и Соответствие ключ не меняется, а значение устанавливается Неопределено;
// - анализ значений в данных типа Массив, Структура, Соответствие выполняется рекурсивно.
//
// Параметры:
//   КлючОбъекта          - Строка           - см. синтакс-помощник платформы.
//   КлючНастроек         - Строка           - см. синтакс-помощник платформы.
//   ЗначениеПоУмолчанию  - Произвольный     - значение, которое возвращается, если настройки не найдены.
//                                             Если не указано, возвращается значение Неопределено.
//   ОписаниеНастроек     - ОписаниеНастроек - см. синтакс-помощник платформы.
//   ИмяПользователя      - Строка           - см. синтакс-помощник платформы.
//
// Возвращаемое значение: 
//   Произвольный - см. синтакс-помощник платформы.
//
Функция ХранилищеОбщихНастроекЗагрузитьДляСканирования(КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию = Неопределено) Экспорт
	УстановитьПривилегированныйРежим(Истина);
	Возврат ОбщегоНазначения.ХранилищеЗагрузить(ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		ЗначениеПоУмолчанию,
		,
		"НастройкиСканера");
	УстановитьПривилегированныйРежим(Ложь);
	
КонецФункции

Функция СистемнаяИнформацияСервера() Экспорт 
	
	СистемнаяИнформация = Новый Структура("ВерсияОС, ВерсияПриложения, ИдентификаторКлиента, ИнформацияПрограммыПросмотра, ОперативнаяПамять, Процессор, ТипПлатформы");
	ЗаполнитьЗначенияСвойств(СистемнаяИнформация, Новый СистемнаяИнформация);
	
	Возврат СистемнаяИнформация;
	
КонецФункции

Функция РежимРасширенныхВозможностейРедактированияДанных() Экспорт
	
	Возврат СтрНайти(Строка(ПараметрыСеанса.ПараметрыКлиентаНаСервере.Получить("ПараметрЗапуска")), "ConfDebug") > 0;
	
КонецФункции

Процедура ВосстановитьПорядокНайденныхСтрок(НайденныеСтроки, Таблица) Экспорт
	
	Если НайденныеСтроки.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ИндексыСтрок = Новый ТаблицаЗначений();
	ИндексыСтрок.Колонки.Добавить("Индекс");
	ИндексыСтрок.Колонки.Добавить("Строка");
	
	Для Каждого Строка ИЗ НайденныеСтроки Цикл
		НСтр = ИндексыСтрок.Добавить();
		НСтр.Индекс = Таблица.Индекс(Строка);
		НСтр.Строка = Строка;
	КонецЦикла;
	
	ИндексыСтрок.Сортировать("Индекс");
	НайденныеСтроки.Очистить();
	Для Каждого УпорядоченнаяСтрока ИЗ ИндексыСтрок Цикл
		НайденныеСтроки.Добавить(УпорядоченнаяСтрока.Строка);
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти