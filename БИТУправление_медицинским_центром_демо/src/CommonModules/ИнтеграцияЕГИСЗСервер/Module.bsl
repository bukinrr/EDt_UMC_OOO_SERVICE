#Область ПрограммныйИнтерфейс

Функция ДанныеОрганизацииПоOid(OidОрганизации) Экспорт
	
	СтруктураОрганизации = Новый Структура();
	СтруктураОрганизации.Вставить("OIDОрганизации");
	СтруктураОрганизации.Вставить("Наименование");
	СтруктураОрганизации.Вставить("ПолноеНаименование");
	СтруктураОрганизации.Вставить("ИНН");
	СтруктураОрганизации.Вставить("КПП");
	СтруктураОрганизации.Вставить("ОГРН");
	
	Организация = Справочники.РеестрМедицинскихОрганизаций.НайтиПоРеквизиту("OIDОрганизации",OidОрганизации);
	Если ЗначениеЗаполнено(Организация) Тогда
		ЗаполнитьЗначенияСвойств(СтруктураОрганизации,Организация);
		Для Каждого СтрокаАтрибута Из Организация.Атрибуты Цикл
			СтруктураОрганизации.Вставить(СтрокаАтрибута.Ключ, СтрокаАтрибута.Значение);	
		КонецЦикла;
	Иначе
		ПараметрыОтбора = Новый Структура();
		МассивФильтров = Новый Массив();
		МассивФильтров.Добавить(СтрШаблон("%1|%2|%3", "oid", OidОрганизации, "EXACT"));
		ПараметрыОтбора.Вставить("filters", МассивФильтров);
		
		ТаблицаЗначений = ЗагрузкаКлассификаторовНСИЕГИСЗ.ПолучитьКлассификаторПоОтбору("1.2.643.5.1.13.13.11.1461",Справочники.РеестрМедицинскихОрганизаций,ПараметрыОтбора);
		Если ТаблицаЗначений <> Неопределено И ТаблицаЗначений.Количество() > 0 Тогда
			
			СтрокаОрганизации = ТаблицаЗначений[0];
			ЗаполнитьЗначенияСвойств(СтруктураОрганизации, СтрокаОрганизации);
			Для Каждого СтрокаАтрибута Из СтрокаОрганизации.Атрибуты Цикл
				СтруктураОрганизации.Вставить(СтрокаАтрибута.Ключ, СтрокаАтрибута.Значение);	
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Возврат СтруктураОрганизации;
	
КонецФункции

Функция ПолучитьЗначениеНастройки(ИмяПараметра, Филиал = Неопределено, МедицинскаяОрганизация = Неопределено) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если МедицинскаяОрганизация = Неопределено Тогда
		Если Филиал = Неопределено Тогда
			Филиал = УправлениеНастройками.ПолучитьФилиалПоУмолчаниюПользователя();
		КонецЕсли;
		
		Если ЗначениеЗаполнено(Филиал) Тогда
			МедицинскаяОрганизация = Филиал.Организация.МедицинскаяОрганизация;
		Иначе
			МедицинскаяОрганизация = Справочники.РеестрМедицинскихОрганизаций.ПустаяСсылка();
		КонецЕсли;
	КонецЕсли;
	
	нзНастройки = РегистрыСведений.ЕГИСЗНастройкиИнтеграции.СоздатьНаборЗаписей();
	нзНастройки.Отбор.МедицинскаяОрганизация.Установить(МедицинскаяОрганизация);
	нзНастройки.Прочитать();
	Если нзНастройки.Количество() > 0 Тогда
		Возврат	ОбщегоНазначенияКлиентСервер.СвойствоОбъекта(нзНастройки[0], ИмяПараметра);
	Иначе
		МетаданныеРесурса = нзНастройки.Метаданные().Ресурсы.Найти(ИмяПараметра);
		Если МетаданныеРесурса = Неопределено Тогда
			Возврат Неопределено;
		Иначе
			Возврат МетаданныеРесурса.Тип.ПривестиЗначение(Неопределено);
		КонецЕсли;
	КонецЕсли;
	
КонецФункции

Функция ПолучитьКонтактныеДанные(Объект) Экспорт
	Запрос = Новый Запрос();
	Запрос.Текст = "ВЫБРАТЬ
	               |	КонтактнаяИнформация.Вид КАК Вид,
	               |	КонтактнаяИнформация.Представление КАК Представление,
	               |	КонтактнаяИнформация.Тип КАК Тип,
	               |	КонтактнаяИнформация.Поле1 КАК Поле1,
	               |	КонтактнаяИнформация.Поле2 КАК Поле2,
	               |	КонтактнаяИнформация.Поле3 КАК Поле3,
	               |	КонтактнаяИнформация.Поле4 КАК Поле4,
	               |	КонтактнаяИнформация.Поле5 КАК Поле5,
	               |	КонтактнаяИнформация.Поле6 КАК Поле6,
	               |	КонтактнаяИнформация.Поле7 КАК Поле7,
	               |	КонтактнаяИнформация.Поле8 КАК Поле8,
	               |	КонтактнаяИнформация.Поле9 КАК Поле9,
	               |	КонтактнаяИнформация.Поле10 КАК Поле10,
	               |	КонтактнаяИнформация.Поле11 КАК Поле11,
	               |	КонтактнаяИнформация.Поле12 КАК Поле12,
	               |	КонтактнаяИнформация.ГородскойРайон КАК ГородскойРайон,
	               |	КонтактнаяИнформация.ТипДома КАК ТипДома,
	               |	КонтактнаяИнформация.ТипКорпуса КАК ТипКорпуса,
	               |	КонтактнаяИнформация.ТипКвартиры КАК ТипКвартиры,
	               |	КонтактнаяИнформация.ЗначенияПолей КАК ЗначенияПолей
	               |ИЗ
	               |	РегистрСведений.КонтактнаяИнформация КАК КонтактнаяИнформация
	               |ГДЕ
	               |	КонтактнаяИнформация.Объект = &Объект";
	Запрос.УстановитьПараметр("Объект",Объект);
	ТаблицаКонтактов = Запрос.Выполнить().Выгрузить();
	
	Возврат ТаблицаКонтактов;
КонецФункции

Функция ПолучитьСтраховыеПолисы(Клиент) Экспорт
	
	Запрос = Новый Запрос();
	Запрос.Текст = "ВЫБРАТЬ
	               |	СтраховыеПолисы.Ссылка КАК Ссылка,
	               |	СтраховыеПолисы.Номер КАК Номер,
	               |	СтраховыеПолисы.Серия КАК Серия,
	               |	СтраховыеПолисы.СрокДействияНачало КАК СрокДействияНачало,
	               |	СтраховыеПолисы.СрокДействия КАК СрокДействия,
	               |	СтраховыеПолисы.ВидПолиса КАК ВидПолиса,
	               |	СтраховыеПолисы.СтраховаяКомпания КАК СтраховаяКомпания,
	               |	СтраховыеПолисы.Контрагент КАК Контрагент
	               |ИЗ
	               |	Справочник.СтраховыеПолисы КАК СтраховыеПолисы
	               |ГДЕ
	               |	СтраховыеПолисы.Владелец = &Клиент
	               |	И НЕ СтраховыеПолисы.НеДействителен
	               |	И СтраховыеПолисы.ВидПолиса.Тип = &ТипОМС
	               |	И НЕ СтраховыеПолисы.ПометкаУдаления";
	
	Запрос.УстановитьПараметр("Клиент", Клиент);
	Запрос.УстановитьПараметр("ТипОМС", Перечисления.ТипыСтраховыхПрограмм.ОМС);
	
	ТаблицаПолисов = Запрос.Выполнить().Выгрузить();
	
	Возврат ТаблицаПолисов;
		
КонецФункции

Функция ОбработатьЗапросHTTPСервиса(Запрос) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	// Запишем запрос в журнал регистрации.
	
	// Если используется метод POST, заполним значение переменной ТелоКакСтрока.
	Если Запрос.HTTPМетод = "POST" Тогда
		
		Если ТипЗнч(Запрос) = Тип("Структура") Тогда
			// Тип запроса Структура используется для юнит-тестов.
			ТелоКакСтрока = Запрос.ТелоКакСтрока;
		Иначе
			ТелоКакСтрока = Запрос.ПолучитьТелоКакСтроку();
		КонецЕсли;
	ИначеЕсли Запрос.HTTPМетод = "GET"
		И Запрос.ПараметрыЗапроса.Получить("DigitalSignatureTest") <> Неопределено
	Тогда
		Возврат ПроверкаИспользованияСертификатаЭЦП();
	КонецЕсли;
	
	// Проверим, что нет лишних параметров URL.
	Если Запрос.ПараметрыURL.Количество() <> 0 Тогда
		Ответ = Новый HTTPСервисОтвет(404);
		Ответ.Заголовки.Вставить("Content-Type", "text/html;charset=UTF-8");
		Ответ.УстановитьТелоИзСтроки(
			"<!DOCTYPE html>
			|<html>
			|	<body>
			|		<h2>404 - Страница не найдена.</h2>
			|	</body>
			|</html>"
		);
		Возврат Ответ;
	КонецЕсли;
	
	// Проверка на наличие лишних параметров в URI.
	ПараметрыСтрокой = "";
	ПараметрыЗапросаОК = Запрос.ПараметрыЗапроса.Количество() = 0;
	Если Запрос.ПараметрыЗапроса.Количество() = 1 Тогда
		Для Каждого КлючИЗначение Из Запрос.ПараметрыЗапроса Цикл
			Если КлючИЗначение.Ключ = "wsdl" И Не ЗначениеЗаполнено(КлючИЗначение.Значение) Тогда
				ПараметрыЗапросаОК = Истина;
				ПараметрыСтрокой = "?wsdl";
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	// При наличии лишних параметров формируется ответ об ошибке.
	Если Не ПараметрыЗапросаОК Тогда
		ПараметрыСтрокой = "";
		Для Каждого КлючИЗначение Из Запрос.ПараметрыЗапроса Цикл
			Если ЗначениеЗаполнено(ПараметрыСтрокой) Тогда
				ПараметрыСтрокой = ПараметрыСтрокой + "&";
			Иначе
				ПараметрыСтрокой = "?";
			КонецЕсли;
			Если Не ЗначениеЗаполнено(КлючИЗначение.Значение) Тогда
				ПараметрыСтрокой = ПараметрыСтрокой + КлючИЗначение.Ключ;
			Иначе
				ПараметрыСтрокой = ""
					+ ПараметрыСтрокой
					+ СтрШаблон("%1=%2", КлючИЗначение.Ключ, КлючИЗначение.Значение)
				;
			КонецЕсли;
		КонецЦикла;
		Ответ = Новый HTTPСервисОтвет(404);
		Ответ.Заголовки.Вставить("Content-Type", "text/html; charset=UTF-8");
		Ответ.УстановитьТелоИзСтроки(СтрШаблон(
			"<!DOCTYPE html>
			|<html>
			|	<body>
			|		<h2>404 - Неверные параметры запроса: ""%1"".</h2>
			|		<p>
			|		 Допустимый параметр - wsdl без значения (""?wsdl"").
			|		</p>
			|	</body>
			|</html>",
			ПараметрыСтрокой
		));
		Возврат Ответ;
	КонецЕсли;
	
	MimeType = "text/xml";
	
	// Вычисление предполагаемого запросом MIME-типа ответа.
	Для Каждого КлючИЗначение Из Запрос.Заголовки Цикл
		
		Если Не ТРег(КлючИЗначение.Ключ) = "Accept" Тогда
			Продолжить;
		КонецЕсли;
		
		// Заголовок Accept имеет следующий вид.
		// Accept: text/plain; q=0.5, text/html,
		//         text/x-dvi; q=0.8, text/x-c,
		//         text/*; q=0.3, */*; q=0.1
		ОжидаемыеТипы = СтрРазделить(КлючИЗначение.Значение, ",");
		
		Для Каждого ЗаписьОжидаемогоТипа Из ОжидаемыеТипы Цикл
			
			// Поиск в строке типа символа /
			ЧастиОжидаемогоТипа = СтрРазделить(СокрЛП(СтрРазделить(ЗаписьОжидаемогоТипа, ";")[0]), "/");
			ОжидаемыйТип = ЧастиОжидаемогоТипа[0];
			
			// Будем проверять только ожидаемый тип и на основе этого выбирать один из двух возможных.
			Если ОжидаемыйТип = "application" Тогда
				MimeType = "application/soap+xml";
			ИначеЕсли ОжидаемыйТип = "text" Или ОжидаемыйТип = "*" Тогда
				MimeType = "text/xml";
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	ЛокальныйURL = Запрос.БазовыйURL + Запрос.ОтносительныйURL;
	
	СтруктураURI = ОбщегоНазначенияКлиентСервер.СтруктураURI(Запрос.БазовыйURL + Запрос.ОтносительныйURL + ПараметрыСтрокой);
	
	// Код ответа (по умолчанию 200).
	КодОтвета = 200;
	
	СтруктураДляЛогов = Новый Структура("ТекстЗапроса, УИДСообщения", Запрос.ПолучитьТелоКакСтроку());
	
	// Если запрос POST, то обрабатывам SOAP пакет, если GET то отправляем WSDL описание.
	Если Запрос.HTTPМетод = "POST" Тогда
		
		РезультатЗапросаSOAP = ОбработатьSOAPЗапрос(ЛокальныйURL, ТелоКакСтрока, СтруктураДляЛогов);
		ТелоОтвета = РезультатЗапросаSOAP.Тело;
		
		Если ЗначениеЗаполнено(РезультатЗапросаSOAP.КэшОтвета) Тогда
			ТелоОтвета = РезультатЗапросаSOAP.КэшОтвета;
		ИначеЕсли РезультатЗапросаSOAP.КодСостояния <> 200 Тогда
			КодОтвета = РезультатЗапросаSOAP.КодСостояния;
		ИначеЕсли СтрНайти(НРег(ЛокальныйURL), "emdr") > 0 Тогда
			// Подписываем ответы для РЭМД.
			ТелоОтвета = ИнтеграцияЕГИСЗ_ЭЦП.ПодписатьSoapСообщение(ТелоОтвета);
		КонецЕсли;
	ИначеЕсли Запрос.HTTPМетод = "GET" Тогда
		ИнтеграцияЕГИСЗСлужебныйСервер.ЗаписатьОбъектВЖурналРегистрации(Запрос);
		ТелоОтвета = ПолучитьОписаниеWSDL(ЛокальныйURL);
	КонецЕсли;
	
	// Подготовка ответа
	Ответ = Новый HTTPСервисОтвет(КодОтвета);
	
	Ответ.УстановитьТелоИзСтроки(ТелоОтвета, КодировкаТекста.UTF8, ИспользованиеByteOrderMark.НеИспользовать);
	
	РазмерТелаСтрокой = Формат(Ответ.ПолучитьТелоКакДвоичныеДанные().Размер(), "ЧН=; ЧГ=");
	
	// Установим обязательные заголовки. Остальные подставить http-сервер, например Apache.
	Ответ.Заголовки.Вставить("Content-Type", СтрШаблон("%1; charset=utf-8", MimeType));
	Ответ.Заголовки.Вставить("Content-Length", РазмерТелаСтрокой);
	
	// Лог отправленных ответов
	Если ЗначениеЗаполнено(СтруктураДляЛогов.УИДСообщения) Тогда
		СтруктураДляЛогов.ТекстЗапроса = Ответ.ПолучитьТелоКакСтроку();
		ИнтеграцияЕГИСЗСлужебныйСервер.ЗаписатьВАрхивЛогов(СтруктураДляЛогов);
	Иначе
		ИнтеграцияЕГИСЗСлужебныйСервер.ЗаписатьОбъектВЖурналРегистрации(Ответ);
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Ложь);
	
	Возврат Ответ;
	
КонецФункции

Функция ОбработатьSOAPЗапрос(ЛокальныйURL, ТелоКакСтрока, СтруктураДляЛогов)
	
	ДокументDOM = ИнтеграцияЕГИСЗСервер.ПостроитьDOM(ТелоКакСтрока);
	
	// Получение версии SOAP.
	ВерсияSOAP = ИнтеграцияЕГИСЗСервер.ПолучитьСтрокуПоXPath(ДокументDOM, , "namespace-uri(/*)");
	Разыменователь = Новый РазыменовательПространствИменDOM("soap", ВерсияSOAP);
	
	// Тип результата XPath для определения заголовка SOAP.
	ТипРезультата = ТипРезультатаDOMXPath.ПервыйУпорядоченныйУзел;
	
	// Команда XPath для поиска заголовка.
	XPath = "/soap:Envelope/soap:Header";
	
	// Выполнение команды XPath.
	РезультатXPath = ДокументDOM.ВычислитьВыражениеXPath(
		XPath, ДокументDOM, Разыменователь, ТипРезультата
	);
	// Берем первый найденный узел.
	ЗаголовокSOAP = РезультатXPath.ОдиночныйУзелЗначение;
	
	// Команда XPath для поиска тела.
	XPath = "/soap:Envelope/soap:Body";
	// Выполнение команды XPath.
	РезультатXPath = ДокументDOM.ВычислитьВыражениеXPath(
		XPath, ДокументDOM, Разыменователь, ТипРезультата
	);
	// Из результата берем первый найденный узел.
	ТелоSOAP = РезультатXPath.ОдиночныйУзелЗначение;
	
	// Команда XPath, с помощью которой определим параметры запроса SOAP.
	XPath = "/soap:Envelope/soap:Body/*";
	// Выполнение команды XPath.
	РезультатXPath = ДокументDOM.ВычислитьВыражениеXPath(
		XPath, ДокументDOM, Разыменователь, ТипРезультата
	);
	// Требуется первый узел в результате XPath.
	ПараметрыSOAP = РезультатXPath.ОдиночныйУзелЗначение;
		
	// Считаем, что имя операции формируется путем отсечения подстроки Request от конца имени тега параметров SOAP.
	ИмяОперацииSOAP = СтрЗаменить(ПараметрыSOAP.ЛокальноеИмя, "Request", "");
	
	// Получим имя модуля для обработки запроса.
	ИмяМодуля = ИмяМодуляПодсистемыЕГИСЗ(ЛокальныйURL);
	
	// Сохраним в строку ПараметрыSOAP.
	ПараметрыSOAPСтрокой = РаботаСDOMКлиентСервер.СтрокаXMLИзDOM(ПараметрыSOAP);
	
	// Проверка запроса на соответствие схеме.
	ИнтеграцияЕГИСЗСервер.ПроверитьПространтваИменВXML(ПараметрыSOAPСтрокой);
	
	// ЗаголовокSOAP в форме строки.
	Если ЗаголовокSOAP <> Неопределено Тогда
		ЗаголовокSOAPСтрокой = РаботаСDOMКлиентСервер.СтрокаXMLИзDOM(ЗаголовокSOAP);
	КонецЕсли;
	
	// Обработка операции SOAP.
	УстановитьПривилегированныйРежим(Истина);
	Результат = Вычислить(СтрШаблон("%1.%2(ПараметрыSOAPСтрокой, ЗаголовокSOAPСтрокой, СтруктураДляЛогов)", ИмяМодуля, ИмяОперацииSOAP));
	УстановитьПривилегированныйРежим(Ложь);
	
	Заголовок = "";
	
	КэшОтвета = Неопределено;
	
	Если ТипЗнч(Результат) = Тип("Структура") Тогда
		
		Тело = Результат.Тело;
		Если ЗначениеЗаполнено(Результат.Заголовок) Тогда
			ШаблонЗаголовка =
				"<soap:Header>
				|	%1
				|</soap:Header>";
			Заголовок = СтрШаблон(ШаблонЗаголовка, СтрЗаменить(Результат.Заголовок, Символы.ПС, Символы.ПС + Символы.Таб));
		КонецЕсли;
	Иначе
		Тело = Результат;
	КонецЕсли;
	
	Если Результат.Свойство("КэшОтвета")
		И ЗначениеЗаполнено(Результат.КэшОтвета)
	Тогда
		КэшОтвета = Результат.КэшОтвета;
	КонецЕсли;
	
	// Возвращаем результат операции SOAP.
	ШаблонКонверта =
		"<soap:Envelope xmlns:soap=""%1"">
		|	%2
		|	<soap:Body>
		|		%3
		|	</soap:Body>
		|</soap:Envelope>";
	
	Конверт = СтрШаблон(
		ШаблонКонверта,
		ВерсияSOAP,
		СтрЗаменить(Заголовок, Символы.ПС, Символы.ПС + Символы.Таб),
		СтрЗаменить(Тело, Символы.ПС, Символы.ПС + Символы.Таб + Символы.Таб)
	);
	
	// Проверяем ответ на соответствие схеме.
	ИнтеграцияЕГИСЗСервер.ПроверитьПространтваИменВXML(Тело);
	
	Возврат Новый Структура("Тело, КодСостояния, КэшОтвета", Конверт, 200, КэшОтвета);
	
КонецФункции

Функция ИмяМодуляПодсистемыЕГИСЗ(ЛокальныйURL)
	
	ШаблонИмениМодуля = "ИнтеграцияЕГИСЗ_%1";
	
	Если СтрЗаканчиваетсяНа(ЛокальныйURL, "/EmdrCallback") Тогда
		ВнутреннееИмя = "РЭМД";
	ИначеЕсли СтрЗаканчиваетсяНа(ЛокальныйURL, "/EMDRCallback") Тогда
		ВнутреннееИмя = "РЭМД";
	ИначеЕсли СтрЗаканчиваетсяНа(ЛокальныйURL, "/EMDR") Тогда
		ВнутреннееИмя = "РЭМД";
	ИначеЕсли СтрЗаканчиваетсяНа(ЛокальныйURL, "/PIX") Тогда
		ВнутреннееИмя = "ГИП";
	КонецЕсли;
	
	ИмяМодуля = СтрШаблон(ШаблонИмениМодуля, ВнутреннееИмя);
	
	Возврат ИмяМодуля;
	
КонецФункции

Функция ПолучитьОписаниеWSDL(ЛокальныйURL)
	
	// Получим внутреннее имя веб-сервиса - это русскоязычный его идентификатор.
	Имя = ПолучитьВнутреннееИмяВебСервиса(ЛокальныйURL);
	// По внутреннему имени получим описание WSDL.
	ОписаниеWSDL = ИнтеграцияЕГИСЗСерверПовтИсп.ПолучитьМакетОписанияWSDL(Имя);
	
	Если СтрНайти(ОписаниеWSDL, "%1") <> 0 Тогда
		ОписаниеWSDL = СтрШаблон(ОписаниеWSDL, ЛокальныйURL);
	КонецЕсли;
	
	Возврат ОписаниеWSDL;
	
КонецФункции

Функция ПолучитьВнутреннееИмяВебСервиса(ЛокальныйURL)
	
	Если СтрЗаканчиваетсяНа(ЛокальныйURL, "/EmdrCallback") Тогда
		Возврат "РЭМДФедеральный";
	ИначеЕсли СтрЗаканчиваетсяНа(ЛокальныйURL, "/EMDRCallback") Тогда
		Возврат "РЭМДФедеральный";
	ИначеЕсли СтрЗаканчиваетсяНа(ЛокальныйURL, "/EMDR") Тогда
		Возврат "РЭМЛокальный";
	ИначеЕсли СтрЗаканчиваетсяНа(ЛокальныйURL, "/PIX") Тогда
		Возврат "ГИП";
	КонецЕсли;
	
КонецФункции

// Получает значения параметров элемента справочника-классификатора
//
// Параметры:
//  СправочникСсылка - СправочникСсылка - Ссылка на элемент справочника ЕГИСЗ 
// 
// Возвращаемое значение:
//  Структура:
//		* code			 - Строка - УИДЕГИСЗ элемента
//		* name			 - Строка - Наименование элемента классификатора
//		* version		 - Строка - Версия классификатора
//		* codesystem	 - Строка - OID классификатора
//		* codesystemname - Строка - Наименование классификатора
//
Функция ПолучитьЗначенияПараметровЭлементаКлассификатора(СправочникСсылка) Экспорт
	
	Если ТипЗнч(СправочникСсылка) = Тип("СправочникСсылка.КлассификаторыМинЗдрава") Тогда
		ИменаРеквизитовДляDisplayNameИCode = ИнтеграцияЕГИСЗСерверПовтИсп.ПолучитьИменаРеквизитовКлассификатораПоВидуКлассификатора(СправочникСсылка.ВидКлассификатора);
		OIDСправочника = ИнтеграцияЕГИСЗСерверПовтИсп.OIDСправочникаПоВидуКлассификатора(СправочникСсылка.ВидКлассификатора);
	Иначе
		ИменаРеквизитовДляDisplayNameИCode = ИнтеграцияЕГИСЗСерверПовтИсп.ПолучитьИменаРеквизитовКлассификатора(ПолучитьИмяТипаПоСсылке(СправочникСсылка));
		OIDСправочника = ИнтеграцияЕГИСЗСерверПовтИсп.OIDСправочникаПоТипу(ПолучитьИмяТипаПоСсылке(СправочникСсылка));
	КонецЕсли;
	
	Поля = Новый Структура("code, name, version, codesystem, codesystemname");
	
	мРеквизитыПоУмолчаниюКод = Новый Массив;
	мРеквизитыПоУмолчаниюКод.Добавить("УИДЕГИСЗ");
	СтрокаКода = ЗначениеПараметраИзСтруктуры(СправочникСсылка, ИменаРеквизитовДляDisplayNameИCode, "Code", мРеквизитыПоУмолчаниюКод);
	
	мРеквизитыПоУмолчаниюНаименование = Новый Массив;
	мРеквизитыПоУмолчаниюНаименование.Добавить("НаименованиеПолное");
	мРеквизитыПоУмолчаниюНаименование.Добавить("ПолноеНаименование");
	мРеквизитыПоУмолчаниюНаименование.Добавить("Наименование");
	СтрокаНаименования = ЗначениеПараметраИзСтруктуры(СправочникСсылка, ИменаРеквизитовДляDisplayNameИCode, "Name", мРеквизитыПоУмолчаниюНаименование);
	
	Поля.code = СтрЗаменить(СтрокаКода, Символы.НПП, "");
	Поля.name = СтрокаНаименования;
	Поля.version = СправочникСсылка.ВерсияКлассификатораМинздрава;
	Поля.codesystem = OIDСправочника;
	Поля.codesystemname = ДанныеВерсииКлассификатора(Поля.codesystem, Поля.version).Наименование;
	
	Возврат Поля;
	
КонецФункции

// Получает значения параметров справочника-классификатора
//
// Параметры:
//  OIDКлассификатора	 - Строка - OID классификатора
//  Идентификатор		 - Строка - УИДЕГИСЗ элемента
// 
// Возвращаемое значение:
//  Структура:
//		* name			 - Строка - Наименование элемента классификатора
//		* version		 - Строка - Версия классификатора
//		* codesystemname - Строка - Наименование классификатора
//
Функция ПолучитьЗначенияПараметровЭлементаКлассификатораПоИдентификатору(OIDКлассификатора, Идентификатор) Экспорт
	
	ПараметрыСправочника = ИнтеграцияЕГИСЗСерверПовтИсп.ПолучитьПараметрыСправочникаЕГИСЗ(OIDКлассификатора);
	
	Если ПараметрыСправочника.Тип = Тип("СправочникСсылка.КлассификаторыМинЗдрава") Тогда
		Если Не ПараметрыСправочника.Свойство("ВидКлассификатора") Тогда
			Возврат Неопределено;
		Иначе
			ДанныеЭлемента = ИнтеграцияЕГИСЗСерверПовтИсп.ПолучитьНаименованиеИВерсиюЭлементаКлассификатора(Идентификатор, ПараметрыСправочника.ВидКлассификатора);
		КонецЕсли;
	Иначе
		ДанныеЭлемента = ИнтеграцияЕГИСЗСерверПовтИсп.ПолучитьНаименованиеИВерсиюЭлементаКлассификатора(Идентификатор, , ПараметрыСправочника.ПолноеНаименование, ПараметрыСправочника.РеквизитПолногоНаименования);
	КонецЕсли;
	
	Если ДанныеЭлемента = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Поля = Новый Структура("name, version, codesystemname");
	Поля.name			= ДанныеЭлемента.Наименование;
	Поля.version		= ДанныеЭлемента.Версия;
	Поля.codesystemname	= ДанныеВерсииКлассификатора(OIDКлассификатора, Поля.version).Наименование;
	
	Возврат Поля;
	
КонецФункции

Функция ЗначениеПараметраИзСтруктуры(Ссылка, Структура, ИмяПараметра, мРеквизитыПоУмолчанию)
	
	// По умолчанию
	Если Не Структура.Свойство(ИмяПараметра) Тогда
		ЗначениеПараметра = Неопределено;
		Для Каждого РеквизитПоУмолчанию Из мРеквизитыПоУмолчанию Цикл
			Попытка
				ЗначениеПараметра = Ссылка[РеквизитПоУмолчанию];
			Исключение КонецПопытки;
			Если ЗначениеЗаполнено(ЗначениеПараметра) Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Возврат ЗначениеПараметра;
	КонецЕсли;
	
	// Из ТЧ Атрибуты
	Если Структура.Свойство(СтрШаблон("ЭтоКлючАтрибута_%1", ИмяПараметра)) И Структура[СтрШаблон("ЭтоКлючАтрибута_%1", ИмяПараметра)] Тогда
		Возврат ПолучитьЗначениеАтрибутаЭлементаКлассификатора(Ссылка, Структура[ИмяПараметра]);
	КонецЕсли;
	
	// Из реквизита
	Возврат ОбщегоНазначения.ПолучитьЗначениеРеквизита(Ссылка, Структура[ИмяПараметра]);
	
КонецФункции

Функция ПолучитьИмяТипаПоСсылке(Ссылка)
	
	Возврат СтрЗаменить(Метаданные.НайтиПоТипу(ТипЗнч(Ссылка)).ПолноеИмя(), ".", "Ссылка.");
	
КонецФункции

Функция ДанныеВерсииКлассификатора(OID, Версия)
	
	ДанныеВерсии = ИнтеграцияЕГИСЗСерверПовтИсп.ДанныеВерсииКлассификатора(OID, Версия);
	Если Не ЗначениеЗаполнено(ДанныеВерсии.Наименование) Тогда
		УстановитьПривилегированныйРежим(Истина);
		ЗагрузкаКлассификаторовНСИЕГИСЗ.СохранитьНаименованиеКлассификатора(OID, Версия);
		
		// Уже обновлены повторно используемые значения через ЗагрузкаКлассификаторовНСИЕГИСЗ.СохранитьНаименованиеКлассификатора()
		// (через модуль записей регистра).
		ДанныеВерсии = ИнтеграцияЕГИСЗСерверПовтИсп.ДанныеВерсииКлассификатора(OID, Версия);
	КонецЕсли;
	
	Возврат ДанныеВерсии;
	
КонецФункции

Функция ПолучитьЗначениеАтрибутаЭлементаКлассификатора(Ссылка, Ключ) Экспорт
	
	Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(Ссылка, "Атрибуты") Тогда
		СтрокаАтрибута = Ссылка.Атрибуты.НайтиСтроки(Новый Структура("Ключ", Ключ));
		Если СтрокаАтрибута.Количество() > 0 Тогда
			Возврат СтрокаАтрибута[0].Значение;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

Функция ПолучитьЭлементКлассификатораПоЗначениюАтрибута(Атрибут, ЗначениеАтрибута, ВидКлассификатора = Неопределено, OIDСправочникаИсточника = Неопределено) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	АтрибутыКлассификатора.Ссылка КАК Ссылка
		|ИЗ
		|	&АтрибутыКлассификатора КАК АтрибутыКлассификатора
		|ГДЕ
		|	&УсловиеВидаКлассификатора
		|	И НЕ АтрибутыКлассификатора.Ссылка.ПометкаУдаления
		|	И АтрибутыКлассификатора.Ключ = &Атрибут
		|	И (ВЫРАЗИТЬ(АтрибутыКлассификатора.Значение КАК СТРОКА(1024))) = &ЗначениеАтрибута";
	
	Запрос.УстановитьПараметр("Атрибут", Атрибут);
	Запрос.УстановитьПараметр("ЗначениеАтрибута", Строка(ЗначениеАтрибута));
	
	Если ЗначениеЗаполнено(ВидКлассификатора) Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&АтрибутыКлассификатора", "Справочник.КлассификаторыМинЗдрава.Атрибуты");
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеВидаКлассификатора", "АтрибутыКлассификатора.Ссылка.ВидКлассификатора = &ВидКлассификатора");
		Запрос.УстановитьПараметр("ВидКлассификатора", ВидКлассификатора);
	ИначеЕсли ЗначениеЗаполнено(OIDСправочникаИсточника) Тогда
		ПараметрыСправочника = ИнтеграцияЕГИСЗСерверПовтИсп.ПолучитьПараметрыСправочникаЕГИСЗ(OIDСправочникаИсточника);
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&АтрибутыКлассификатора", СтрШаблон("%1.Атрибуты", ПараметрыСправочника.ПолноеНаименование));
		Запрос.УстановитьПараметр("УсловиеВидаКлассификатора", Истина);
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	Попытка
		Выборка = Запрос.Выполнить().Выбрать();
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
	Если Выборка.Следующий() Тогда
		Возврат Выборка.Ссылка;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

Функция ПолучитьАдресПоВидуАдреса(Объект, ВидАдреса) Экспорт
	
	Запись = РегистрыСведений.КонтактнаяИнформация.СоздатьМенеджерЗаписи();
	Запись.Объект	= Объект;
	Запись.Тип		= Перечисления.ТипыКонтактнойИнформации.Адрес;
	Запись.Вид		= ВидАдреса;
	Запись.Прочитать();
	
	СтруктураАдреса = Новый Структура("Представление, СубъектРФ, Район, Город, НаселПункт, Улица, Дом, Корпус, Квартира, ЗначенияПолей");
	
	Если Запись.Выбран() Тогда
		// Адрес найден
		Если Не ЗначениеЗаполнено(Запись.ЗначенияПолей) Тогда
			Запись = КонтактнаяИнформацияСервер.ОбновитьКИПодФорматФИАС(Объект, Запись.Вид);	
		КонецЕсли;
		
		ДанныеАдреса = Новый Структура("ЗначенияПолей", Запись.ЗначенияПолей);
		ДанныеАдреса.Вставить("Представление", СокрЛП(Запись.Представление));
		ДанныеАдреса.Вставить("СубъектРФ", ?(ЗначениеЗаполнено(Запись.Поле2), Запись.Поле2, КонтактнаяИнформацияСервер.ПолучитьПредставлениеЭлементовАдресов(Запись.ЗначенияПолей, Истина).СубъектРФ));
		
		Возврат ДанныеАдреса;
	Иначе
		// У пациента нет подходящего адреса
		Возврат ОбщегоНазначенияРасширенный.СоздатьСтруктуруПоЭлементуКоллекции(СтруктураАдреса, , "");
	КонецЕсли;
	
КонецФункции

Процедура ОбновитьКэшОтветов(МедицинскаяОрганизация, ТекстУспешноПодписан) Экспорт
	
	НЗ = РегистрыСведений.ИнтеграцияЕГИСЗКэшОтветов.СоздатьНаборЗаписей();
	НЗ.Отбор.МедицинскаяОрганизация.Установить(МедицинскаяОрганизация);
	НЗ.Отбор.СообщениеРЭМД.Установить(Справочники.СообщенияРЭМД.ПустаяСсылка());
	
	СертификатЭЦП = ПолучитьЗначениеНастройки("СертификатЭЦППодписиSOAPСообщений",, МедицинскаяОрганизация);
	Если ЗначениеЗаполнено(СертификатЭЦП)
		И СертификатЭЦП.ДействителенДо > ТекущаяДата()
	Тогда
		ТекстУспешногоОтветаРегистрации = СформироватьТекстУспешногоОтветаРегистрации(СертификатЭЦП);
		Если ЗначениеЗаполнено(ТекстУспешногоОтветаРегистрации) Тогда
			СтрокаКэшаОтветов = НЗ.Добавить();
			СтрокаКэшаОтветов.МедицинскаяОрганизация			= МедицинскаяОрганизация;
			СтрокаКэшаОтветов.Подсистема						= Перечисления.ПодсистемыЕГИСЗ.РЭМД;
			СтрокаКэшаОтветов.Запрос							= "registerDocumentResult";
			СтрокаКэшаОтветов.КэшОтвета							= ТекстУспешногоОтветаРегистрации;
			СтрокаКэшаОтветов.ДатаОкончанияДействияСертификата	= СертификатЭЦП.ДействителенДо;
		Иначе
			ТекстУспешноПодписан = Ложь;
		КонецЕсли;
	КонецЕсли;
	
	НЗ.Записать();
	
КонецПроцедуры

Функция СформироватьТекстУспешногоОтветаРегистрации(СертификатЭЦП)
	
	ШаблонКонверта =
		"<soap:Envelope xmlns:soap=""http://www.w3.org/2003/05/soap-envelope"">
		|	<soap:Header>
		|		<MessageID xmlns=""http://www.w3.org/2005/08/addressing"">uuid:%1</MessageID>
		|	</soap:Header>
		|	<soap:Body>
		|		%2
		|	</soap:Body>
		|</soap:Envelope>";
	
	Тело = ИнтеграцияЕГИСЗ_РЭМД.ТекстXMLCallbackResponse();
	
	Конверт = СтрШаблон(ШаблонКонверта, Строка(Новый УникальныйИдентификатор), СтрЗаменить(Тело, Символы.ПС, Символы.ПС + Символы.Таб + Символы.Таб));
	ТекстНеподписанногоСообщения = Конверт;
	ТекстПодписанногоСообщения = ИнтеграцияЕГИСЗ_ЭЦП.ПодписатьSoapСообщение(Конверт, СертификатЭЦП);
	
	Если ТекстПодписанногоСообщения = ТекстНеподписанногоСообщения
		Или ТекстСообщенияСодержитНезаполненныеТегиСертификата(ТекстПодписанногоСообщения)
	Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ТекстПодписанногоСообщения;
	
КонецФункции

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

Функция ОбновитьСправочник(OID, ВЗависимостиОтРежима = Истина) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	МенеджерЗаписи = РегистрыСведений.НастройкиОбновленияСправочниковЕГИСЗ.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.Классификатор = OID;
	МенеджерЗаписи.Прочитать();
	
	Если Не ЗначениеЗаполнено(МенеджерЗаписи.Наименование) Тогда
		ПаспортСправочника = ЗагрузкаКлассификаторовНСИЕГИСЗ.ПолучитьПаспортСправочника(OID);
		Если ПаспортСправочника = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
		
		МенеджерЗаписи.Классификатор	= OID;
		МенеджерЗаписи.Наименование		= ПаспортСправочника.fullName;
		МенеджерЗаписи.Записать();
	КонецЕсли;
	
	Если ВЗависимостиОтРежима Тогда
		РежимОбновления = МенеджерЗаписи.РежимОбновления;
		Если РежимОбновления = Перечисления.РежимыАвтоОбновленияСправочниковЕГИСЗ.Выключено
			Или Не ЗначениеЗаполнено(РежимОбновления)
		Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	ПараметрыСправочника = ИнтеграцияЕГИСЗСерверПовтИсп.ПолучитьПараметрыСправочникаЕГИСЗ(OID);
	Менеджер = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПараметрыСправочника.ПолноеНаименование);
	
	ВидКлассификатора = Неопределено;
	ПараметрыСправочника.Свойство("ВидКлассификатора", ВидКлассификатора);
	
	ИмяСправочника = ПараметрыСправочника.Наименование;
	ТекущаяВерсия = МенеджерЗаписи.Версия; 
	
	Версии = ЗагрузкаКлассификаторовНСИЕГИСЗ.ПолучитьВсеВерсииКлассификатора(OID);
	Если Версии = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ПоследняяВерсия = Версии[Версии.Количество()-1].Версия;
	ДатаВерсии = Версии[Версии.Количество()-1].ДатаОбновления;
	
	Если ТекущаяВерсия <> ПоследняяВерсия Тогда
		
		Если ЗначениеЗаполнено(ТекущаяВерсия) Тогда
			СправочникОбновлен = ЗагрузкаОбновленийСправочника(OID, ТекущаяВерсия, ПоследняяВерсия, ВидКлассификатора, Менеджер, РежимОбновления);
		Иначе
			СправочникОбновлен = Ложь;
		КонецЕсли;
		
		Если Не СправочникОбновлен Тогда
			СправочникОбновлен = ПолнаяЗагрузкаСправочника(OID, ПоследняяВерсия, ИмяСправочника, ВидКлассификатора, Менеджер, РежимОбновления);
		КонецЕсли;
	Иначе
		СправочникОбновлен = Истина;
		ЗагрузкаКлассификаторовНСИЕГИСЗ.СохранитьНаименованиеКлассификатора(OID, ТекущаяВерсия);
	КонецЕсли;
	
	Если СправочникОбновлен Тогда
		МенеджерЗаписи.ДатаПоследнегоОбновления = ТекущаяДата();
		МенеджерЗаписи.Версия					= ПоследняяВерсия;
		МенеджерЗаписи.ДатаВерсии				= ДатаВерсии;
		МенеджерЗаписи.Записать();
		Возврат Истина;
	Иначе
		ОбщегоНазначения.СообщитьОбОшибке(СтрШаблон(НСтр("ru='Ошибка обновления справочника %1!'"),ПараметрыСправочника.Представление));
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

Функция ЗагрузкаОбновленийСправочника(OID, ТекущаяВерсия, ПоследняяВерсия, ВидКлассификатора, Менеджер, РежимОбновления)
	
	ТаблицаКлассификатор = ЗагрузкаКлассификаторовНСИЕГИСЗ.ЗапроситьОбновлениеКлассификатора(OID, ТекущаяВерсия, Менеджер,ВидКлассификатора);
	
	Если ТаблицаКлассификатор = Неопределено
		Или ТаблицаКлассификатор.Количество() = 0
	Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Попытка
		Менеджер.ЗагрузкаСправочникаПередНачаломЗагрузки(ТаблицаКлассификатор, OID, Неопределено);
	Исключение КонецПопытки;
	
	ТаблицаКлассификатор = НайтиГруппыВТаблице(ТаблицаКлассификатор);
	
	Попытка
		Сч = 0;
		Для Каждого СтрокаКлассификатора Из ТаблицаКлассификатор Цикл
			Если СтрокаКлассификатора.OPER = "u" Тогда
				Результат = ИзменитьЭлементСправочника(Менеджер, ПоследняяВерсия, СтрокаКлассификатора);
			ИначеЕсли СтрокаКлассификатора.OPER = "d" Тогда
				Результат = ПоместитьВАрхивЭлементСправочника(Менеджер, ПоследняяВерсия, СтрокаКлассификатора);
			ИначеЕсли СтрокаКлассификатора.OPER = "i" Тогда
				Если РежимОбновления <> Перечисления.РежимыАвтоОбновленияСправочниковЕГИСЗ.ТолькоЗагруженных Тогда
					Результат = ДобавитьЭлементСправочника(Менеджер, ПоследняяВерсия, СтрокаКлассификатора, OID);
				Иначе
					Результат = Истина;
				КонецЕсли;
			Иначе
				Прервать;
			КонецЕсли;
			
			Если Не Результат Тогда
				Прервать;
			КонецЕсли;
			
			Сч = Сч + 1;
		КонецЦикла;
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
	Если Сч = ТаблицаКлассификатор.Количество() Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

Функция ДобавитьЭлементСправочника(Менеджер, ПоследняяВерсия, СтрокаКлассификатора, OID)
	
	Если СтрокаКлассификатора.УИДЕГИСЗРодителя > 0 Тогда
		СсылкаРодитель = Менеджер.НайтиПоРеквизиту("УИДЕГИСЗ", СтрокаКлассификатора.УИДЕГИСЗРодителя);
		Если СсылкаРодитель = Неопределено Или Не СсылкаРодитель.ЭтоГруппа Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Если СтрокаКлассификатора.ЭтоГруппа Тогда
		ЗаписьОбъект = Менеджер.СоздатьГруппу();
	Иначе
		ЗаписьОбъект = Менеджер.СоздатьЭлемент();
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(ЗаписьОбъект,СтрокаКлассификатора);
	
	// Заполняем атрибуты
	Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(ЗаписьОбъект, "Атрибуты") Тогда
		Для Каждого СтрокаАтрибута Из СтрокаКлассификатора.Атрибуты Цикл
			НоваяСтрока = ЗаписьОбъект.Атрибуты.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока,СтрокаАтрибута);
		КонецЦикла;
	КонецЕсли;
	
	// Заполняем родителя
	Если ЗначениеЗаполнено(СсылкаРодитель) Тогда
		ЗаписьОбъект.Родитель = СсылкаРодитель;
	КонецЕсли;
	
	ЗаписьОбъект.OIDСправочникаИсточника = OID;
	ЗаписьОбъект.ВерсияКлассификатораМинздрава = ПоследняяВерсия;
	
	ЗаписьОбъект.Записать();
	
	Возврат Истина;
	
КонецФункции

Функция ИзменитьЭлементСправочника(Менеджер, ПоследняяВерсия, СтрокаКлассификатора)
	
	Если СтрокаКлассификатора.УИДЕГИСЗРодителя > 0 Тогда
		СсылкаРодитель = Менеджер.НайтиПоРеквизиту("УИДЕГИСЗ", СтрокаКлассификатора.УИДЕГИСЗРодителя);
		Если СсылкаРодитель = Неопределено Или Не СсылкаРодитель.ЭтоГруппа Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	ЗаписьСсылка = Менеджер.НайтиПоРеквизиту("УИДЕГИСЗ", СтрокаКлассификатора.УИДЕГИСЗ);
	Если ЗначениеЗаполнено(ЗаписьСсылка) Тогда
		ЗаписьОбъект = ЗаписьСсылка.ПолучитьОбъект();
		
		Если СтрокаКлассификатора.ЭтоГруппа И Не ЗаписьОбъект.ЭтоГруппа Тогда
			ЗаписьОбъект.Удалить();
			ЗаписьОбъект = Менеджер.СоздатьГруппу();
		КонецЕсли;
		
		ЗаполнитьЗначенияСвойств(ЗаписьОбъект,СтрокаКлассификатора);
		
		// Обновляем атрибуты
		Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(ЗаписьОбъект, "Атрибуты") Тогда
			ЗаписьОбъект.Атрибуты.Очистить();
			Для Каждого СтрокаАтрибута Из СтрокаКлассификатора.Атрибуты Цикл
				НоваяСтрока = ЗаписьОбъект.Атрибуты.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрока,СтрокаАтрибута);
			КонецЦикла;
		КонецЕсли;
		
		// Обновляем родителя
		Если ЗначениеЗаполнено(СсылкаРодитель) Тогда
			ЗаписьОбъект.Родитель = СсылкаРодитель;
		КонецЕсли;
		ЗаписьОбъект.ВерсияКлассификатораМинздрава = ПоследняяВерсия;
		ЗаписьОбъект.Записать();
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

Функция ПоместитьВАрхивЭлементСправочника(Менеджер, ПоследняяВерсия, СтрокаКлассификатора)
	
	ЗаписьСсылка = Менеджер.НайтиПоРеквизиту("УИДЕГИСЗ", СтрокаКлассификатора.УИДЕГИСЗ);
	Если ЗначениеЗаполнено(ЗаписьСсылка) Тогда
		ЗаписьОбъект = ЗаписьСсылка.ПолучитьОбъект();
		ЗаписьОбъект.Архив							= Истина;
		ЗаписьОбъект.ВерсияКлассификатораМинздрава	= ПоследняяВерсия;
		ЗаписьОбъект.Записать();
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

Функция НайтиГруппыВТаблице(ТаблицаКлассификатор)
	
	ТаблицаКлассификатор.Колонки.Добавить("ЭтоГруппа", Новый ОписаниеТипов("Булево"));
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	ТаблицаКлассификатор.УИДЕГИСЗ КАК УИДЕГИСЗ,
		|	ТаблицаКлассификатор.УИДЕГИСЗРодителя КАК УИДЕГИСЗРодителя
		|ПОМЕСТИТЬ ТаблицаКлассификатор
		|ИЗ
		|	&ТаблицаКлассификатор КАК ТаблицаКлассификатор
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ТаблицаКлассификатор.УИДЕГИСЗ КАК УИДЕГИСЗ,
		|	ТаблицаКлассификатор.УИДЕГИСЗРодителя КАК УИДЕГИСЗРодителя
		|ИЗ
		|	ТаблицаКлассификатор КАК ТаблицаКлассификатор
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ТаблицаКлассификатор КАК ТаблицаКлассификатор1
		|		ПО ТаблицаКлассификатор.УИДЕГИСЗ = ТаблицаКлассификатор1.УИДЕГИСЗРодителя";
	
	Запрос.УстановитьПараметр("ТаблицаКлассификатор", ТаблицаКлассификатор);
	РезультатЗапроса = Запрос.Выполнить();
	Выборка = РезультатЗапроса.Выбрать();
	Пока Выборка.Следующий() Цикл
		СтрокаТабл = ТаблицаКлассификатор.НайтиСтроки(Новый Структура("УИДЕГИСЗ", Выборка.УИДЕГИСЗ))[0];
		СтрокаТабл.ЭтоГруппа = Истина;
	КонецЦикла;
	
	ТаблицаКлассификатор.Сортировать("ЭтоГруппа Убыв, УИДЕГИСЗ Возр");
	
	Возврат ТаблицаКлассификатор;
	
КонецФункции

Функция ПолнаяЗагрузкаСправочника(OID, Версия, НаименованиеСправочника, ВидКлассификатора, Менеджер, РежимОбновления)
	
	Попытка
		ТаблицаКлассификатор = ЗагрузкаКлассификаторовНСИЕГИСЗ.ЗапроситьКлассификатор(OID, Версия, Менеджер, ВидКлассификатора);
		
		ПараметрыЗаписи = Новый Структура;
		ПараметрыЗаписи.Вставить("Версия",					Версия);
		ПараметрыЗаписи.Вставить("OID",						OID);
		ПараметрыЗаписи.Вставить("МенеджерСправочника",		Менеджер);
		ПараметрыЗаписи.Вставить("НаименованиеСправочника",	НаименованиеСправочника);
		
		Если ВидКлассификатора <> Неопределено Тогда
			ПараметрыЗаписи.Вставить("ВидКлассификатора",ВидКлассификатора);
		КонецЕсли; 
		ЗагрузкаКлассификаторовНСИЕГИСЗ.ЗаписатьНовыеЭлементыСправочника(ПараметрыЗаписи, ТаблицаКлассификатор, , , РежимОбновления);
		
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
	Возврат Истина;
	
КонецФункции

// Проверка существует ли файл
Функция ФайлСуществует(ИмяФайла) Экспорт
	
	Файл = Новый Файл(ИмяФайла);
	Возврат Файл.Существует();
	
КонецФункции

Функция ЭлементКлассификатораПоID(УИДЕГИСЗ, ИмяСправочника, ВидКлассификатора = Неопределено) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("УИДЕГИСЗ", УИДЕГИСЗ);
	Запрос.УстановитьПараметр("ВидКлассификатора", ВидКлассификатора);
	
	Если ИмяСправочника = Метаданные.Справочники.КлассификаторыМинЗдрава.Имя Тогда
		Запрос.Текст = 
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	КлассификаторыМинЗдрава.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.КлассификаторыМинЗдрава КАК КлассификаторыМинЗдрава
		|ГДЕ
		|	КлассификаторыМинЗдрава.ВидКлассификатора = &ВидКлассификатора
		|	И КлассификаторыМинЗдрава.УИДЕГИСЗ = &УИДЕГИСЗ
		|	И НЕ КлассификаторыМинЗдрава.ПометкаУдаления
		|	И НЕ КлассификаторыМинЗдрава.Архив"
		;
	Иначе
		Запрос.Текст = СтрШаблон(
		 "ВЫБРАТЬ
		 |	Ссылка КАК Ссылка,
		 |	OIDСправочникаИсточника КАК OIDСправочникаИсточника
		 |ИЗ
		 |	Справочник.%1 КАК Таблица
		 |ГДЕ
		 |	УИДЕГИСЗ = &УИДЕГИСЗ
		 |	И НЕ ПометкаУдаления
		 |	И НЕ Архив",
		ИмяСправочника);
	КонецЕсли;
	
	Выб = Запрос.Выполнить().Выбрать();
	
	Пока Выб.Следующий() Цикл
		
		Если ЗначениеЗаполнено(ВидКлассификатора) // Справочник "КлассификаторыМинЗдрава".
			Или Выб.OIDСправочникаИсточника = Справочники[ИмяСправочника].ПолучитьOIDСправочника() // Загружен из актуального oid.
		Тогда
			Возврат Выб.Ссылка;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

Функция КэшОтветаЕГИСЗ(МедицинскаяОрганизация, Подсистема, Запрос, СообщениеРЭМД = Неопределено) Экспорт
	
	Если СообщениеРЭМД = Неопределено Тогда
		СообщениеРЭМД = Справочники.СообщенияРЭМД.ПустаяСсылка();
	КонецЕсли;
	
	МЗ = РегистрыСведений.ИнтеграцияЕГИСЗКэшОтветов.СоздатьМенеджерЗаписи();
	МЗ.МедицинскаяОрганизация = МедицинскаяОрганизация;
	МЗ.СообщениеРЭМД = СообщениеРЭМД;
	МЗ.Подсистема = Подсистема;
	МЗ.Запрос = Запрос;
	МЗ.Прочитать();
	
	Если МЗ.Выбран()
		И ЗначениеЗаполнено(МЗ.КэшОтвета)
		И МЗ.ДатаОкончанияДействияСертификата > ТекущаяДата()
	Тогда
		Возврат МЗ.КэшОтвета;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

Процедура УдалитьКэшОтветаПоЗапросу(МедицинскаяОрганизация, Подсистема, Запрос, СообщениеРЭМД = Неопределено) Экспорт
	
	СохранитьКэшОтветаПоЗапросу(МедицинскаяОрганизация, Подсистема, Запрос, СообщениеРЭМД);
	
КонецПроцедуры

Процедура СохранитьКэшОтветаПоЗапросу(МедицинскаяОрганизация, Подсистема, Запрос, СообщениеРЭМД = Неопределено, КэшОтвета = Неопределено, ДатаОкончанияДействияСертификата = Неопределено) Экспорт
	
	Если Не (ЗначениеЗаполнено(МедицинскаяОрганизация)
			И ЗначениеЗаполнено(Подсистема)
			И ЗначениеЗаполнено(Запрос))
	Тогда
		Возврат;
	КонецЕсли;
	
	Если СообщениеРЭМД = Неопределено Тогда
		СообщениеРЭМД = Справочники.СообщенияРЭМД.ПустаяСсылка();
	КонецЕсли;
	
	МЗ = РегистрыСведений.ИнтеграцияЕГИСЗКэшОтветов.СоздатьМенеджерЗаписи();
	МЗ.МедицинскаяОрганизация = МедицинскаяОрганизация;
	МЗ.СообщениеРЭМД = СообщениеРЭМД;
	МЗ.Подсистема = Подсистема;
	МЗ.Запрос = Запрос;
	
	Если Не (ЗначениеЗаполнено(КэшОтвета)
			И ЗначениеЗаполнено(ДатаОкончанияДействияСертификата))
	Тогда
		МЗ.Удалить();
	Иначе
		МЗ.КэшОтвета = КэшОтвета;
		МЗ.ДатаОкончанияДействияСертификата = ДатаОкончанияДействияСертификата;
		МЗ.Записать();
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура ЕГИСЗПриИзмененииДанныхКлиентаПриЗаписи(Источник, Отказ) Экспорт
	
	// Если запись вызвана не событием обмена данными с ГИП, то зафиксируем изменения данных пациента для отправки туда рег.заданием.
	Если Не Отказ И ТипЗнч(Источник) = Тип("СправочникОбъект.Клиенты")
		И Не Источник.ПометкаУдаления
		И ИнтеграцияЕГИСЗСерверПовтИсп.ДоступенОбменСГИП()
	Тогда
		УстановитьПривилегированныйРежим(Истина);
		
		ГИПНоваяЗапись = РегистрыСведений.ГИПИзмененныеПациенты.СоздатьМенеджерЗаписи();
		ГИПНоваяЗапись.Пациент			= Источник.Ссылка;
		ГИПНоваяЗапись.ДатаИзменений	= ТекущаяДатаСеанса();
		ГИПНоваяЗапись.Записать();
		
		УстановитьПривилегированныйРежим(Ложь);
	КонецЕсли;
	
КонецПроцедуры

// Построение документа DOM из стоки XML
//
// Параметры:
//  СтрокаXML	 - Строка	 - Строка XML, по которой нужно построить DOM.
// 
// Возвращаемое значение:
//  ДокументDOM - Построенный по строке XML документ DOM.
//
Функция ПостроитьDOM(СтрокаXML) Экспорт
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);
	
	ПостроительDOM = Новый ПостроительDOM;
	ДокументDOM = ПостроительDOM.Прочитать(ЧтениеXML);
	
	Возврат ДокументDOM;
	
КонецФункции

Функция ПолучитьСтрокуПоXPath(ДокументDOM, Знач Разыменователь = Неопределено, XPath) Экспорт
	
	Если Неопределено = Разыменователь Тогда
		Разыменователь = ДокументDOM.СоздатьРазыменовательПИ();
	КонецЕсли;
	
	ТипРезультата = ТипРезультатаDOMXPath.Строка;
	
	РезультатXPath = ДокументDOM.ВычислитьВыражениеXPath(
		XPath, ДокументDOM, Разыменователь, ТипРезультата
	);
	
	Возврат РезультатXPath.СтроковоеЗначение;
	
КонецФункции

// Выполняет проверку текста XML на соответствие использованным в нём схемам.
//  В случае ошибки фисирует её в журнале регистрации.
//
// Параметры:
//  ТекстXML - Строка	 - Проверяемый документ XML.
//
Процедура ПроверитьПространтваИменВXML(ТекстXML) Экспорт
	
	Попытка
		// Получение на языке XPath выборки элементов из текста XML для сбора из них URI пространств имен.
		ДокументDOM = ИнтеграцияЕГИСЗСервер.ПостроитьDOM(ТекстXML);
		
		КомандаXPath = "//. | //@*"; // Выборка узлов и атрибутов из документа DOM;
		ПустойРазыменователь = Новый РазыменовательПространствИменDOM(Новый Соответствие);
		ТипXPath = ТипРезультатаDOMXPath.НеупорядоченныйИтераторУзлов;
		
		// Непосредственно выборка элементов.
		XPathВыборкаУзловXML = ДокументDOM.ВычислитьВыражениеXPath(КомандаXPath, ДокументDOM, ПустойРазыменователь, ТипXPath);
		
		// Строка для сбора всех URI пространств имен, найденных в тексте XML.
		ПространстваИменDOM = "";
		
		Пока Истина Цикл
			
			// Следующий элемент или атрибут документа.
			Элемент = XPathВыборкаУзловXML.ПолучитьСледующий();
			
			// Проверка, не пройдены ли все элементы.
			Если Элемент = Неопределено Тогда
				Прервать;
			КонецЕсли;
			
			URIПространства = Элемент.URIПространстваИмен;
			
			// Проверка заполненности пространства имен.
			Если ЗначениеЗаполнено(URIПространства)
			 	И URIПространства <> ПространстваИмен.URI("xsi")
			Тогда
				// Добавление пространства в строку найденных
				СтрокаПоискаURI = Символы.ПС + URIПространства + Символы.ПС;
				Если СтрНайти(ПространстваИменDOM, СтрокаПоискаURI) = 0 Тогда
					ПространстваИменDOM = ПространстваИменDOM + СтрокаПоискаURI;
				КонецЕсли;
			КонецЕсли;
			
		КонецЦикла;
		
		// Проверка набора схем
		НаборСхемXML = ИнтеграцияЕГИСЗСерверПовтИсп.ПолучитьНаборСхемXML(ПространстваИменDOM);
		ПроверкаСхемУспешна = НаборСхемXML.Проверить();
		
		// Подготовка к чтению XML с учетом набора схем.
		ЧтениеXML = Новый ЧтениеXML;
		ЧтениеXML.УстановитьСтроку(ТекстXML, Новый ПараметрыЧтенияXML(,,,ТипПроверкиXML.СхемаXML), НаборСхемXML);
		
		// Если чтение будет успешным, то проверка пройдена.
		ЧтениеXML.Прочитать();
		ЧтениеXML.Закрыть();
		
	Исключение
		
		// Фиксация ошибки в журнал регистрации.
		Ошибка = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ЗаписьЖурналаРегистрации("ИнтеграцияРЭМД.Ошибка",
								 УровеньЖурналаРегистрации.Ошибка,
								 ,
								 ТекстXML,
								 Ошибка);
	КонецПопытки;
	
КонецПроцедуры

Процедура ДобавитьВНаборСхем(НаборСхем, МассивПространствИмен, ИндексВМассиве) Экспорт
	
	// Выбираем искомое пространство имен из массива.
	ПространствоИмен = МассивПространствИмен[ИндексВМассиве];
	
	// Текстом файла со схемой может быть содержимое xsd файла, описание wsdl или содержимое
	// любого другого документа XML, содержащего тег <xs:schema>.
	ТекстФайлаСоСхемой = ИнтеграцияЕГИСЗСерверПовтИсп.ПолучитьТекстФайлаСоСхемой(ПространствоИмен);
	
	// Для выполнения запросов XPath нам потребуется разыменователь с пространством имен xs.
	ПИ = Новый РазыменовательПространствИменDOM("xs", ПространстваИмен.xs());
	
	// Также нам потребуется следующий тип результата XPath.
	ТипРезультата = ТипРезультатаDOMXPath.ЛюбойНеупорядоченныйУзел;
	
	// Для выбора схемы будем использовать такой запрос XPath.
	XPathСхемаXML = СтрШаблон("//xs:schema[@targetNamespace='%1']", ПространствоИмен);
	
	КолВо = -1;
	Если ТипЗнч(ТекстФайлаСоСхемой) = Тип("Массив") Тогда
		КолВо = ТекстФайлаСоСхемой.Количество();
	КонецЕсли;
	
	Для Индекс = 0 По ?(КолВо < 0, 0, КолВо - 1) Цикл
		
		// Преобразуем описание WSDL в DOM для выполнения запросов XPath.
		ДокументDOM = ИнтеграцияЕГИСЗСервер.ПостроитьDOM(
			?(КолВо < 0, ТекстФайлаСоСхемой, ТекстФайлаСоСхемой[Индекс])
		);
		
		// Выполним запрос XPath.
		РезультатXPath =
			ДокументDOM.ВычислитьВыражениеXPath(XPathСхемаXML, ДокументDOM, ПИ, ТипРезультата)
		;
		// Результатом запроса XPath должен быть корневой узел схемы.
		КорневойУзелСхемы = РезультатXPath.ОдиночныйУзелЗначение;
		
		// В схеме могут встречаться теги <xs:import> и <xs:include>, в которых атрибут
		// schemaLocation ссылается на недоступное место. Когда платформа 1С:Предприятие выполняет
		// проверку на соответствие xml схеме, она пытается загрузить внешние схемы, указанные в
		// этих тегах. Подождав некоторое время (несколько десятков секунд) и не получив ответ,
		// платформа выдает ошибку. Чтобы этого не происходило, удалим из тегов <xs:import> и
		// <xs:include> атрибут schemaLocation. Для этого также используем XPath.
		ШаблонXPath = "./*[(local-name()='import' or local-name()='include') and namespace-uri()='%1']";
		XPath = СтрШаблон(ШаблонXPath, ПространстваИмен.xs());
		РезультатXPath =
			ДокументDOM.ВычислитьВыражениеXPath(
				XPath, КорневойУзелСхемы, ПИ, ТипРезультатаDOMXPath.НеупорядоченныйИтераторУзлов
			)
		;
		Узел = РезультатXPath.ПолучитьСледующий();
		Пока Не Неопределено = Узел Цикл
			Если Узел.ЕстьАтрибут("namespace") Тогда
				// Заодно добавим импортируемое пространство имен в массив пространств имен.
				ДополнительноеПИ = Узел.ПолучитьАтрибут("namespace");
				Если Неопределено = МассивПространствИмен.Найти(ДополнительноеПИ) Тогда
					МассивПространствИмен.Добавить(ДополнительноеПИ);
				КонецЕсли;
			КонецЕсли;
			Если Узел.ЕстьАтрибут("schemaLocation") Тогда
				Узел.УдалитьАтрибут("schemaLocation");
			КонецЕсли;
			Узел = РезультатXPath.ПолучитьСледующий();
		КонецЦикла;
		
		// Для создания схемы используем построитель схем.
		ПостроительСхем = Новый ПостроительСхемXML;
		// Собственно, создаем схему.
		СхемаXML = ПостроительСхем.СоздатьСхемуXML(КорневойУзелСхемы);
		
		// Теперь нужно обновить ДОМ схемы, иначе манипуляции с тегами <xs:import> и <xs:include>
		// не будут учтены. Можно просто удалить его.
		СхемаXML.ДокументDOM = Неопределено;
		
		// Добавляем схему в набор.
		НаборСхем.Добавить(СхемаXML);
		
	КонецЦикла;
	
КонецПроцедуры

Функция СтруктураURI(АдресДляОтправки) Экспорт
	
	// Если подсистема работает в составе конфигурации "1С:Медицина", то переадресуем вызов
	// в общий модуль ОбщегоНазначенияКлиентСервер.
	Если Не Неопределено = Метаданные.ОбщиеМодули.Найти("ОбщегоНазначенияКлиентСервер") Тогда
		ОписаниеОшибки = "";
		Возврат Вычислить(
			"ОбщегоНазначенияКлиентСервер.СтруктураURI(АдресДляОтправки)"
		);
	КонецЕсли;
	
	// Следующий код скопирован из общего модуля ОбщегоНазначенияКлиентСервер.
	
	СтрокаURI = СокрЛП(АдресДляОтправки);
	
	// схема
	Схема = "";
	Позиция = СтрНайти(СтрокаURI, "://");
	Если Позиция > 0 Тогда
		Схема = НРег(Лев(СтрокаURI, Позиция - 1));
		СтрокаURI = Сред(СтрокаURI, Позиция + 3);
	КонецЕсли;
	
	// Строка соединения и путь на сервере.
	СтрокаСоединения = СтрокаURI;
	ПутьНаСервере = "";
	Позиция = СтрНайти(СтрокаСоединения, "/");
	Если Позиция > 0 Тогда
		ПутьНаСервере = Сред(СтрокаСоединения, Позиция + 1);
		СтрокаСоединения = Лев(СтрокаСоединения, Позиция - 1);
	КонецЕсли;
	
	// Информация пользователя и имя сервера.
	СтрокаАвторизации = "";
	ИмяСервера = СтрокаСоединения;
	Позиция = СтрНайти(СтрокаСоединения, "@");
	Если Позиция > 0 Тогда
		СтрокаАвторизации = Лев(СтрокаСоединения, Позиция - 1);
		ИмяСервера = Сред(СтрокаСоединения, Позиция + 1);
	КонецЕсли;
	
	// логин и пароль
	Логин = СтрокаАвторизации;
	Пароль = "";
	Позиция = СтрНайти(СтрокаАвторизации, ":");
	Если Позиция > 0 Тогда
		Логин = Лев(СтрокаАвторизации, Позиция - 1);
		Пароль = Сред(СтрокаАвторизации, Позиция + 1);
	КонецЕсли;
	
	// хост и порт
	Хост = ИмяСервера;
	Порт = "";
	Позиция = СтрНайти(ИмяСервера, ":");
	Если Позиция > 0 Тогда
		Хост = Лев(ИмяСервера, Позиция - 1);
		Порт = Сред(ИмяСервера, Позиция + 1);
		Если Не СтрРазделить(Порт, "0123456789", Ложь).Количество() = 0 Тогда
			Порт = "";
		КонецЕсли;
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("Схема", Схема);
	Результат.Вставить("Логин", Логин);
	Результат.Вставить("Пароль", Пароль);
	Результат.Вставить("ИмяСервера", ИмяСервера);
	Результат.Вставить("Хост", Хост);
	Результат.Вставить("Порт", ?(ПустаяСтрока(Порт), Неопределено, Число(Порт)));
	Результат.Вставить("ПутьНаСервере", ПутьНаСервере);
	
	Возврат Результат;
	
КонецФункции

// Преобразует уникальный идентификатор в число строкой.
//
// Параметры:
//  УИД	 - УникальныйИдентификатор	 - Уникальный идентификатор.
// 
// Возвращаемое значение:
//	Строка.
//
Функция УИДВЧисло(УИД) Экспорт
	
	СтрокаGUID = СтрЗаменить(Строка(УИД), "-", "");
	Возврат Формат(ЧислоИзШестнадцатеричнойСтроки("0x"+СтрокаGUID), "ЧГ=0; ЧДЦ=0; ЧН=");
	
КонецФункции

Функция ПредставлениеЛокальнойДатыСоСмещением(ЛокальнаяДата, ФорматнаяСтрока, ФорматнаяСтрокаСмещения = "ДФ=HHmm") Экспорт
	
	#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
		Смещение = СмещениеСтандартногоВремени(ЧасовойПоясСеанса());
	#Иначе
		Смещение = СтандартныеПодсистемыКлиент.ПараметрыРаботыКлиента().СмещениеСтандартногоВремени;
	#КонецЕсли
	ПредставлениеСмещения = "Z";
	Если Смещение > 0 Тогда
		ПредставлениеСмещения = "+";
	ИначеЕсли Смещение < 0 Тогда
		ПредставлениеСмещения = "-";
		Смещение = -Смещение;
	КонецЕсли;
	Если Смещение <> 0 Тогда
		ПредставлениеСмещения = ПредставлениеСмещения + Формат('00010101' + Смещение, ФорматнаяСтрокаСмещения);
	КонецЕсли;
	
	Возврат Формат(ЛокальнаяДата, ФорматнаяСтрока) + ПредставлениеСмещения;
	
КонецФункции

// Обработчик рег. задания ИнтеграцияЕГИСЗОбновлениеСправочников
Процедура ОбновитьВсеСправочники() Экспорт
	
	СписокСправочников = ИнтеграцияЕГИСЗСерверПовтИсп.ПолучитьТаблицуСправочниковЕГИСЗ();
	
	Для Каждого ПараметрыСправочника Из СписокСправочников Цикл
		ОбновитьСправочник(ПараметрыСправочника.oid);
	КонецЦикла;
	
	ЗагрузкаКлассификаторовНСИЕГИСЗ.ОбновитьСхематроныИСхемыВизуализации();
	
КонецПроцедуры

Функция ПолучитьНовыйПутьКФайлуВХранилище(ИмяФайла) Экспорт
	ПутьКХранилищу = ИнтеграцияЕГИСЗСерверПовтИсп.ПолучитьПутьКАрхивуРЭМД();
	
	Если Не ЗначениеЗаполнено(ПутьКХранилищу) Тогда
		
		ВызватьИсключение "Не заполнен путь к хранилищу файлов ЭМД.";
	КонецЕсли;
	
	РеквизитыОрганизации = ИнтеграцияЕГИСЗСерверПовтИсп.ПолучитьOIDИНаменованиеМедицинскойОрганизации();
	
	Если Не ЗначениеЗаполнено(РеквизитыОрганизации.КодOIDМедицинскойОрганизации) Тогда
		
		ВызватьИсключение "Не заполнен ""Код OID Медицинской организации"" у организации: " + РеквизитыОрганизации.Наименование;
	КонецЕсли;
	
	// путь исключая путь к хранилищу.
	ОтносительныйПуть = РеквизитыОрганизации.КодOIDМедицинскойОрганизации + ПолучитьРазделительПути()
				+ Формат(ТекущаяДатаСеанса(), "ДФ=ггггММдд") + ПолучитьРазделительПути();
				
	ПолныйПуть = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(ПутьКХранилищу)
					+ ОтносительныйПуть;
	
	ИмяФайлаСПутем = РаботаСФайламиСлужебныйКлиентСервер.ПолучитьУникальноеИмяСПутем(ПолныйПуть, ИмяФайла);
	ПолноеИмяФайлаСПутем = ПолныйПуть + ИмяФайлаСПутем;
	
	ИмяФайлаСОтносительнымПутем = ОтносительныйПуть + ИмяФайлаСПутем; // путь исключая путь к хранилищу.
	
	Возврат Новый Структура("ПолныйПуть, ОтносительныйПуть", ПолноеИмяФайлаСПутем, ИмяФайлаСОтносительнымПутем);
	
КонецФункции

Функция ТекстСообщенияСодержитНезаполненныеТегиСертификата(ТекстПодписанногоСообщения) Экспорт
	
	ТегиСертификата = Новый Массив;
	ТегиСертификата.Добавить("%BinarySecurityToken%");
	ТегиСертификата.Добавить("%DigestValue%");
	ТегиСертификата.Добавить("%SignatureValue%");
	ТегиСертификата.Добавить("%SignatureMethod%");
	ТегиСертификата.Добавить("%DigestMethod%");
	
	Для Каждого ТегСертификата Из ТегиСертификата Цикл
		Если СтрНайти(ТекстПодписанногоСообщения, ТегСертификата) > 0 Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

Функция ПроверкаИспользованияСертификатаЭЦП()
	
	Результат = ИнтеграцияЕГИСЗ_ЭЦП.ПодписатьSoapСообщение("<soap:Envelope xmlns:soap=""http://www.w3.org/2003/05/soap-envelope""><soap:Header></soap:Header></soap:Envelope>");
	
	ЗаменяемыеСтроки = Новый Массив;
	ЗаменяемыеСтроки.Добавить("%BinarySecurityToken%");
	ЗаменяемыеСтроки.Добавить("%DigestValue%");
	ЗаменяемыеСтроки.Добавить("%SignatureValue%");
	ЗаменяемыеСтроки.Добавить("%SignatureMethod%");
	ЗаменяемыеСтроки.Добавить("%DigestMethod%");
	
	ТекстОтвета = 
		"<html>
		|	<body>
		|		<div>
		|			Проверка использования сертификата ЭЦП, указанного в настройках интеграции с ЕГИСЗ, успешно пройдена.
		|		</div>
		|	</body>
		|</html>";
	
	Для Каждого ЗаменяемаяСтрока Из ЗаменяемыеСтроки Цикл
		Если СтрНайти(Результат, ЗаменяемаяСтрока) > 0 Тогда
			ТекстОтвета =
				"<html>
				|	<body>
				|		<div>
				|			Не удалось пройти проверку использования сертификата ЭЦП, указанного в настройках интеграции с ЕГИСЗ. Проверьте доступность сертификата для соответствующего пользователя операционной системы.
				|		</div>
				|		<br>
				|		<div>
				|			Сертификат должен быть доступен пользователю операционной системы, от имени которого будет запускаться сеанс для фонового подписания сообщений при обмене с РЭМД:
				|		</div>
				|		<ul type='disc'>
				|			<li>В клиент-серверном варианте служба агента сервера 1С должна запускаться с учётными данными этого пользователя (т.е. указать конкретного пользователя, а не использовать системную учётную запись);</li>
				|			<li>В файловом – учётные данные должны быть указаны в настройках веб-сервера</li>
				|			<ul type='circle'>
				|				<li>Для IIS: в настройках публикации необходимо указать учётные данные для доступа к физическому пути;</li>
				|				<li>Для Apache: служба «Apache» должна запускаться с учётными данными этого пользователя);</li>
				|			</ul>
				|		</ul>
				|	</body>
				|</html>";
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Ответ = Новый HTTPСервисОтвет(200);
	Ответ.Заголовки.Вставить("Content-Type", "text/html;charset=UTF-8");
	Ответ.УстановитьТелоИзСтроки(ТекстОтвета);
	
	Возврат Ответ;
	
КонецФункции

#КонецОбласти