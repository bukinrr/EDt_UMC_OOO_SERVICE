#Область ПрограммныйИнтерфейс

// Добавляет в список ошибок новую ошибку пользователя для дальнейшей отправки с помощью
// 	процедуры СообщитьОшибкиПользователю().
// 	Предназначена для накопления списка ошибок с последующей обработкой этого списка перед тем, как вывести
// 	пользователю. Полученный список ошибок можно, например, отсортировать по важности, очистить от дублей,
// 	а также вывести пользователю в ином виде, чем выводит метод СообщитьПользователю, например, в табличный документ
//
// Параметры:
//  Ошибки          - Неопределено - будет создан новый список,
//                  значение, установленное при первом вызове этой процедуры со значением Неопределено
//
//  ПолеОшибки      - Строка - значение, которое задается в свойстве Поле объекта СообщениеПользователю
//                    Для автоподстановки номера строки должна содержать "%1"
//                    Например, "Объект.ИНН" или "Объект.Пользователи[%1].Пользователь"
//
//  ТекстДляОднойОшибки - Строка - текст ошибки для случая, когда ГруппаОшибок в коллекции только одна,
//                    например, НСтр("ru = 'Пользователь не выбран.'")
//
//  ГруппаОшибок    - Неопределено - используется для выбора либо текста для одной ошибки,
//                    либо текста для нескольких ошибок, например, имя "Объект.Пользователи"
//                    Если значение не заполнено, тогда используется текст для одной ошибки
//
//  НомерСтроки     - Число - значение от 0 ... , определяющее номер строки, который нужно подставить
//                    в строку ПолеОшибки и в ТекстДляНесколькихОшибок (подставляется НомерСтроки + 1)
//
//  ТекстДляНесколькихОшибок - Строка - текст ошибки для случая, когда добавлено несколько ошибок с одинаковым
//                    свойством ГруппаОшибок, например, НСтр("ru = 'Пользователь в строке %1 не выбран.'")
//
//  ИндексСтроки    - Неопределено - совпадает со значением параметра НомерСтроки.
//                    Число - значение от 0 ... , определяющее номер строки, который нужно подставить
//                    в строку ПолеОшибки.
//
Процедура ДобавитьОшибкуПользователю(Ошибки, ПолеОшибки, ТекстДляОднойОшибки, ГруппаОшибок, НомерСтроки = 0, ТекстДляНесколькихОшибок = "", ИндексСтроки = Неопределено) Экспорт
	
	Если Ошибки = Неопределено Тогда
		Ошибки = Новый Структура;
		Ошибки.Вставить("СписокОшибок", Новый Массив);
		Ошибки.Вставить("ГруппыОшибок", Новый Соответствие);
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ГруппаОшибок) Тогда
		// При незаполненной группе ошибок используется текст для одной ошибки.
	Иначе
		Если Ошибки.ГруппыОшибок[ГруппаОшибок] = Неопределено Тогда
			// Группа ошибок использовалась один раз, используется текст для одной ошибки.
			Ошибки.ГруппыОшибок.Вставить(ГруппаОшибок, Ложь);
		Иначе
			// Группа ошибок использовалась несколько раз, используется текст для нескольких ошибок.
			Ошибки.ГруппыОшибок.Вставить(ГруппаОшибок, Истина);
		КонецЕсли;
	КонецЕсли;
	
	Ошибка = Новый Структура;
	Ошибка.Вставить("ПолеОшибки",               ПолеОшибки);
	Ошибка.Вставить("ТекстДляОднойОшибки",      ТекстДляОднойОшибки);
	Ошибка.Вставить("ГруппаОшибок",             ГруппаОшибок);
	Ошибка.Вставить("НомерСтроки",              НомерСтроки);
	Ошибка.Вставить("ТекстДляНесколькихОшибок", ТекстДляНесколькихОшибок);
	Ошибка.Вставить("ИндексСтроки",             ИндексСтроки);
	
	Ошибки.СписокОшибок.Добавить(Ошибка);
	
КонецПроцедуры

// Выводит накопленные методом ДобавитьОшибкуПользователю ошибки, при этом использует нужные шаблоны текстов ошибок
// в зависимости от количества однотипных ошибок.
//
// Параметры:
//  Ошибки  - Неопределено, Структура - коллекция ошибок.
//  Отказ   - Булево - устанавливается Истина, если ошибки сообщались.
//
Процедура СообщитьОшибкиПользователю(Ошибки, Отказ = Ложь) Экспорт
	
	Если Ошибки = Неопределено Тогда
		Возврат;
	Иначе
		Отказ = Истина;
	КонецЕсли;
	
	Для каждого Ошибка Из Ошибки.СписокОшибок Цикл
		
		Если Ошибка.ИндексСтроки = Неопределено Тогда
			ИндексСтроки = Ошибка.НомерСтроки;
		Иначе
			ИндексСтроки = Ошибка.ИндексСтроки;
		КонецЕсли;
		
		Если Ошибки.ГруппыОшибок[Ошибка.ГруппаОшибок] <> Истина Тогда
			
			СообщитьПользователю(
				Ошибка.ТекстДляОднойОшибки,
				,
				СтрЗаменить(Ошибка.ПолеОшибки, "%1", Формат(ИндексСтроки, "ЧН=0; ЧГ=")));
		Иначе
			СообщитьПользователю(
				СтрЗаменить(Ошибка.ТекстДляНесколькихОшибок, "%1", Формат(Ошибка.НомерСтроки + 1, "ЧН=0; ЧГ=")),
				,
				СтрЗаменить(Ошибка.ПолеОшибки, "%1", Формат(ИндексСтроки, "ЧН=0; ЧГ=")));
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Формирует текст ошибок заполнения полей и списков.
//
// Параметры:
//  ВидПоля       - Строка - может принимать значения:
//                  Поле, Колонка, Список;
//  ВидСообщения  - Строка - может принимать значения:
//                  Заполнение, Корректность;
//  ИмяПоля        - Строка - имя поля;
//  НомерСтроки    - Строка, Число - номер строки;
//  ИмяСписка      - Строка - имя списка;
//  ТекстСообщения - Строка - детальная расшифровка ошибки заполнения.
//
// Возвращаемое значение:
//   Строка - текст ошибки заполнения.
//
Функция ТекстОшибкиЗаполнения(ВидПоля = "Поле", ВидСообщения = "Заполнение",
	ИмяПоля = "", НомерСтроки = "", ИмяСписка = "", ТекстСообщения = "") Экспорт

	Если ВРег(ВидПоля) = "ПОЛЕ" Тогда
		Если ВРег(ВидСообщения) = "ЗАПОЛНЕНИЕ" Тогда
			Шаблон = НСтр("ru = 'Поле ""%1"" не заполнено'");
		ИначеЕсли ВРег(ВидСообщения) = "КОРРЕКТНОСТЬ" Тогда
			Шаблон = НСтр("ru = 'Поле ""%1"" заполнено некорректно.
								|%4'");
		КонецЕсли;
	ИначеЕсли ВРег(ВидПоля) = "КОЛОНКА" Тогда
		Если ВРег(ВидСообщения) = "ЗАПОЛНЕНИЕ" Тогда
			Шаблон = НСтр("ru = 'Не заполнена колонка ""%1"" в строке %2 списка ""%3""'");
		ИначеЕсли ВРег(ВидСообщения) = "КОРРЕКТНОСТЬ" Тогда
			Шаблон = НСтр("ru = 'Некорректно заполнена колонка ""%1"" в строке %2 списка ""%3"".
								|%4'");
		КонецЕсли;
	ИначеЕсли ВРег(ВидПоля) = "СПИСОК" Тогда
		Если ВРег(ВидСообщения) = "ЗАПОЛНЕНИЕ" Тогда
			Шаблон = НСтр("ru = 'Не введено ни одной строки в список ""%3""'");
		ИначеЕсли ВРег(ВидСообщения) = "КОРРЕКТНОСТЬ" Тогда
			Шаблон = НСтр("ru = 'Некорректно заполнен список ""%3"".
								|%4'");
		КонецЕсли;
	КонецЕсли;

	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(Шаблон, ИмяПоля, НомерСтроки, ИмяСписка, ТекстСообщения);

КонецФункции

// Дополняет структуру значениями из другой структуры.
//
// Параметры:
//   Приемник - Структура - коллекция, в которую будут добавляться новые значения.
//   Источник - Структура - коллекция, из которой будут считываться пары Ключ и Значение для заполнения.
//   Заменять - Булево, Неопределено - Что делать в местах пересечения ключей источника и приемника:
//                                       Истина - Заменять значения приемника (самый быстрый способ),
//                                       Ложь   - Не заменять значения приемника (пропускать),
//                                       Неопределено - Значение по умолчанию. Бросать исключение.
//
Процедура ДополнитьСтруктуру(Приемник, Источник, Заменять = Неопределено) Экспорт
	
	Для Каждого Элемент Из Источник Цикл
		Если Заменять <> Истина И Приемник.Свойство(Элемент.Ключ) Тогда
			Если Заменять = Ложь Тогда
				Продолжить;
			Иначе
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Пересечение ключей источника и приемника: ""%1"".'"), Элемент.Ключ);
			КонецЕсли
		КонецЕсли;
		Приемник.Вставить(Элемент.Ключ, Элемент.Значение);
	КонецЦикла;
	
КонецПроцедуры

// Дополняет соответствие значениями из другой структуры.
//
// Параметры:
//   Приемник - Соответствие - коллекция, в которую будут добавляться новые значения.
//   Источник - Соответствие - коллекция, из которой будут считываться пары Ключ и Значение для заполнения.
//   Заменять - Булево, Неопределено - Что делать в местах пересечения ключей источника и приемника:
//                                       Истина - Заменять значения приемника (самый быстрый способ),
//                                       Ложь   - Не заменять значения приемника (пропускать),
//                                       Неопределено - Значение по умолчанию. Бросать исключение.
//
Процедура ДополнитьСоответствие(Приемник, Источник, Заменять = Неопределено) Экспорт
	
	Для Каждого Элемент Из Источник Цикл
		Если Заменять <> Истина И Приемник[Элемент.Ключ] <> Неопределено Тогда
			Если Заменять = Ложь Тогда
				Продолжить;
			Иначе
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Пересечение ключей источника и приемника: ""%1"".'"), Элемент.Ключ);
			КонецЕсли
		КонецЕсли;
		Приемник.Вставить(Элемент.Ключ, Элемент.Значение);
	КонецЦикла;
	
КонецПроцедуры

// Проверяет наличие реквизита или свойства у произвольного объекта без обращения к метаданным.
//
// Параметры:
//  Объект       - Произвольный - объект, у которого нужно проверить наличие реквизита или свойства;
//  ИмяРеквизита - Строка       - имя реквизита или свойства.
//
// Возвращаемое значение:
//  Булево - Истина, если есть.
//
Функция ЕстьРеквизитИлиСвойствоОбъекта(Объект, ИмяРеквизита) Экспорт
	
	КлючУникальности   = Новый УникальныйИдентификатор;
	СтруктураРеквизита = Новый Структура(ИмяРеквизита, КлючУникальности);
	ЗаполнитьЗначенияСвойств(СтруктураРеквизита, Объект);
	
	Возврат СтруктураРеквизита[ИмяРеквизита] <> КлючУникальности;
	
КонецФункции

// Получает массив значений из отмеченных элементов списка значений.
//
// Параметры:
//  Список - СписокЗначений - список значений из которого будет формироваться массив значений;
// 
// Возвращаемое значение:
//  Массив - массив значений из отмеченных элементов списка значений.
//
Функция ОтмеченныеЭлементы(Список) Экспорт
	
	// Возвращаемое значение функции.
	Массив = Новый Массив;
	
	Для Каждого Элемент Из Список Цикл
		
		Если Элемент.Пометка Тогда
			
			Массив.Добавить(Элемент.Значение);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Массив;
КонецФункции

// Получает номер версии конфигурации без номера сборки.
//
// Параметры:
//  Версия - Строка - версия конфигурации в формате РР.ПП.ЗЗ.СС,
//                    где СС - номер сборки, который будет удален.
// 
// Возвращаемое значение:
//  Строка - номер версии конфигурации без номера сборки в формате РР.ПП.ЗЗ.
//
Функция ВерсияКонфигурацииБезНомераСборки(Знач Версия) Экспорт
	
	Массив = СтрРазделить(Версия, ".");
	
	Если Массив.Количество() < 3 Тогда
		Возврат Версия;
	КонецЕсли;
	
	Результат = "[Редакция].[Подредакция].[Релиз]";
	Результат = СтрЗаменить(Результат, "[Редакция]",    Массив[0]);
	Результат = СтрЗаменить(Результат, "[Подредакция]", Массив[1]);
	Результат = СтрЗаменить(Результат, "[Релиз]",       Массив[2]);
	
	Возврат Результат;
КонецФункции

// Сравнить две строки версий.
//
// Параметры:
//  СтрокаВерсии1  - Строка - номер версии в формате РР.{П|ПП}.ЗЗ.
//  СтрокаВерсии2  - Строка - второй сравниваемый номер версии.
//
// Возвращаемое значение:
//   Число   - больше 0, если СтрокаВерсии1 > СтрокаВерсии2; 0, если версии равны.
//
Функция СравнитьВерсииБезНомераСборки(Знач СтрокаВерсии1, Знач СтрокаВерсии2) Экспорт
	
	Строка1 = ?(ПустаяСтрока(СтрокаВерсии1), "0.0.0", СтрокаВерсии1);
	Строка2 = ?(ПустаяСтрока(СтрокаВерсии2), "0.0.0", СтрокаВерсии2);
	Версия1 = СтрРазделить(Строка1, ".");
	Если Версия1.Количество() <> 3 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неправильный формат параметра СтрокаВерсии1: %1'"), СтрокаВерсии1);
	КонецЕсли;
	Версия2 = СтрРазделить(Строка2, ".");
	Если Версия2.Количество() <> 3 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
	    	НСтр("ru = 'Неправильный формат параметра СтрокаВерсии2: %1'"), СтрокаВерсии2);
	КонецЕсли;
	
	Результат = 0;
	Для Разряд = 0 По 2 Цикл
		Результат = Число(Версия1[Разряд]) - Число(Версия2[Разряд]);
		Если Результат <> 0 Тогда
			Возврат Результат;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;
	
КонецФункции

// Получает строку, содержащую ключи структуры, разделенные символом разделителя.
//
// Параметры:
//	Структура - Структура - Структура, ключи которой преобразуются в строку.
//	Разделитель - Строка - Разделитель, который вставляется в строку между ключами структуры.
//
// Возвращаемое значение:
//	Строка - Строка, содержащая ключи структуры разделенные разделителем.
//
Функция КлючиСтруктурыВСтроку(Структура, Разделитель = ",") Экспорт
	
	Результат = "";
	
	Для Каждого Элемент Из Структура Цикл
		СимволРазделителя = ?(ПустаяСтрока(Результат), "", Разделитель);
		Результат = Результат + СимволРазделителя + Элемент.Ключ;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Возвращает пустой уникальный идентификатор.
//
// Возвращаемое значение:
//  УникальныйИдентификатор - 00000000-0000-0000-0000-000000000000
//
Функция ПустойУникальныйИдентификатор() Экспорт
	
	Возврат Новый УникальныйИдентификатор("00000000-0000-0000-0000-000000000000");
	
КонецФункции

// Возвращает имя COM-класса для работы с 1С:Предприятием 8 через COM-соединение.
//
// Возвращаемое значение:
//  Строка - имя COM-класса для работы с 1С:Предприятием 8 через COM-соединение.
//
Функция ИмяCOMСоединителя() Экспорт
	СистемнаяИнфо = Новый СистемнаяИнформация;
	ПодстрокиВерсии = СтрРазделить(СистемнаяИнфо.ВерсияПриложения, ".");
	Возврат "v" + ПодстрокиВерсии[0] + ПодстрокиВерсии[1] + ".COMConnector";
КонецФункции

// Устанавливает внешнее соединение с информационной базой по переданным параметрам подключения и возвращает указатель
// на это соединение.
// 
// Параметры:
//  Параметры - Структура - параметры для установки внешнего соединения с информационной базой.
//                          Свойства см. в функции
//                          ОбщегоНазначенияКлиентСервер.СтруктураПараметровДляУстановкиВнешнегоСоединения):
//
//    * ВариантРаботыИнформационнойБазы             - Число - Вариант работы информационной базы: 0 - файловый; 1 -
//                                                            клиент-серверный;
//    * КаталогИнформационнойБазы                   - Строка - Каталог информационной базы для файлового режима работы;
//    * ИмяСервера1СПредприятия                     - Строка - Имя сервера1С:Предприятия;
//    * ИмяИнформационнойБазыНаСервере1СПредприятия - Строка - Имя информационной базы на сервере1С:Предприятия;
//    * АутентификацияОперационнойСистемы           - Булево - Признак аутентификации операционной системы при создании
//                                                             внешнего подключения к информационной базе;
//    * ИмяПользователя                             - Строка - Имя пользователя информационной базы;
//    * ПарольПользователя                          - Строка - Пароль пользователя информационной базы.
// 
//  СтрокаСообщенияОбОшибке - Строка - если в процессе установки внешнего соединения возникает ошибка,
//                                     то подробное описание ошибки помещается в этот параметр.
//  ОшибкаПодключенияКомпоненты - Булево - (возвращаемый параметр) устанавливается Истина, если была ошибка при
//                                         подключении.
//
// Возвращаемое значение:
//  COMОбъект, Неопределенно - в случае успешной установки внешнего соединения возвращается указатель на COM-объект
//  соединения; в случае ошибки возвращается Неопределенно.
//
Функция УстановитьВнешнееСоединение(Параметры, СтрокаСообщенияОбОшибке = "", ОшибкаПодключенияКомпоненты = Ложь) Экспорт
	Результат = УстановитьВнешнееСоединениеСБазой(Параметры);
	ОшибкаПодключенияКомпоненты = Результат.ОшибкаПодключенияКомпоненты;
	СтрокаСообщенияОбОшибке     = Результат.ПодробноеОписаниеОшибки;
	
	Возврат Результат.Соединение;
КонецФункции

// Устанавливает внешнее соединение с информационной базой по переданным параметрам подключения и возвращает указатель
// на это соединение.
// 
// Параметры:
//  Параметры - Структура - параметры для установки внешнего соединения с информационной базой.
//                          Свойства см. в функции
//                          ОбщегоНазначенияКлиентСервер.СтруктураПараметровДляУстановкиВнешнегоСоединения):
//
//   * ВариантРаботыИнформационнойБазы             - Число  - Вариант работы информационной базы: 0 - файловый; 1 -
//                                                            клиент-серверный;
//   * КаталогИнформационнойБазы                   - Строка - Каталог информационной базы для файлового режима работы;
//   * ИмяСервера1СПредприятия                     - Строка - Имя сервера1С:Предприятия;
//   * ИмяИнформационнойБазыНаСервере1СПредприятия - Строка - Имя информационной базы на сервере1С:Предприятия;
//   * АутентификацияОперационнойСистемы           - Булево - Признак аутентификации операционной системы при создании
//                                                            внешнего подключения к информационной базе;
//   * ИмяПользователя                             - Строка - Имя пользователя информационной базы;
//   * ПарольПользователя                          - Строка - Пароль пользователя информационной базы.
// 
// Возвращаемое значение:
//  Структура - информация о соединении:
//    * Соединение                  - COMОбъект, Неопределено - указатель на COM-объект соединения или Неопределено в
//                                    случае ошибки;
//    * КраткоеОписаниеОшибки       - Строка - краткое описание ошибки;
//    * ПодробноеОписаниеОшибки     - Строка - подробное описание ошибки;
//    * ОшибкаПодключенияКомпоненты - Булево - флаг ошибки подключения COM.
//
Функция УстановитьВнешнееСоединениеСБазой(Параметры) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Соединение");
	Результат.Вставить("КраткоеОписаниеОшибки", "");
	Результат.Вставить("ПодробноеОписаниеОшибки", "");
	Результат.Вставить("ОшибкаПодключенияКомпоненты", Ложь);
	
	#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
		ПодключениеНедоступно = ОбщегоНазначения.ЭтоLinuxСервер();
		КраткоеОписаниеОшибки = НСтр("ru = 'Прямое подключение к информационной базе недоступно на сервере под управлением ОС Linux.'");
	#Иначе
		ПодключениеНедоступно = ЭтоLinuxКлиент() Или ЭтоOSXКлиент();
		КраткоеОписаниеОшибки = НСтр("ru = 'Прямое подключение к информационной базе доступно только на клиенте под управлением ОС Windows.'");
	#КонецЕсли
	
	Если ПодключениеНедоступно Тогда
		Результат.Соединение = Неопределено;
		Результат.КраткоеОписаниеОшибки = КраткоеОписаниеОшибки;
		Результат.ПодробноеОписаниеОшибки = КраткоеОписаниеОшибки;
		Возврат Результат;
	КонецЕсли;
	
	Попытка
	#Если Не МобильныйКлиент Тогда
   		COMConnector = Новый COMObject(ИмяCOMСоединителя()); // "V83.COMConnector"
	#Иначе
		ВызватьИсключение НСтр("ru='Используется мобильный клиент!'");
	#КонецЕсли 
	Исключение
		Информация = ИнформацияОбОшибке();
		СтрокаСообщенияОбОшибке = НСтр("ru = 'Не удалось подключится к другой программе: %1'");
		
		Результат.ОшибкаПодключенияКомпоненты = Истина;
		Результат.ПодробноеОписаниеОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, ПодробноеПредставлениеОшибки(Информация));
		Результат.КраткоеОписаниеОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, КраткоеПредставлениеОшибки(Информация));
		
		Возврат Результат;
	КонецПопытки;
	
	ФайловыйВариантРаботы = Параметры.ВариантРаботыИнформационнойБазы = 0;
	
	// Проверка корректности указания параметров.
	ОшибкаПроверкиЗаполнения = Ложь;
	Если ФайловыйВариантРаботы Тогда
		
		Если ПустаяСтрока(Параметры.КаталогИнформационнойБазы) Тогда
			СтрокаСообщенияОбОшибке = НСтр("ru = 'Не задано месторасположение каталога информационной базы.'");
			ОшибкаПроверкиЗаполнения = Истина;
		КонецЕсли;
		
	Иначе
		
		Если ПустаяСтрока(Параметры.ИмяСервера1СПредприятия) Или ПустаяСтрока(Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия) Тогда
			СтрокаСообщенияОбОшибке = НСтр("ru = 'Не заданы обязательные параметры подключения: ""Имя сервера""; ""Имя информационной базы на сервере"".'");
			ОшибкаПроверкиЗаполнения = Истина;
		КонецЕсли;
		
	КонецЕсли;
	
	Если ОшибкаПроверкиЗаполнения Тогда
		
		Результат.ПодробноеОписаниеОшибки = СтрокаСообщенияОбОшибке;
		Результат.КраткоеОписаниеОшибки   = СтрокаСообщенияОбОшибке;
		Возврат Результат;
		
	КонецЕсли;
	
	// Формирование строки соединения.
	ШаблонСтрокиСоединения = "[СтрокаБазы][СтрокаАутентификации]";
	
	Если ФайловыйВариантРаботы Тогда
		СтрокаБазы = "File = ""&КаталогИнформационнойБазы""";
		СтрокаБазы = СтрЗаменить(СтрокаБазы, "&КаталогИнформационнойБазы", Параметры.КаталогИнформационнойБазы);
	Иначе
		СтрокаБазы = "Srvr = ""&ИмяСервера1СПредприятия""; Ref = ""&ИмяИнформационнойБазыНаСервере1СПредприятия""";
		СтрокаБазы = СтрЗаменить(СтрокаБазы, "&ИмяСервера1СПредприятия",                     Параметры.ИмяСервера1СПредприятия);
		СтрокаБазы = СтрЗаменить(СтрокаБазы, "&ИмяИнформационнойБазыНаСервере1СПредприятия", Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия);
	КонецЕсли;
	
	Если Параметры.АутентификацияОперационнойСистемы Тогда
		СтрокаАутентификации = "";
	Иначе
		
		Если СтрНайти(Параметры.ИмяПользователя, """") Тогда
			Параметры.ИмяПользователя = СтрЗаменить(Параметры.ИмяПользователя, """", """""");
		КонецЕсли;
		
		Если СтрНайти(Параметры.ПарольПользователя, """") Тогда
			Параметры.ПарольПользователя = СтрЗаменить(Параметры.ПарольПользователя, """", """""");
		КонецЕсли;
		
		СтрокаАутентификации = "; Usr = ""&ИмяПользователя""; Pwd = ""&ПарольПользователя""";
		СтрокаАутентификации = СтрЗаменить(СтрокаАутентификации, "&ИмяПользователя",    Параметры.ИмяПользователя);
		СтрокаАутентификации = СтрЗаменить(СтрокаАутентификации, "&ПарольПользователя", Параметры.ПарольПользователя);
	КонецЕсли;
	
	СтрокаСоединения = СтрЗаменить(ШаблонСтрокиСоединения, "[СтрокаБазы]", СтрокаБазы);
	СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "[СтрокаАутентификации]", СтрокаАутентификации);
	
	Попытка
	#Если Не МобильныйКлиент Тогда
	 	Результат.Соединение = COMConnector.Connect(СтрокаСоединения); 
	#Иначе
		ВызватьИсключение НСтр("ru='Невозможно на мобильном клиенте!'");
	#КонецЕсли 	
	Исключение
		Информация = ИнформацияОбОшибке();
		СтрокаСообщенияОбОшибке = НСтр("ru = 'Не удалось подключиться к другой программе: %1'");
		
		Результат.ОшибкаПодключенияКомпоненты = Истина;
		Результат.ПодробноеОписаниеОшибки     = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, ПодробноеПредставлениеОшибки(Информация));
		Результат.КраткоеОписаниеОшибки       = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, КраткоеПредставлениеОшибки(Информация));
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Получает картинку для вывода на странице с комментарием в зависимости
// от наличия текста в комментарии.
//
// Параметры:
//  Комментарий  - Строка - текст комментария.
//
// Возвращаемое значение:
//  Картинка - Картинка, которая должна отображаться на странице с комментарием.
//
Функция КартинкаКомментария(Комментарий) Экспорт

	Если НЕ ПустаяСтрока(Комментарий) Тогда
		Картинка = БиблиотекаКартинок.Комментарий;
	Иначе
		Картинка = Новый Картинка;
	КонецЕсли;
	
	Возврат Картинка;
	
КонецФункции

// Преобразует локальную дату к формату "YYYY-MM-DDThh:mm:ssTZD" согласно ISO 8601.
//
// Параметры:
//  ЛокальнаяДата - Дата - дата в часовом поясе сеанса.
// 
// Возвращаемое значение:
//   Строка - представление даты.
//
Функция ПредставлениеЛокальнойДатыСоСмещением(ЛокальнаяДата) Экспорт
	#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
		Смещение = СмещениеСтандартногоВремени(ЧасовойПоясСеанса());
	#Иначе
		Смещение = СтандартныеПодсистемыКлиент.ПараметрыРаботыКлиента().СмещениеСтандартногоВремени;
	#КонецЕсли
	ПредставлениеСмещения = "Z";
	Если Смещение > 0 Тогда
		ПредставлениеСмещения = "+";
	ИначеЕсли Смещение < 0 Тогда
		ПредставлениеСмещения = "-";
		Смещение = -Смещение;
	КонецЕсли;
	Если Смещение <> 0 Тогда
		ПредставлениеСмещения = ПредставлениеСмещения + Формат('00010101' + Смещение, "ДФ=HH:mm");
	КонецЕсли;
	
	Возврат Формат(ЛокальнаяДата, "ДФ=yyyy-MM-ddTHH:mm:ss; ДП=0001-01-01T00:00:00") + ПредставлениеСмещения;
КонецФункции

// Разбирает строку URI на составные части и возвращает в виде структуры.
// На основе RFC 3986.
//
// Параметры:
//     СтрокаURI - Строка - ссылка на ресурс в формате:
//                          <схема>://<логин>:<пароль>@<хост>:<порт>/<путь>?<параметры>#<якорь>.
//
// Возвращаемое значение:
//     Структура - составные части URI согласно формату:
//         * Схема         - Строка.
//         * Логин         - Строка.
//         * Пароль        - Строка.
//         * ИмяСервера    - Строка - часть <хост>:<порт> входного параметра.
//         * Хост          - Строка.
//         * Порт          - Строка.
//         * ПутьНаСервере - Строка - часть <путь>?<параметры>#<якорь> входного параметра.
//
Функция СтруктураURI(Знач СтрокаURI) Экспорт
	
	СтрокаURI = СокрЛП(СтрокаURI);
	
	// Схема
	Схема = "";
	Позиция = Найти(СтрокаURI, "://");
	Если Позиция > 0 Тогда
		Схема = НРег(Лев(СтрокаURI, Позиция - 1));
		СтрокаURI = Сред(СтрокаURI, Позиция + 3);
	КонецЕсли;

	// Строка соединения и путь на сервере.
	СтрокаСоединения = СтрокаURI;
	ПутьНаСервере = "";
	Позиция = Найти(СтрокаСоединения, "/");
	Если Позиция > 0 Тогда
		ПутьНаСервере = Сред(СтрокаСоединения, Позиция + 1);
		СтрокаСоединения = Лев(СтрокаСоединения, Позиция - 1);
	КонецЕсли;
		
	// Информация пользователя и имя сервера.
	СтрокаАвторизации = "";
	ИмяСервера = СтрокаСоединения;
	Позиция = Найти(СтрокаСоединения, "@");
	Если Позиция > 0 Тогда
		СтрокаАвторизации = Лев(СтрокаСоединения, Позиция - 1);
		ИмяСервера = Сред(СтрокаСоединения, Позиция + 1);
	КонецЕсли;
	
	// Логин и пароль
	Логин = СтрокаАвторизации;
	Пароль = "";
	Позиция = Найти(СтрокаАвторизации, ":");
	Если Позиция > 0 Тогда
		Логин = Лев(СтрокаАвторизации, Позиция - 1);
		Пароль = Сред(СтрокаАвторизации, Позиция + 1);
	КонецЕсли;
	
	// Хост и порт
	Хост = ИмяСервера;
	Порт = "";
	Позиция = Найти(ИмяСервера, ":");
	Если Позиция > 0 Тогда
		Хост = Лев(ИмяСервера, Позиция - 1);
		Порт = Сред(ИмяСервера, Позиция + 1);
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("Схема", Схема);
	Результат.Вставить("Логин", Логин);
	Результат.Вставить("Пароль", Пароль);
	Результат.Вставить("ИмяСервера", ИмяСервера);
	Результат.Вставить("Хост", Хост);
	Результат.Вставить("Порт", ?(ПустаяСтрока(Порт), Неопределено, Число(Порт)));
	Результат.Вставить("ПутьНаСервере", ПутьНаСервере);
	
	Возврат Результат;
	
КонецФункции

// Функция раскладывает Строку в массив строк, используя "./\" как разделитель.
//
// Параметры:
//  Строка - Строка - исходная строка.
//
// Возвращаемое значение:
//  Массив - коллекция фрагментов строки.
//
Функция РазложитьСтрокуПоТочкамИСлэшам(Знач Строка) Экспорт
	
	Перем ТекущаяПозиция;
	
	Фрагменты = Новый Массив;
	
	НачальнаяПозиция = 1;
	
	Для ТекущаяПозиция = 1 По СтрДлина(Строка) Цикл
		ТекущийСимвол = Сред(Строка, ТекущаяПозиция, 1);
		Если ТекущийСимвол = "." Или ТекущийСимвол = "/" Или ТекущийСимвол = "\" Тогда
			ТекущийФрагмент = Сред(Строка, НачальнаяПозиция, ТекущаяПозиция - НачальнаяПозиция);
			НачальнаяПозиция = ТекущаяПозиция + 1;
			Фрагменты.Добавить(ТекущийФрагмент);
		КонецЕсли;
	КонецЦикла;
	
	Если НачальнаяПозиция <> ТекущаяПозиция Тогда
		ТекущийФрагмент = Сред(Строка, НачальнаяПозиция, ТекущаяПозиция - НачальнаяПозиция);
		Фрагменты.Добавить(ТекущийФрагмент);
	КонецЕсли;
	
	Возврат Фрагменты;
	
КонецФункции

// Выделяет из имени файла его расширение (набор символов после последней точки).
//
// Параметры:
//  ИмяФайла - Строка - имя файла с именем каталога или без.
//
// Возвращаемое значение:
//   Строка - расширение файла.
//
Функция ПолучитьРасширениеИмениФайла(Знач ИмяФайла) Экспорт
	
	Расширение = "";
	
	ПозицияСимвола = СтрДлина(ИмяФайла);
	Пока ПозицияСимвола >= 1 Цикл
		
		Если Сред(ИмяФайла, ПозицияСимвола, 1) = "." Тогда
			
			Расширение = Сред(ИмяФайла, ПозицияСимвола + 1);
			Прервать;
		КонецЕсли;
		
		ПозицияСимвола = ПозицияСимвола - 1;
	КонецЦикла;

	Возврат Расширение;
	
КонецФункции

// Возвращает имя файла с расширением.
// Если расширение пустое, тогда точка не добавляется.
//
// Параметры:
//  ИмяБезРасширения - Строка - имя файла без расширения.
//  Расширение       - Строка - расширение.
//
// Возвращаемое значение:
//  Строка - имя файла с расширением.
//
Функция ПолучитьИмяСРасширением(ИмяБезРасширения, Расширение) Экспорт
	
	ИмяСРасширением = ИмяБезРасширения;
	
	Если Расширение <> "" Тогда
		ИмяСРасширением = ИмяСРасширением + "." + Расширение;
	КонецЕсли;
	
	Возврат ИмяСРасширением;
	
КонецФункции

// Удалить элемент группы отбора динамического списка.
//
// Параметры:
//  ДинамическийСписок - ДинамическийСписок - реквизит формы, для которого требуется установить отбор.
//  ИмяПоля         - Строка - имя поля компоновки (не используется для групп).
//  Представление   - Строка - представление поля компоновки.
//
Процедура УдалитьЭлементыГруппыОтбораДинамическогоСписка(ДинамическийСписок, ИмяПоля = Неопределено, Представление = Неопределено) Экспорт
	
	УдалитьЭлементыГруппыОтбора(
		ДинамическийСписок.КомпоновщикНастроек.ФиксированныеНастройки.Отбор,
		ИмяПоля,
		Представление);
	
	УдалитьЭлементыГруппыОтбора(
		ДинамическийСписок.КомпоновщикНастроек.Настройки.Отбор,
		ИмяПоля,
		Представление);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Работа с предопределенными данными.
//

// Для файлового режима работы возвращает полное имя каталога, в котором расположена информационная база.
// Если режим работы клиент-серверный, то возвращается пустая строка.
//
// Возвращаемое значение:
//  Строка - Полное имя каталога, в котором расположена файловая информационная база.
//
Функция КаталогФайловойИнформационнойБазы() Экспорт
	
	ПараметрыСоединения = СтроковыеФункцииКлиентСервер.ПараметрыИзСтроки(СтрокаСоединенияИнформационнойБазы());
	
	Если ПараметрыСоединения.Свойство("File") Тогда
		Возврат ПараметрыСоединения.File;
	КонецЕсли;
	
	Возврат "";
КонецФункции

// Возвращает Истина, если клиентское приложение является мобильным клиентом.
//
// Возвращаемое значение:
//  Булево - если нет клиентского приложения, возвращается Ложь.
//
Функция ЭтоМобильныйКлиент() Экспорт
	
#Если МобильныйКлиент Тогда
	Возврат Истина;
#ИначеЕсли Сервер Или ТолстыйКлиентОбычноеПриложение Тогда

	ЭтоМобильныйКлиент = Ложь;
	
	Если ЭтоМобильныйКлиент = Неопределено Тогда
		Возврат Ложь; // Нет клиентского приложения.
	КонецЕсли;
	
	Возврат ЭтоМобильныйКлиент;
#Иначе
	Возврат Ложь;
#КонецЕсли
	
КонецФункции

Функция ЗначениеОжидаемогоТипа(Значение, ОжидаемыеТипы)
	ТипЗначения = ТипЗнч(Значение);
	Если ТипЗнч(ОжидаемыеТипы) = Тип("ОписаниеТипов") Тогда
		Возврат ОжидаемыеТипы.Типы().Найти(ТипЗначения) <> Неопределено;
	ИначеЕсли ТипЗнч(ОжидаемыеТипы) = Тип("Тип") Тогда
		Возврат ТипЗначения = ОжидаемыеТипы;
	ИначеЕсли ТипЗнч(ОжидаемыеТипы) = Тип("Массив") Тогда
		Возврат ОжидаемыеТипы.Найти(ТипЗначения) <> Неопределено;
	ИначеЕсли ТипЗнч(ОжидаемыеТипы) = Тип("ФиксированноеСоответствие") Тогда 
		Возврат ОжидаемыеТипы.Получить(ТипЗначения) <> Неопределено;
	КонецЕсли;
	Возврат Неопределено;
КонецФункции

Функция ПредставлениеТипов(ОжидаемыеТипы)
	Если ТипЗнч(ОжидаемыеТипы) = Тип("Массив") Тогда
		Результат = "";
		Для Каждого Тип Из ОжидаемыеТипы Цикл
			Если Не ПустаяСтрока(Результат) Тогда
				Результат = Результат + ", ";
			КонецЕсли;
			Результат = Результат + ?(Тип = Неопределено, "Неопределено", Строка(Тип));
		КонецЦикла;
		Возврат Результат;
	Иначе
		Возврат Строка(ОжидаемыеТипы);
	КонецЕсли;
КонецФункции

Функция СодержитНебезопасныеДействия(Знач СтрокаКоманды)
	
	СтрокаКоманды = СтрЗаменить(СтрокаКоманды, "$DISPLAY", "");
	СтрокаКоманды = СтрЗаменить(СтрокаКоманды, "$XAUTHORITY", "");
	
	Возврат СтрНайти(СтрокаКоманды, "$") <> 0
		Или СтрНайти(СтрокаКоманды, "`") <> 0
		Или СтрНайти(СтрокаКоманды, "|") <> 0
		Или СтрНайти(СтрокаКоманды, ";") <> 0
		Или СтрНайти(СтрокаКоманды, "&") <> 0;
	
КонецФункции
////////////////////////////////////////////////////////////////////////////////
// Клиентские и серверные процедуры общего назначения.

// Формирует и выводит сообщение, которое может быть связано с элементом 
// управления формы.
//
// Параметры:
//  ТекстСообщенияПользователю - Строка - текст сообщения.
//  КлючДанных                 - ЛюбаяСсылка - объект или ключ записи информационной базы, к которому это сообщение
//                                             относится.
//  Поле                       - Строка - наименование реквизита формы.
//  ПутьКДанным                - Строка - путь к данным (путь к реквизиту формы).
//  Отказ                      - Булево - выходной параметр, всегда устанавливается в значение Истина.
//
// Пример:
//
//  1. Для вывода сообщения у поля управляемой формы, связанного с реквизитом объекта:
//  ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "ПолеВРеквизитеФормыОбъект",
//   "Объект");
//
//  Альтернативный вариант использования в форме объекта:
//  ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "Объект.ПолеВРеквизитеФормыОбъект");
//
//  2. Для вывода сообщения рядом с полем управляемой формы, связанным с реквизитом формы:
//  ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "ИмяРеквизитаФормы");
//
//  3. Для вывода сообщения связанного с объектом информационной базы:
//  ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ОбъектИнформационнойБазы, "Ответственный",,Отказ);
//
//  4. Для вывода сообщения по ссылке на объект информационной базы:
//  ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), Ссылка, , , Отказ);
//
//  Случаи некорректного использования:
//   1. Передача одновременно параметров КлючДанных и ПутьКДанным.
//   2. Передача в параметре КлючДанных значения типа отличного от допустимых.
//   3. Установка ссылки без установки поля (и/или пути к данным).
//
Процедура СообщитьПользователю(
		Знач ТекстСообщенияПользователю,
		Знач КлючДанных = Неопределено,
		Знач Поле = "",
		Знач ПутьКДанным = "",
		Отказ = Ложь) Экспорт
	
	Сообщение = Новый СообщениеПользователю;
	Сообщение.Текст = ТекстСообщенияПользователю;
	Сообщение.Поле = Поле;
	
	ЭтоОбъект = Ложь;
	
#Если НЕ ТонкийКлиент И НЕ ВебКлиент Тогда
	Если КлючДанных <> Неопределено
	   И XMLТипЗнч(КлючДанных) <> Неопределено Тогда
		ТипЗначенияСтрокой = XMLТипЗнч(КлючДанных).ИмяТипа;
		ЭтоОбъект = СтрНайти(ТипЗначенияСтрокой, "Object.") > 0;
	КонецЕсли;
#КонецЕсли
	
	Если ЭтоОбъект Тогда
		Сообщение.УстановитьДанные(КлючДанных);
	Иначе
		Сообщение.КлючДанных = КлючДанных;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ПутьКДанным) Тогда
		Сообщение.ПутьКДанным = ПутьКДанным;
	КонецЕсли;
		
	Сообщение.Сообщить();
	
	Отказ = Истина;
	
КонецПроцедуры

// Получает массив значений из отмеченных элементов списка значений.
//
// Параметры:
//  Список - СписокЗначений - список значений из которого будет формироваться массив значений.
// 
// Возвращаемое значение:
//  Массив - массив значений из отмеченных элементов списка значений.
//
Функция ПолучитьМассивОтмеченныхЭлементовСписка(Список) Экспорт
	
	// Возвращаемое значение функции.
	Массив = Новый Массив;
	
	Для Каждого Элемент Из Список Цикл
		
		Если Элемент.Пометка Тогда
			
			Массив.Добавить(Элемент.Значение);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Массив;
КонецФункции

// Извлекает из строки соединения с информационной базой параметры подключения
// и передает параметры в структуру для установки внешнего соединения.
//
// Параметры:
//  СтрокаСоединения - Строка
//
// Возвращаемое значение:
//  Структура.
//
Функция ПолучитьПараметрыПодключенияИзСтрокиСоединенияИнформационнойБазы(Знач СтрокаСоединения) Экспорт
	
	Результат = СтруктураПараметровДляУстановкиВнешнегоСоединения();
	
	Параметры = СтроковыеФункцииКлиентСервер.ПолучитьПараметрыИзСтроки(СтрокаСоединения);
	
	Параметры.Свойство("File", Результат.КаталогИнформационнойБазы);
	Параметры.Свойство("Srvr", Результат.ИмяСервера1СПредприятия);
	Параметры.Свойство("Ref",  Результат.ИмяИнформационнойБазыНаСервере1СПредприятия);
	
	Результат.ВариантРаботыИнформационнойБазы = ?(Параметры.Свойство("File"), 0, 1);
	
	Возврат Результат;
КонецФункции

// Удаляет заданный литерал (префикс) в именах ключей переданной структуры.
// 	Создает новую структуру
//
// Параметры:
// 	Структура - Структура - Структура элементов, 
//				на основании которой необходимо создать новую структуру с ключами без заданного литерала
// 	Литерал - Строка - Строка символов, 
//				которую необходимо исключить из имени ключей переданной структуры
//
// Возвращаемое значение:
//  Структура -  Возвращаемая структура получается на основании копирования исходной структуры.
//
Функция УдалитьПрефиксВКлючахКоллекции(Структура, Литерал) Экспорт
	
	Результат = Новый Структура;
	
	Для Каждого Элемент Из Структура Цикл
		
		Результат.Вставить(СтрЗаменить(Элемент.Ключ, Литерал, ""), Элемент.Значение);
		
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Функция "расщепляет" строку на подстроки, используя заданный 
// 		разделитель. Разделитель может иметь любую длину. 
// 		Если в качестве разделителя задан пробел, рядом стоящие пробелы 
// 		считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
// 		игнорируются.
// 		Например, 
// 		РазложитьСтрокуВМассивПодстрок(",ку,,,му", ",") возвратит массив значений из пяти элементов, 
// 		три из которых - пустые строки, а 
// 		РазложитьСтрокуВМассивПодстрок(" ку   му", " ") возвратит массив значений из двух элементов.
//
// Параметры: 
// 	Стр - Строка - которую необходимо разложить на подстроки 
// 					Параметр передается по значению
//	Разделитель - Строка - разделитель, по умолчанию - запятая
//
//
// Возвращаемое значение:
//	Массив из Неопределено - значений, элементы которого - подстроки.
//
Функция РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",") Экспорт
	
	МассивСтрок = Новый Массив();
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
		Пока 1=1 Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = СокрЛ(Сред(Стр,Поз));
		КонецЦикла;
	Иначе
		ДлинаРазделителя = СтрДлина(Разделитель);
		Пока 1=1 Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = Сред(Стр,Поз+ДлинаРазделителя);
		КонецЦикла;
	КонецЕсли;
	
КонецФункции // 

// Функция ЭтоЦифра.
//
// Параметры:
//  Символ - Строка - проверяемый символ.
//  ШаблонЦифры - Строка - допустимые символы.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоЦифра(Символ, ШаблонЦифры = Неопределено) Экспорт
	
	Если ШаблонЦифры  = Неопределено Тогда
		ШаблонЦифры = "01234567890";
	КонецЕсли;
	Возврат Найти(ШаблонЦифры, Символ) > 0;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции для поддержки формирования печатных форм.
//

// Возвращает заголовок документа в том виде, в котором его формирует платформа для представления ссылки на документ.
//
// Параметры:
//  Шапка				 - Структура - Структура с ключами: Номер (номер документа), Дата  (дата документа).
//  НазваниеДокумента	 - Строка	 - название документа (например, синоним объекта метаданных).
// 
// Возвращаемое значение:
//  Строка - заголовок документа.
//
Функция СформироватьЗаголовокДокумента(Шапка, знач НазваниеДокумента = "") Экспорт
	
	// Если название документа не передано, получим название по представлению документа.
	Если НазваниеДокумента = ""	И Шапка.Свойство("Представление") И ЗначениеЗаполнено(Шапка.Представление) Тогда
		ПоложениеНомера = Найти(Шапка.Представление, Шапка.Номер);
		Если ПоложениеНомера > 0 Тогда
			НазваниеДокумента = СокрЛП(Лев(Шапка.Представление, ПоложениеНомера - 1));
		КонецЕсли;
	КонецЕсли;

	НомерНаПечать = ПрефиксацияОбъектовКлиентСервер.НомерНаПечать(Шапка.Номер);
	
	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = '%1 № %2 от %3'"),
		НазваниеДокумента, НомерНаПечать, Формат(Шапка.Дата, "ДФ='дд ММММ гггг'"));
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с файловой системой.
//

// Процедура УдалитьКаталогСФайлами удаляет все файлы в заданном каталоге.
//
// Параметры:
//  Путь         - Строка, полный путь каталога, в котором требуется
//                 удалить все файлы.
//
Процедура УдалитьКаталогСФайлами(Путь) Экспорт
	
	Каталог = Новый Файл(Путь);
	
	Если Каталог.Существует() Тогда
		УдалитьФайлы(Путь);
	КонецЕсли;
	
КонецПроцедуры // УдалитьКаталогСФайлами()

// Раскладывает полное имя файла на составляющие.
//
// Параметры:
//  ПолноеИмяФайла - Строка - полный путь к файлу
//  ЭтоПапка - Булево - признак того, что требуется разложить полное имя папки, а не файла
//
// Возвращаемое значение:
//	Структура - имя файла, разложенное на составные части(аналогично свойствам объекта Файл):
//     * ПолноеИмя - Строка - содержит полный путь к файлу, т.е. полностью соответствует входному параметру ПолноеИмяФайла.
//     * Путь - Строка - содержит путь к каталогу, в котором лежит файл.
//     * Имя - Строка - содержит имя файла с расширением, без пути к файлу.
//     * Расширение - Строка - содержит расширение файла.
//     * ИмяБезРасширения - Строка - содержит имя файла без расширения и без пути к файлу.
// 
// Пример:
//  ПолноеИмяФайла = "c:\temp\test.txt";
//  ЧастиИмениФайла = РазложитьПолноеИмяФайла(ПолноеИмяФайла);
//  
//  В результате структура полей будет заполнена следующим образом:
//    ПолноеИмя: "c:\temp\test.txt",
//    Путь: "c:\temp\",
//    Имя: "test.txt",
//    Расширение: ".txt",
//    ИмяБезРасширения: "test".
//
Функция РазложитьПолноеИмяФайла(Знач ПолноеИмяФайла, ЭтоПапка = Ложь) Экспорт
	
	СтруктураИмениФайла = Новый Структура("ПолноеИмя,Путь,Имя,Расширение,ИмяБезРасширения");
	
	// Убераем из полного имени файла завершающий слеш и сохраняем получившееся полное имя в структуре.
	Если ЭтоПапка И (Прав(ПолноеИмяФайла, 1) = "/" Или Прав(ПолноеИмяФайла, 1) = "\") Тогда
		Если ЭтоПапка Тогда
			ПолноеИмяФайла = Сред(ПолноеИмяФайла, 1, СтрДлина(ПолноеИмяФайла) - 1);
		Иначе
			// Если путь к файлу заканчивается слешем, то у файла нет имени.
			СтруктураИмениФайла.Вставить("ПолноеИмя", ПолноеИмяФайла); 
			СтруктураИмениФайла.Вставить("Путь", ПолноеИмяФайла); 
			СтруктураИмениФайла.Вставить("Имя", ""); 
			СтруктураИмениФайла.Вставить("Расширение", ""); 
			СтруктураИмениФайла.Вставить("ИмяБезРасширения", ""); 
			Возврат СтруктураИмениФайла;
		КонецЕсли;
	КонецЕсли;
	СтруктураИмениФайла.Вставить("ПолноеИмя", ПолноеИмяФайла); 
	
	// Если полное имя файла оказалось пустым - то остальные параметры структуры возвращаем пустыми.
	Если СтрДлина(ПолноеИмяФайла) = 0 Тогда 
		СтруктураИмениФайла.Вставить("Путь", ""); 
		СтруктураИмениФайла.Вставить("Имя", ""); 
		СтруктураИмениФайла.Вставить("Расширение", ""); 
		СтруктураИмениФайла.Вставить("ИмяБезРасширения", ""); 
		Возврат СтруктураИмениФайла;
	КонецЕсли;
	
	// Выделяем путь к файлу и имя файла.
	Если Найти(ПолноеИмяФайла, "/") > 0 Тогда
		ПозицияРазделителя = СтроковыеФункцииКлиентСервер.НайтиСимволСКонца(ПолноеИмяФайла, "/");
	ИначеЕсли Найти(ПолноеИмяФайла, "\") > 0 Тогда
		ПозицияРазделителя = СтроковыеФункцииКлиентСервер.НайтиСимволСКонца(ПолноеИмяФайла, "\");
	Иначе
		ПозицияРазделителя = 0;
	КонецЕсли;
	СтруктураИмениФайла.Вставить("Путь", Лев(ПолноеИмяФайла, ПозицияРазделителя)); 
	СтруктураИмениФайла.Вставить("Имя", Сред(ПолноеИмяФайла, ПозицияРазделителя + 1));
	
	// Папки не имеют расширений, а для файла выделяем расширение.
	Если ЭтоПапка Тогда
		СтруктураИмениФайла.Вставить("Расширение", "");
		СтруктураИмениФайла.Вставить("ИмяБезРасширения", СтруктураИмениФайла.Имя);
	Иначе
        ПозицияТочки = СтроковыеФункцииКлиентСервер.НайтиСимволСКонца(СтруктураИмениФайла.Имя, ".");
		Если ПозицияТочки = 0 Тогда
			СтруктураИмениФайла.Вставить("Расширение", "");
			СтруктураИмениФайла.Вставить("ИмяБезРасширения", СтруктураИмениФайла.Имя);
		Иначе
			СтруктураИмениФайла.Вставить("Расширение", Сред(СтруктураИмениФайла.Имя, ПозицияТочки));
			СтруктураИмениФайла.Вставить("ИмяБезРасширения", Лев(СтруктураИмениФайла.Имя, ПозицияТочки - 1));
		КонецЕсли;
	КонецЕсли;
	
	Возврат СтруктураИмениФайла;
	
КонецФункции

// Функция ПолучитьКаталогВременныхФайлов.
//
// Возвращаемое значение:
//  Строка.
//
Функция ПолучитьКаталогВременныхФайлов() Экспорт
	
	Возврат ДобавитьКонечныйРазделительПути(КаталогВременныхФайлов());
	
КонецФункции
////////////////////////////////////////////////////////////////////////////////
// Блок функций для работы с почтовыми адресами.
//

// Функция проверяет что введенная строка с e-mail адресами введена правильно
// 	Формат строки:
// 	Z = ИмяПользователя|[Имя Пользователя] [<]пользователь@почтовый_сервер[>], Строка = Z[<разделитель*>Z]
//  ВАЖНО: Функция возвращает массив структур, в которых одно поле (любое)
//         может быть незаполнено. Может использоваться различными
//         подсистемами для собственного сопоставления имени пользователя
//         некому e-mail адресу. Поэтому, необходимо перед непосредственной
//         отправкой проверить, что поле почтового адреса заполнено
// 
//   Прим.: разделитель* - имеется в виду любой разделитель адресов
//
// Параметры:
// 	СтрокаПереданныхАдресов - Строка - правильная строка с почтовыми адресами.
//
// Возвращаемое значение:
// 	Структура:
// 		* Статус - Булево - успех или неуспех преобразования
// 		* Значение - Массив из Структура:
//      	** Адрес - Строка - e-mail получателя.
//          ** Представление - Строка - имя получателя
// 			** СообщениеОбОшибке - строка.
//
//
Функция РазобратьСтрокуСПочтовымиАдресами(знач СтрокаПереданныхАдресов) Экспорт
	
	Результат = Новый Массив;
	
	НедопустимыеСимволы = "!#$%^&*()+`~|\/=";
	
	СообщениеНедопустимыеСимволы = НСтр("ru = 'Недопустимый символ %1 в адресе электронной почты %2'");
	СообщениеНеверныйФорматПочтовогоАдреса = НСтр("ru = 'Некорректный адрес электронной почты %1'");
	
	МассивПодстрок = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрокаПереданныхАдресов,";", Истина);
	МассивПодстрокКОбработке = Новый Массив;
	
	Для каждого ЭлементМассива Из МассивПодстрок Цикл
		Если Найти(ЭлементМассива,",") > 0 Тогда
			ДопМассивПодстрок = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрокаПереданныхАдресов);
			Для каждого ЭлементДопМассива Из ДопМассивПодстрок Цикл
				МассивПодстрокКОбработке.Добавить(ЭлементДопМассива);
			КонецЦикла;
		Иначе
			МассивПодстрокКОбработке.Добавить(ЭлементМассива);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого СтрокаАдреса Из МассивПодстрокКОбработке Цикл
		
		Индекс = 1;               // Номер обрабатываемого символа.
		Накопитель = "";          // Накопитель символов, после анализа перемещается либо в полное имя.
		// Либо в почтовый адрес
		ПолноеИмяАдресата = "";   // переменная, накапливающая имя адресата
		ПочтовыйАдрес = "";       // переменная, накапливающая e-mail адрес
		// 1 - формирование полного имени: ожидаются любые допустимые символы имени адресата
		// 2 - формирование почтового адреса: ожидаются любые допустимые символы email адреса
		// 3 - завершение формирования очередного почтового адреса - ожидаются символы разделители либо пробелы.
		СтадияРазбора = 1; 
		
		Пока Индекс <= СтрДлина(СтрокаАдреса) Цикл
			
			Символ = Сред(СтрокаАдреса, Индекс, 1);
			
			Если      Символ = " " Тогда
				Индекс = ? ((ПропуститьПробелы(СтрокаАдреса, Индекс, " ") - 1) > Индекс,
				ПропуститьПробелы(СтрокаАдреса, Индекс, " ") - 1,
				Индекс);
				Если      СтадияРазбора = 1 Тогда
					ПолноеИмяАдресата = ПолноеИмяАдресата + Накопитель + " ";
				ИначеЕсли СтадияРазбора = 2 Тогда
					ПочтовыйАдрес = Накопитель;
					СтадияРазбора = 3;
				КонецЕсли;
				Накопитель = "";
			ИначеЕсли Символ = "@" Тогда
				Если      СтадияРазбора = 1 Тогда
					СтадияРазбора = 2;
					
					Для ИндексПоискаНС = 1 По СтрДлина(Накопитель) Цикл
						Если Найти(НедопустимыеСимволы, Сред(Накопитель, ИндексПоискаНС, 1)) > 0 Тогда
							ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
							                  СообщениеНедопустимыеСимволы,Сред(Накопитель, ИндексПоискаНС, 1),СтрокаАдреса);
						КонецЕсли;
					КонецЦикла;
					
					Накопитель = Накопитель + Символ;
				ИначеЕсли СтадияРазбора = 2 Тогда
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					                  СообщениеНеверныйФорматПочтовогоАдреса,СтрокаАдреса);
				ИначеЕсли СтадияРазбора = 3 Тогда
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					                  СообщениеНеверныйФорматПочтовогоАдреса,СтрокаАдреса);
				КонецЕсли;
			Иначе
				Если СтадияРазбора = 2 ИЛИ СтадияРазбора = 3 Тогда
					Если Найти(НедопустимыеСимволы, Символ) > 0 Тогда
						ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						                  СообщениеНедопустимыеСимволы,Символ,СтрокаАдреса);
					КонецЕсли;
				КонецЕсли;
				
				Накопитель = Накопитель + Символ;
			КонецЕсли;
			
			Индекс = Индекс + 1;
		КонецЦикла;
		
		Если      СтадияРазбора = 1 Тогда
			ПолноеИмяАдресата = ПолноеИмяАдресата + Накопитель;
		ИначеЕсли СтадияРазбора = 2 Тогда
			ПочтовыйАдрес = Накопитель;
		КонецЕсли;
		
		Если ПустаяСтрока(ПочтовыйАдрес) И (Не ПустаяСтрока(ПолноеИмяАдресата)) Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			                  СообщениеНеверныйФорматПочтовогоАдреса,ПолноеИмяАдресата);
		ИначеЕсли СтрЧислоВхождений(ПочтовыйАдрес,"@") <> 1 Тогда 
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			                  СообщениеНеверныйФорматПочтовогоАдреса,ПочтовыйАдрес);
		КонецЕсли;
		
		Если НЕ (ПустаяСтрока(ПолноеИмяАдресата) И ПустаяСтрока(ПочтовыйАдрес)) Тогда
			Результат.Добавить(ПроверитьИПодготовитьПочтовыйАдрес(ПолноеИмяАдресата, ПочтовыйАдрес));
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Проверяет, что почтовый адрес не содержит символов обрамления, 
// если символы обрамления вставлены правильно убирает их.
// Параметры:
//  ПолноеИмяАдресата - строка - имя получателя.
//  ПочтовыйАдрес     - строка - email адрес.
// Возвращаемое значение:
//  Структура - 
//   Ключ статус - булево - успех или неуспех операции.
//   СообщениеОбОшибке - в случае неуспеха операции содержит сообщение об ошибке.
//   Значение - структура - в случае успеха операции содержит записанную структуру почтового
//                          адреса: ключи - Адрес, Представление (строки).
//
Функция ПроверитьИПодготовитьПочтовыйАдрес(знач ПолноеИмяАдресата, знач ПочтовыйАдрес)
	
	НедопустимыйСимволВИмениАдресата = НСтр("ru = 'Недопустимый символ в имени адресата.'");
	НедопустимыйСимволВПочтовомАдресе = НСтр("ru = 'Недопустимый символ в почтовом адресе.'");
	СимволыОбрамления = "<>[]";
	
	ПочтовыйАдрес     = СокрЛП(ПочтовыйАдрес);
	ПолноеИмяАдресата = СокрЛП(ПолноеИмяАдресата);
	
	Если Лев(ПолноеИмяАдресата, 1) = "<" Тогда
		Если Прав(ПолноеИмяАдресата, 1) = ">" Тогда
			ПолноеИмяАдресата = Сред(ПолноеИмяАдресата, 2, СтрДлина(ПолноеИмяАдресата)-2);
		Иначе
			ВызватьИсключение НедопустимыйСимволВИмениАдресата;
		КонецЕсли;
	ИначеЕсли Лев(ПолноеИмяАдресата, 1) = "[" Тогда
		Если Прав(ПолноеИмяАдресата, 1) = "]" Тогда
			ПолноеИмяАдресата = Сред(ПолноеИмяАдресата, 2, СтрДлина(ПолноеИмяАдресата)-2);
		Иначе
			ВызватьИсключение НедопустимыйСимволВИмениАдресата;
		КонецЕсли;
	КонецЕсли;
	
	Если Лев(ПочтовыйАдрес, 1) = "<" Тогда
		Если Прав(ПочтовыйАдрес, 1) = ">" Тогда
			ПочтовыйАдрес = Сред(ПочтовыйАдрес, 2, СтрДлина(ПочтовыйАдрес)-2);
		Иначе
			ВызватьИсключение НедопустимыйСимволВПочтовомАдресе;
		КонецЕсли;
	ИначеЕсли Лев(ПочтовыйАдрес, 1) = "[" Тогда
		Если Прав(ПочтовыйАдрес, 1) = "]" Тогда
			ПочтовыйАдрес = Сред(ПочтовыйАдрес, 2, СтрДлина(ПочтовыйАдрес)-2);
		Иначе
			ВызватьИсключение НедопустимыйСимволВПочтовомАдресе;
		КонецЕсли;
	КонецЕсли;
	
	Для Индекс = 1 По СтрДлина(СимволыОбрамления) Цикл
		Если Найти(ПолноеИмяАдресата, Сред(СимволыОбрамления, Индекс, 1)) <> 0
		 ИЛИ Найти(ПочтовыйАдрес,     Сред(СимволыОбрамления, Индекс, 1)) <> 0 Тогда
			ВызватьИсключение НедопустимыйСимволВПочтовомАдресе;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Новый Структура("Адрес, Представление", ПочтовыйАдрес,ПолноеИмяАдресата);
	
КонецФункции

// Разбирает строку с адресами электронной почты согласно стандарту RFC 5322 с ограничениями.
//
// Ограничения:
//  1. В адресе разрешаются только буквы, цифры, символ подчеркивания, дефис и символ "@".
//  2. Символы скобок "<>[]()" допускаются, но игнорируются путём замены на пробелы.
//  3. Группы запрещены.
//
// Параметры:
//  Строка - Строка - Строка, содержащая электронные адреса (mailbox-list).
//
// Возвращаемое значение:
//  Массив - содержит массив структур адресов.
//           Поля структуры:
//             Псевдоним      - Строка - представление адресата.
//             Адрес          - Строка - найденный и соответствующий требованиям почтовый адрес;
//                                       Если текст, похожий на адрес найден, но не соответствует требованиям
//                                       стандартов, то такой текст записывается в поле "Псевдоним".
//             ОписаниеОшибки - Строка - текстовое представление ошибки, либо пустая строка, если ошибок нет.
Функция АдресаЭлектроннойПочтыИзСтроки(Знач Строка) Экспорт
	
	Результат = Новый Массив;
	
	// Заменяем скобки на пробелы
	СимволыСкобок = "<>()[]";
	Строка = ЗаменитьСимволыВСтрокеНаПробелы(Строка, СимволыСкобок);
	
	// Приводим разделители к одному виду.
	Строка = СтрЗаменить(Строка, ",", ";");
	
	// Раскладываем mailbox-list на mailbox'ы.
	МассивАдресов = РазложитьСтрокуНаМассивПодстрок(Строка);
	
	// Допустимые символы для псевдонима (display-name).
	Буквы = "abcdefghijklmnopqrstuvwxyzабвгдеёжзийклмнопрстуфхцчшщъыьэюя";
	Цифры = "0123456789";
	ДополнительныеСимволы = "._- ";
	
	// Выделяем из строки адреса (mailbox'а) псевдоним (display-name) и адрес (addr-spec).
	Для Каждого СтрокаАдреса Из МассивАдресов Цикл
		
		Псевдоним = "";
		Адрес = "";
		ОписаниеОшибки = "";
		
		Если СтрЧислоВхождений(СтрокаАдреса, "@") <> 1 Тогда
			Псевдоним = СтрокаАдреса;
		Иначе
			// Всё, что не подходит в качестве адреса, складываем в псевдоним.
			Для Каждого Подстрока Из РазложитьСтрокуНаМассивПодстрок(СтрокаАдреса, " ") Цикл
				Если ПустаяСтрока(Адрес) И АдресЭлектроннойПочтыСоответствуетТребованиям(Подстрока) Тогда
					Адрес = Подстрока;
				Иначе
					Псевдоним = Псевдоним + " " + Подстрока;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		Псевдоним = СокрЛП(Псевдоним);
		
		// Проверки
		Если ПустаяСтрока(ОписаниеОшибки) Тогда
			ЕстьНедопустимыеСимволыВПсевдониме = Не СтрокаСодержитТолькоДопустимыеСимволы(НРег(Псевдоним), Буквы + Цифры + ДополнительныеСимволы);
			АдресОпределен = Не ПустаяСтрока(Адрес);
			ЕстьПризнакНаличияАдресаВСтроке = Найти(СтрокаАдреса, "@") > 0;
			
			Если АдресОпределен Тогда 
				Если ЕстьНедопустимыеСимволыВПсевдониме Тогда
					ОписаниеОшибки = НСтр("ru = 'Представление содержит недопустимые символы'");
				КонецЕсли;
			Иначе
				Если ЕстьПризнакНаличияАдресаВСтроке Тогда 
					ОписаниеОшибки = НСтр("ru = 'Адрес электронной почты содержит ошибки'");
				Иначе
					ОписаниеОшибки = НСтр("ru = 'Строка не содержит адреса электронной почты'");
				КонецЕсли;
			КонецЕсли;	
		КонецЕсли;
		
		СтруктураАдреса = Новый Структура("Псевдоним,Адрес,ОписаниеОшибки", Псевдоним, Адрес, ОписаниеОшибки);
		Результат.Добавить(СтруктураАдреса);
	КонецЦикла;
	
	Возврат Результат;	
	
КонецФункции

Функция РазложитьСтрокуНаМассивПодстрок(Знач Строка, Разделитель = ";", ПропускатьПустыеСтроки = Истина)
	
	Результат = Новый Массив;
	
	Если ПустаяСтрока(Разделитель) Тогда 
		Результат.Добавить(Строка);
		Возврат Результат;
	КонецЕсли;
	
	Позиция = Найти(Строка, Разделитель);
	Пока Позиция > 0 Цикл
		Подстрока = Лев(Строка, Позиция - 1);
		Если Не ПустаяСтрока(Подстрока) Или не ПропускатьПустыеСтроки Тогда
			Результат.Добавить(Подстрока);
		КонецЕсли;
		Строка = Сред(Строка, Позиция + СтрДлина(Разделитель));
		Позиция = Найти(Строка, Разделитель);
	КонецЦикла;
	
	Результат.Добавить(Строка);
	
	Возврат Результат;
		
КонецФункции

// Проверяет email адрес на соответствие требованиям стандартов RFC 5321, RFC 5322,
// 	а также RFC 5335, RFC 5336 и RFC 3696
// 	Кроме того, функция ограничивает использование спецсимволов
// 
// Параметры:
//  Адрес - Строка - проверяемый email
//  РазрешитьЛокальныеАдреса - Булево - не выдавать ошибку в случае отсутствия зоны домена в адресе
//
// Возвращаемое значение:
//  Булево - Истина, если ошибок нет.
//
Функция АдресЭлектроннойПочтыСоответствуетТребованиям(Знач Адрес, РазрешитьЛокальныеАдреса = Ложь) Экспорт
	
	// Допустимые символы для email.
	Буквы = "abcdefghijklmnopqrstuvwxyzабвгдеёжзийклмнопрстуфхцчшщъыьэюя";
	Цифры = "0123456789";
	СпецСимволы = ".@_-:+";
	
	// проверяем символ @
	Если СтрЧислоВхождений(Адрес, "@") <> 1 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Разрешаем двоеточие только один раз.
	Если СтрЧислоВхождений(Адрес, ":") > 1 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// проверяем две точки подряд
	Если СтрНайти(Адрес, "..") > 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Приводим строку адреса к нижнему регистру.
	Адрес = НРег(Адрес);
	
	// Проверяем допустимые символы.
	Если Не СтрокаСодержитТолькоДопустимыеСимволы(Адрес, Буквы + Цифры + СпецСимволы) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Разбираем адрес на local-part и domain.
	Позиция = СтрНайти(Адрес,"@");
	ЛокальноеИмя = Лев(Адрес, Позиция - 1);
	Домен = Сред(Адрес, Позиция + 1);
	
	// Проверяем на заполненность и допустимость длины.
	Если ПустаяСтрока(ЛокальноеИмя)
	 	Или ПустаяСтрока(Домен)
		Или СтрДлина(ЛокальноеИмя) > 64
		Или СтрДлина(Домен) > 255 Тогда
		
		Возврат Ложь;
	КонецЕсли;
	
	// Проверяем наличие спецсимволов в начале и в конце домена.
	Если ЕстьСимволыВНачалеВКонце(Домен, СпецСимволы) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// В домене должна быть минимум одна точка.
	Если СтрНайти(Домен,".") = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// В домене не должно быть символа подчеркивания.
	Если СтрНайти(Домен,"_") > 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// В домене не должно быть символа двоеточие.
	Если СтрНайти(Домен,":") > 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// В домене не должно быть символа "плюс".
	Если СтрНайти(Домен,"+") > 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Выделяем зону (TLD) из имени домена.
	Зона = Домен;
	Позиция = СтрНайти(Зона,".");
	Пока Позиция > 0 Цикл
		Зона = Сред(Зона, Позиция + 1);
		Позиция = СтрНайти(Зона,".");
	КонецЦикла;
	
	// Проверяем зону домена (минимум 2 символа, только буквы).
	Возврат СтрДлина(Зона) >= 2 И СтрокаСодержитТолькоДопустимыеСимволы(Зона,Буквы);
	
КонецФункции

// Формирует структуру с ключами Статус (Истина) и Значение.
//
// Параметры:
//  Значение - Неопределено
//  Статус - Булево - По умолчанию Истина
//
// Возвращаемое значение:
//  Неопределено.
//
Функция ЗаполнитьРезультат(знач Значение, знач Статус = Истина) Экспорт
	
	Если Статус Тогда
		Возврат Новый Структура("Статус, Значение", Истина, Значение);
	Иначе
		Возврат Новый Структура("Статус, СообщениеОбОшибке", Ложь, Значение);
	КонецЕсли;
	
КонецФункции

// Добавить элемент компоновки в контейнер элементов компоновки.
//
// Параметры:
//  ОбластьДобавления - КоллекцияЭлементовОтбораКомпоновкиДанных - контейнер с элементами и группами отбора,
//                                                                 например, Список.Отбор или группа в отборе.
//  ИмяПоля                 - Строка - имя поля компоновки данных (заполняется всегда).
//  ПравоеЗначение          - Произвольный - сравниваемое значение.
//  ВидСравнения            - ВидСравненияКомпоновкиДанных - вид сравнения.
//  Представление           - Строка - представление элемента компоновки данных.
//  Использование           - Булево - использование элемента.
//  РежимОтображения        - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения.
//  ИдентификаторПользовательскойНастройки - Строка - см. ОтборКомпоновкиДанных.ИдентификаторПользовательскойНастройки
//                                                    в синтакс-помощнике.
// Возвращаемое значение:
//  ЭлементОтбораКомпоновкиДанных - элемент компоновки.
//
Функция ДобавитьЭлементКомпоновки(ОбластьДобавления,
									Знач ИмяПоля,
									Знач ВидСравнения,
									Знач ПравоеЗначение = Неопределено,
									Знач Представление  = Неопределено,
									Знач Использование  = Неопределено,
									знач РежимОтображения = Неопределено,
									знач ИдентификаторПользовательскойНастройки = Неопределено) Экспорт
	
	Элемент = ОбластьДобавления.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Элемент.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);
	Элемент.ВидСравнения = ВидСравнения;
	
	Если РежимОтображения = Неопределено Тогда
		Элемент.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
	Иначе
		Элемент.РежимОтображения = РежимОтображения;
	КонецЕсли;
	
	Если ПравоеЗначение <> Неопределено Тогда
		Элемент.ПравоеЗначение = ПравоеЗначение;
	КонецЕсли;
	
	Если Представление <> Неопределено Тогда
		Элемент.Представление = Представление;
	КонецЕсли;
	
	Если Использование <> Неопределено Тогда
		Элемент.Использование = Использование;
	КонецЕсли;
	
	// Важно: установка идентификатора должна выполняться
	// в конце настройки элемента, иначе он будет скопирован
	// в пользовательские настройки частично заполненным.
	Если ИдентификаторПользовательскойНастройки <> Неопределено Тогда
		Элемент.ИдентификаторПользовательскойНастройки = ИдентификаторПользовательскойНастройки;
	ИначеЕсли Элемент.РежимОтображения <> РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный Тогда
		Элемент.ИдентификаторПользовательскойНастройки = ИмяПоля;
	КонецЕсли;
	
	Возврат Элемент;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с управляемыми формами.
//

// Получает значение реквизита формы
//
// Параметры:
//	Форма - Форма
// 	ПутьРеквизита - Строка - путь к данным, например: "Объект.МесяцНачисления"
//
// Возвращаемое значение:
//  Неопределено
//
Функция ПолучитьРеквизитФормыПоПути(Форма, ПутьРеквизита) Экспорт
	
	МассивИмен = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьРеквизита, ".");
	
	Объект        = Форма;
	ПоследнееПоле = МассивИмен[МассивИмен.Количество()-1];
	
	Для Сч = 0 По МассивИмен.Количество()-2 Цикл
		Объект = Объект[МассивИмен[Сч]]
	КонецЦикла;
	
	Возврат Объект[ПоследнееПоле];
	
КонецФункции

// Добавляет в конце "\" или "/".
// Параметры:
//  НовыйПуть - Неопределено
//  ТипПлатформыТекущий - Неопределено
//
Процедура ДобавитьСлешЕслиНужно(НовыйПуть, ТипПлатформыТекущий) Экспорт
	
	Если СтрДлина(НовыйПуть) = 0 Тогда
		Возврат;
	КонецЕсли;	
	
	Если Прав(НовыйПуть, 1) <> "\" И Прав(НовыйПуть,1) <> "/" Тогда
		
		Если ТипПлатформыТекущий = ТипПлатформы.Windows_x86 ИЛИ ТипПлатформыТекущий = ТипПлатформы.Windows_x86_64 Тогда
			НовыйПуть = НовыйПуть + "\";
		Иначе	
			НовыйПуть = НовыйПуть + "/";
		КонецЕсли;			
	КонецЕсли;
	
КонецПроцедуры	

// Создает копию переданного массива, структуры или соответствия
//
// Параметры:
//  КоллекцияИсходная- Массив из Неопределено - Структура, Соответствие - исходная коллекция
// Возвращаемое значение:
//  Массив из Неопределено - Структура, Соответствие - копия исходной коллекции.
//
Функция СкопироватьУниверсальнуюКоллекцию(КоллекцияИсходная) Экспорт
	
	Если ТипЗнч(КоллекцияИсходная)=Тип("Массив") Тогда
		
		КоллекцияКопия=Новый Массив;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Добавить(Элемент);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия;
		
	ИначеЕсли ТипЗнч(КоллекцияИсходная)=Тип("Структура") Тогда
		
		КоллекцияКопия=Новый Структура;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Вставить(Элемент.Ключ,Элемент.Значение);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия; 
		
	ИначеЕсли ТипЗнч(КоллекцияИсходная)=Тип("Соответствие") Тогда
		
		КоллекцияКопия=Новый Соответствие;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Вставить(Элемент.Ключ,Элемент.Значение);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия;
		
	Иначе
		
		Возврат Неопределено
		
	КонецЕсли;
	
КонецФункции // СкопироватьУниверсальнуюКоллекцию()

// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
// В случае работы на клиенте или на сервере выводит в окно сообщений,
// в случае внешнего соединения вызывает исключение.
//
// Параметры:
//  ТекстСообщения - Строка - текст сообщения.
//  Отказ          - Булево - признак отказа (необязательный). По умолчанию Ложь
//	Заголовок - Строка - ПО умолчанию ""
//	Статус - Неопределено - По умолчанию Неопределено
//
Процедура СообщитьОбОшибке(ТекстСообщения, Отказ = Ложь, Заголовок = "", Статус = Неопределено) Экспорт
	Если Статус = Неопределено Тогда
		Статус = СтатусСообщения.Важное;
	КонецЕсли;
	
	НачалоСлужебногоСообщения    = Найти(ТекстСообщения, "{");
	ОкончаниеСлужебногоСообщения = Найти(ТекстСообщения, "}:");
	Если ОкончаниеСлужебногоСообщения > 0 И НачалоСлужебногоСообщения > 0 Тогда
		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1)) +
		                 Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));
	КонецЕсли;

	Отказ = Истина;
	
	#Если ВнешнееСоединение Тогда
		Если ЗначениеЗаполнено(Заголовок) Тогда
			ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
			Заголовок = "";
		КонецЕсли;
		ВызватьИсключение (ТекстСообщения);
	#Иначе
		Если ЗначениеЗаполнено(Заголовок) Тогда
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(Заголовок);
			Заголовок = "";
		КонецЕсли;
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения);
	#КонецЕсли
КонецПроцедуры // СообщитьОбОшибке()

// Функция возвращает максимум/минимум значения заданного свойства в произвольной коллекции
//
// Параметры:
// 	Коллекция - Неопределено - произвольная коллекция, в которой будет искаться максимум/минимум
//  ИмяСвойства - Строка - имя свойства, значение которого будет анализироваться
//  ПоискМаксимума - Булево - Если Истина функция возвращает максимальное значение, иначе минимальное
//  НачальноеЗначение - Число - начальный уровень, от которого начинается сравнение, По умолчанию 0
//
// Возвращаемое значение:
// 	Число, Строка, Дата, Булево - тип определяется типом свойства, допускаются только данные типы.
//
Функция ПолучитьМаксимумМинимумСвойстваВКоллекции(Коллекция, ИмяСвойства, ПоискМаксимума, НачальноеЗначение=0) Экспорт
	
	ТекЗначение = НачальноеЗначение;
	Для Каждого СтрокаКоллекции Из Коллекция Цикл
		Если ПоискМаксимума Тогда
			ТекЗначение = Макс(ТекЗначение,СтрокаКоллекции[ИмяСвойства]);
		Иначе
			ТекЗначение = Мин(ТекЗначение,СтрокаКоллекции[ИмяСвойства]);
		КонецЕсли;
	КонецЦикла;
	
	Возврат ТекЗначение;
КонецФункции

// Функция ПолучитьНовыйКлючСтроки.
//
// Параметры:
//  КоллекцияСтрок - Неопределено
//
// Возвращаемое значение:
//  Неопределено.
//
Функция ПолучитьНовыйКлючСтроки(КоллекцияСтрок) Экспорт 
	
	Возврат ПолучитьМаксимумМинимумСвойстваВКоллекции(КоллекцияСтрок,"КлючСтроки",Истина,0) + 1;
	
КонецФункции

// Функция ВремяВСекунды.
//
// Параметры:
//  ДатаВремя - Дата
//
// Возвращаемое значение:
//  Неопределено.
//
Функция ВремяВСекунды(ДатаВремя) Экспорт
	Если ТипЗнч(ДатаВремя) = Тип("Дата") Тогда
		Возврат ДатаВремя-НачалоДня(ДатаВремя);
	Иначе
		Возврат 0;
	КонецЕсли;
КонецФункции

// Функция ТаблицуЗначенийВМассивСтруктур.
//
// Параметры:
//  ТаблицаЗначений - Неопределено
//
// Возвращаемое значение:
//  Неопределено.
//
Функция ТаблицуЗначенийВМассивСтруктур(ТаблицаЗначений) Экспорт
	
	Результат = Новый Массив;
	
	ИменаКолонок = "";
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		ИменаКолонок = ИменаКолонок + "," + Колонка.Имя;
	КонецЦикла;
	ИменаКолонок = Сред(ИменаКолонок, 2);
	
	Для Каждого Строка Из ТаблицаЗначений Цикл
		СтруктураСтроки = Новый Структура(ИменаКолонок);
		ЗаполнитьЗначенияСвойств(СтруктураСтроки, Строка);
		Результат.Добавить(СтруктураСтроки);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Функция ПолучитьПолноеЧислоЛетСДаты.
//
// Параметры:
//  ДатаНачала - Дата
//  ДатаОкончания - Дата
//
// Возвращаемое значение:
//  Неопределено.
//
Функция ПолучитьПолноеЧислоЛетСДаты(Знач ДатаНачала, Знач ДатаОкончания) Экспорт
	
	ВозрастЛет = Год(ДатаОкончания) - Год(ДатаНачала);
	
	Если Месяц(ДатаОкончания) < Месяц(ДатаНачала)
		Или Месяц(ДатаОкончания) = Месяц(ДатаНачала) И День(ДатаОкончания) < День(ДатаНачала)
	Тогда
		ВозрастЛет = ВозрастЛет - 1;
	КонецЕсли;
	
	Возврат ВозрастЛет;
	
КонецФункции

// Функция ПолучитьВозрастСтрокой.
//
// Параметры:
//  ДатаРождения - Дата
//  ДатаОтсчета - Дата - По умолчанию Неопределено
//  Выводить0Лет - Булево - По умолчанию Истина
//
// Возвращаемое значение:
//  Неопределено.
//
Функция ПолучитьВозрастСтрокой(Знач ДатаРождения, Знач ДатаОтсчета = Неопределено, Выводить0Лет = Истина) Экспорт
	
	Если Не ЗначениеЗаполнено(ДатаРождения) Тогда
		Возраст = "";
	Иначе
		Если ДатаОтсчета = Неопределено Тогда
			ДатаОтсчета = ТекущаяДата();
		КонецЕсли;
		
		ВозрастЛет = ПолучитьПолноеЧислоЛетСДаты(ДатаРождения, ДатаОтсчета);
		Если ВозрастЛет >= 0 Тогда
			Возраст = Формат(ВозрастЛет,"ЧГ=0; ЧН="); 
			Послед = Число(Прав(Возраст,2));
			Если Послед > 20 Тогда 
				Послед = Послед % 10;
			КонецЕсли;
			// Склонение года
			Если Послед = 1 Тогда
				Возраст = Возраст + " год";
			ИначеЕсли Послед = 0 Или Послед > 4 Тогда
				Возраст = Возраст + " лет";	
			Иначе
				Возраст = Возраст + " года";
			КонецЕсли;
			
			Если ВозрастЛет = 0 И Не Выводить0Лет Тогда
				Возраст = "";
			КонецЕсли;
			
			// Для детей до 3 лет выводится количество месяцев.
			Если ВозрастЛет < 3 Тогда
				
				ВозрастМесяцев = 0;
				
				// Находим последний день рождения.
				мДата = ДатаРождения;
				Пока мДата <= ДатаОтсчета Цикл
					мДата = ДобавитьМесяц(мДата, 12);
				КонецЦикла;
				ПоследнийДР = ДобавитьМесяц(мДата, -12);
				
				мДата = ДатаОтсчета;
				Пока Истина Цикл
					
					мДата = ДобавитьМесяц(мДата,-1);
					Если мДата > ПоследнийДР Тогда
						ВозрастМесяцев = ВозрастМесяцев + 1;
					Иначе
						Прервать;
					КонецЕсли;
					
				КонецЦикла;
		
				Возраст = Возраст + " " + Формат(ВозрастМесяцев,"ЧН=0");
				// Склонение месяца
				Если ВозрастМесяцев = 1 Тогда
					Возраст = Возраст + " месяц";
				ИначеЕсли ВозрастМесяцев >= 2 И ВозрастМесяцев <= 4 Тогда
					Возраст = Возраст + " месяца";
				Иначе
					Возраст = Возраст + " месяцев";
				КонецЕсли;
			КонецЕсли;
		Иначе
			Возраст = "";
		КонецЕсли;
	КонецЕсли;
	
	Возврат Возраст;
	
КонецФункции

// Функция КодОсновногоЯзыка.
//
// Возвращаемое значение:
//  Неопределено.
//
Функция КодОсновногоЯзыка() Экспорт
	#Если Клиент Тогда
		Возврат "ru";
	#Иначе
		Возврат Метаданные.ОсновнойЯзык.КодЯзыка;
	#КонецЕсли
КонецФункции

// Возвращает ссылку на общий модуль по имени.
//
// Параметры:
//  Имя          - Строка - имя общего модуля, например:
//                 "ОбщегоНазначения",
//                 "ОбщегоНазначенияКлиент".
//
// Возвращаемое значение:
//  ОбщийМодуль.
//
Функция ОбщийМодуль(Имя) Экспорт
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	Модуль = ОбщегоНазначения.ОбщийМодуль(Имя);
#Иначе
	Модуль = СтандартныеПодсистемыКлиент.КлиентскийОбщийМодуль(Имя);
#КонецЕсли
	
	Возврат Модуль;
	
КонецФункции

// To do: обновить на СтрокаВДату() БСП 3.1.
//
// Параметры:
//  СтрокаДата - Строка
//
// Возвращаемое значение:
//  Дата.
//
Функция ПолучитьДатуИзСтроки(Знач СтрокаДата) Экспорт
	
	Если ТипЗнч(СтрокаДата) <> Тип("Строка") Тогда 
		СтрокаДата = Строка(СтрокаДата);
	КонецЕсли;
	
	Попытка
		НайденнаяДата = Дата(СтрокаДата);
		ДатаПолучена = Истина;
	Исключение
		ДатаПолучена = Ложь;	
	КонецПопытки;
	
	Если ДатаПолучена Тогда 
		Возврат НайденнаяДата;
	КонецЕсли;
	
	ШаблонЦифры = "0123456789";
	ШаблонРазделители = ".-/\:_";
	
	мсЧастиДаты = Новый Массив;
	МаксКлючи = Новый Структура;
	ТекНомерЧастиДаты = 0;
	ТекЧастьДаты = "";
	
	ПредСимволРазделитель = Истина;
	ТекРазделитель = "";
	ПредРазделитель = "";
	
	ДлинаСтроки = СтрДлина(СтрокаДата);
	Для Сч = 1 По ДлинаСтроки Цикл
		
		ТекСимвол = Сред(СтрокаДата, Сч, 1);
		ЭтоПоследнийСимволЧасти = (Сч = ДлинаСтроки); 
		
		Если Найти(ШаблонЦифры, ТекСимвол) <> 0 Тогда
			ПредСимволРазделитель = Ложь;
			ТекЧастьДаты = ТекЧастьДаты + ТекСимвол;
		Иначе
			Если Найти(ШаблонРазделители, ТекСимвол) Тогда 
				ПредРазделитель = ТекРазделитель;
				ТекРазделитель = ТекСимвол;
			КонецЕсли;
			Если Не ПредСимволРазделитель Тогда 
				ЭтоПоследнийСимволЧасти = Истина;
			КонецЕсли;
			ПредСимволРазделитель = Истина;
		КонецЕсли;
		
		Если ЭтоПоследнийСимволЧасти Тогда
			Если ТекЧастьДаты = "" Тогда 
				Продолжить;
			КонецЕсли;
			
			ЧастьЧисло = Число(ТекЧастьДаты);
			СтруктураЧасти = Новый Структура("День, Месяц, Год, Час, Мин, Сек", 0, 0, 0, 0, 0, 0);
			мсЧастиДаты.Добавить(СтруктураЧасти);
			
			ЧастьЧисло = Число(ТекЧастьДаты);
			Если ЧастьЧисло > 0 И ЧастьЧисло <= 12 Тогда // Месяц 
				СтруктураЧасти.Месяц = СтруктураЧасти.Месяц + 1;
				Если ТекНомерЧастиДаты = 1 Тогда
					СтруктураЧасти.Месяц = СтруктураЧасти.Месяц + 1;
				КонецЕсли;
				Если МаксКлючи.Свойство("День") И МаксКлючи["День"] = ТекНомерЧастиДаты - 1 Тогда 
					СтруктураЧасти.Месяц = СтруктураЧасти.Месяц + 1;
				КонецЕсли;
			КонецЕсли;
			Если ЧастьЧисло < 24 Тогда // Час
				СтруктураЧасти.Час = СтруктураЧасти.Час + 1;
				Если ТекНомерЧастиДаты = 3 Тогда
					СтруктураЧасти.Час = СтруктураЧасти.Час + 1;
				КонецЕсли;
				Если ТекРазделитель = ":" Или ПредРазделитель = ":" Тогда 
					СтруктураЧасти.Час = СтруктураЧасти.Час + 2;
				КонецЕсли;
			КонецЕсли;
			Если ЧастьЧисло > 0 И ЧастьЧисло <= 31 Тогда // День
				СтруктураЧасти.День = СтруктураЧасти.День + 1;
				Если ТекНомерЧастиДаты = 0 Тогда 
					СтруктураЧасти.День = СтруктураЧасти.День + 1;
				КонецЕсли;
				Если МаксКлючи.Свойство("Месяц") И МаксКлючи["Месяц"] = ТекНомерЧастиДаты - 1 Тогда 
					СтруктураЧасти.День = СтруктураЧасти.День + 1;
				КонецЕсли;
			КонецЕсли;
			Если ЧастьЧисло < 60 Тогда // Минуты и секунды
				СтруктураЧасти.Мин = СтруктураЧасти.Мин + 1;
				СтруктураЧасти.Сек = СтруктураЧасти.Сек + 1;
				Если ТекРазделитель = ":" Или ПредРазделитель = ":" Тогда 
					СтруктураЧасти.Мин = СтруктураЧасти.Мин + 2;
					СтруктураЧасти.Сек = СтруктураЧасти.Сек + 2;
				КонецЕсли;
			КонецЕсли;
			Если ЧастьЧисло > 0 Тогда // Год
				Если СтрДлина(ТекЧастьДаты) = 4 Тогда 
					СтруктураЧасти.Год = СтруктураЧасти.Год + 2;
				КонецЕсли;
				Если СтрДлина(ТекЧастьДаты) = 2 И ТекНомерЧастиДаты = 2 Тогда 
					СтруктураЧасти.Год = СтруктураЧасти.Год + 1;
				КонецЕсли;
			КонецЕсли;
			
			МаксКлюч = "";
			Для Каждого кзЧасть Из СтруктураЧасти Цикл
				Если (МаксКлюч = "" Или кзЧасть.Значение > СтруктураЧасти[МаксКлюч])
					И Не МаксКлючи.Свойство(кзЧасть.Ключ) Тогда 
					МаксКлюч = кзЧасть.Ключ;
				КонецЕсли;
			КонецЦикла;
			МаксКлючи.Вставить(МаксКлюч, ЧастьЧисло);
			СтруктураЧасти.Вставить("МаксКлюч", МаксКлюч);
			СтруктураЧасти.Вставить("Строка", ТекЧастьДаты);
			СтруктураЧасти.Вставить("Число", ЧастьЧисло);
			
			ТекЧастьДаты = "";
			ТекНомерЧастиДаты = ТекНомерЧастиДаты + 1;
			Если ТекНомерЧастиДаты = 6 Тогда 
				Прервать;
			КонецЕсли;
		КонецЕсли;	
		
	КонецЦикла;
	
	Если мсЧастиДаты.Количество() < 2 Тогда 
		Возврат Неопределено;
	КонецЕсли;
	
	ТекДата = ТекущаяДата();
	Год = 1;
	Месяц = 1;
	День = 1;
	Час = 0;
	Минута = 0;
	Секунда = 0;
	
	// Если найдена часть даты, дополняем.
	Если МаксКлючи.Свойство("Год") Или МаксКлючи.Свойство("Месяц") Или МаксКлючи.Свойство("День") Тогда 
		
		Если Не МаксКлючи.Свойство("Год") Тогда 
			МаксКлючи.Вставить("Год", Год(ТекДата));
		Иначе
			Год = МаксКлючи["Год"];
			Если МаксКлючи["Год"] < 100 Тогда
				ТекГодСтрокой = Формат(Год(ТекДата), "ЧГ=");
				ПервыеЦифрыГода = Число(Лев(ТекГодСтрокой, 2));
				ПоследЦифрыГода = Число(Прав(ТекГодСтрокой, 2));
				Год = Число(Строка(ПервыеЦифрыГода - ?(Год <= ПоследЦифрыГода, 0, 1)) + Формат(Год, "ЧЦ=2; ЧН=00; ЧВН="));
				МаксКлючи.Вставить("Год", Год);
			КонецЕсли;	
		КонецЕсли;
		
		Если Не МаксКлючи.Свойство("Месяц") Тогда
			МаксКлючи.Вставить("Месяц", Месяц(ТекДата));
		КонецЕсли;
		
		Если Не МаксКлючи.Свойство("День") Тогда 
			МаксКлючи.Вставить("День", 1);
		КонецЕсли;
		
	Иначе
		МаксКлючи.Вставить("День", 1);
		МаксКлючи.Вставить("Месяц", 1);
		МаксКлючи.Вставить("Год", 1);	
	КонецЕсли;

	Если Не МаксКлючи.Свойство("Час") Тогда 
		МаксКлючи.Вставить("Час", 0);
	КонецЕсли;
	Если Не МаксКлючи.Свойство("Мин") Тогда 
		МаксКлючи.Вставить("Мин", 0);
	КонецЕсли;
	Если Не МаксКлючи.Свойство("Сек") Тогда 
		МаксКлючи.Вставить("Сек", 0);
	КонецЕсли;
	
	Попытка
		НайденнаяДата = Дата(МаксКлючи.Год, МаксКлючи.Месяц, МаксКлючи.День, МаксКлючи.Час, МаксКлючи.Мин, МаксКлючи.Сек);
	Исключение
		Попытка
			НайденнаяДата = Дата(1, 1, 1, МаксКлючи.Час, МаксКлючи.Мин, МаксКлючи.Сек);
		Исключение
			Попытка
				НайденнаяДата = Дата(МаксКлючи.Год, МаксКлючи.Месяц, МаксКлючи.День);
			Исключение
			КонецПопытки;
		КонецПопытки;
	КонецПопытки;
	
	Возврат НайденнаяДата;
		
КонецФункции

// Процедура заполняет КПП на базе ИНН.
// Параметры:
//  ИНН - Неопределено
//  КПП - Неопределено
//  БезусловноеЗаполнениеКПП - Булево - По умолчанию Истина
//
Процедура ЗаполнитьКППпоИНН(Знач ИНН, КПП, БезусловноеЗаполнениеКПП = Истина) Экспорт
	
	// Если КПП формируется стандартным образом по ИНН, то для КПП берутся 
	// первые 4 цифры ИНН + 01001, например:
	// ИНН 7712563009
	// КПП 771201001.
		
	// Если не указано ИНН или заполнено КПП то прерываем выполнение операции.
	Если (СтрДлина(ИНН) < 4) Тогда
		Возврат;
	КонецЕсли;
	
	ПревыеСимволыИНН = Лев(ИНН, 4);
	НовоеЗначениеКПП = ПревыеСимволыИНН + "01001";
	
	// Если новое значение КПП и старое значение КПП совпадают, то прерываем выполнение операции.
	Если (НовоеЗначениеКПП = КПП) Тогда
		Возврат;
	КонецЕсли;
	
	// Если безусловно нужно поменять - меняем.
	Если БезусловноеЗаполнениеКПП ИЛИ НЕ ЗначениеЗаполнено(КПП) Тогда
		КПП = НовоеЗначениеКПП;
		Возврат;
	КонецЕсли;
	
	#Если Клиент Тогда
	ОтветНужноМенятьКПП = (Вопрос("Изменить КПП автоматически на """ + НовоеЗначениеКПП + """?", РежимДиалогаВопрос.ДаНет) = КодВозвратаДиалога.Да);
	Если ОтветНужноМенятьКПП Тогда
		КПП = НовоеЗначениеКПП;
	КонецЕсли;
	#Иначе
		КПП = НовоеЗначениеКПП;
	#КонецЕсли
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ПРОВЕРКОЙ ЗАПОЛНЕНИЯ.

// Процедура заполняет массив непроверяемых реквизитов значениями, не используемыми при выбранной хозяйственной
// 	операции документа 
//
// Параметры:
// 	МассивВсехРеквизитов - Массив из Неопределено - Массив всех реквизитов документа.
// 	МассивРеквизитовОперации - Массив из Неопределено - Массив реквизитов документа, которые относятся к хозяйственной операции
// 	                                    документа.
// 	МассивНепроверяемыхРеквизитов - Массив из Неопределено -  реквизитов объекта, не требующих проверки.
//
Процедура ЗаполнитьМассивНепроверяемыхРеквизитов(МассивВсехРеквизитов, МассивРеквизитовОперации, МассивНепроверяемыхРеквизитов) Экспорт
	
	Для Каждого ЭлементМассива Из МассивВсехРеквизитов Цикл
		
		// Если реквизит не используется для хозяйственной операции, исключаем данный реквизит из проверки.
		Если МассивРеквизитовОперации.Найти(ЭлементМассива) = Неопределено Тогда
			МассивНепроверяемыхРеквизитов.Добавить(ЭлементМассива);


		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Определяет, запущена ли база версией платформы 8.3.
//
// Возвращаемое значение:
//  Неопределено.
//
Функция ЭтоПлатформа83() Экспорт
	
	Информация = Новый СистемнаяИнформация;
	Возврат Лев(Информация.ВерсияПриложения, 3) = "8.3";
	
КонецФункции

// Возвращает приведенное имя параметра, удовлетворяющее требованиям платформы, например, для использования в качестве
// ключа структуры.
//
// Параметры:
//  ИмяПараметра - Строка - имя параметра.
//
// Возвращаемое значение:
//  Строка - приведенное имя параметра.
//
Функция ПривестиИмяПараметраКДопустимому(Знач ИмяПараметра) Экспорт
	
	БуквыРус	= Новый Структура("Начало, Конец", КодСимвола("А"), КодСимвола("я"));
	БуквыАнг	= Новый Структура("Начало, Конец", КодСимвола("A"), КодСимвола("z"));
	Цифры		= Новый Структура("Начало, Конец", КодСимвола("0"), КодСимвола("9"));
	мсОтдельныеСимволы = Новый Массив;
	мсОтдельныеСимволы.Добавить(КодСимвола("_"));

	ПриведенноеИмя = "";
	ДлинаСтроки = СтрДлина(ИмяПараметра);
	НачалоСтроки = Истина;
	СледующийСимволБольшой = Ложь;
	Для Сч = 1 По ДлинаСтроки Цикл
		
		ТекСимвол = Сред(ИмяПараметра, Сч, 1);
		КодТекСимвола = КодСимвола(ТекСимвол);
		Если 
			(КодТекСимвола >= БуквыРус.Начало И КодТекСимвола <= БуквыРус.Конец) Или
			(КодТекСимвола >= БуквыАнг.Начало И КодТекСимвола <= БуквыАнг.Конец) Или
			(Не НачалоСтроки И КодТекСимвола >= Цифры.Начало И КодТекСимвола <= Цифры.Конец) Или
			(мсОтдельныеСимволы.Найти(КодТекСимвола) <> Неопределено)
		Тогда
		
			ПриведенноеИмя = ПриведенноеИмя + ?(СледующийСимволБольшой, ВРег(ТекСимвол), ТекСимвол);
			НачалоСтроки = Ложь;
			СледующийСимволБольшой = Ложь;
			
		Иначе
			
			СледующийСимволБольшой = Истина;
		
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ПриведенноеИмя;
	
КонецФункции

// Функция - проверяет, удовлетворяет ли имя параметра требованиям платформы, например, для использования в качестве
//           ключа структуры
//
// Параметры:
//  ИмяПараметра - Строка - Имя параметра, переменной
// 
// Возвращаемое значение:
// 	Булево - Истина, если имя переменной удовлетворяет требованиям платформы.
//
Функция ИмяПараметраКорректно(ИмяПараметра) Экспорт 
	
	СтруктураДляПроверки = Новый Структура;
	Попытка
		СтруктураДляПроверки.Вставить(ИмяПараметра);
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
	Возврат Истина;
	
КонецФункции

// Функция - Ищет в тексте параметры, заключенные в определенные символы, скобки
//
// Параметры:
//  Текст					 - Строка - Текст, в котором необходимо найти параметры
//  НачалоПараметра			 - Строка - Начальный символ параметра, например '<', '[' и т.д
//  КонецПараметра			 - Строка - Конечный символ параметра
//  ПроверятьКорректность	 - Булево - Определяет необходимость проверки имени найденного параметра на соответствие
//                                    требованиям платформы
//  ТолькоСамыеВложенные	 - Булево - Если в тексте имеются вложенные параметры, определяют, будут ли возвращены все или
//                                   только последние
// 
// Возвращаемое значение:
// 	Массив из Неопределено - Массив структур с полями 'Начало' - номер символа в тексте, 'Конец', 'ИмяПараметра',
//          'ИмяПараметраИсходное', 'ПараметрКорректен'
//
Функция НайтиПараметрыВТексте(Знач Текст, Знач НачалоПараметра = "<", Знач КонецПараметра = ">", ПроверятьКорректность = Истина, ТолькоСамыеВложенные = Истина) Экспорт 
	
	СписокПараметров = Новый Массив;
	СтекПараметров = Новый Массив;
	
	НачалоПараметра = Лев(НачалоПараметра, 1);
	КонецПараметра = Прав(КонецПараметра, 1);
	
	ДлинаТекста = СтрДлина(Текст);
	СтруктураПараметра = Неопределено;
	Для Сч = 1 По ДлинаТекста Цикл
		
		ТекСимвол = Сред(Текст, Сч, 1);
		Если ТекСимвол = НачалоПараметра Тогда
			СтруктураПараметра = Новый Структура("Начало, Конец, ИмяПараметра, ИмяПараметраИсходное, ПараметрКорректен", Сч, Сч, "", "", Истина);
			СтекПараметров.Добавить(СтруктураПараметра);
		ИначеЕсли ТекСимвол = КонецПараметра Тогда 
			Если СтекПараметров.Количество() > 0 Тогда 
				СтруктураПараметра = СтекПараметров[СтекПараметров.ВГраница()];
				СтруктураПараметра.Конец = Сч;
				
				ИмяПараметра = Сред(СтруктураПараметра.ИмяПараметра, 2, СтрДлина(СтруктураПараметра.ИмяПараметра) - 1);
				Если Не ПустаяСтрока(ИмяПараметра) Тогда 
					СписокПараметров.Добавить(СтруктураПараметра);
					СтруктураПараметра.ИмяПараметраИсходное = ИмяПараметра;
					СтруктураПараметра.ИмяПараметра = ИмяПараметра;
					Если ПроверятьКорректность И Не ИмяПараметраКорректно(ИмяПараметра) Тогда
						КорректноеИмяПараметра = ПривестиИмяПараметраКДопустимому(ИмяПараметра);
						СтруктураПараметра.ИмяПараметра = КорректноеИмяПараметра;
						СтруктураПараметра.ПараметрКорректен = (НРег(СтруктураПараметра.ИмяПараметра) = НРег(СтруктураПараметра.ИмяПараметраИсходное));
					КонецЕсли;
				Иначе
					СтруктураПараметра.ПараметрКорректен = Ложь;	
				КонецЕсли;
				
				СтруктураПараметра = Неопределено;
				Если ТолькоСамыеВложенные Тогда 
					СтекПараметров.Очистить();
				Иначе
					СтекПараметров.Удалить(СтекПараметров.ВГраница());
					Если СтекПараметров.Количество() > 0 Тогда 
						СтруктураПараметра = СтекПараметров[СтекПараметров.ВГраница()];
					КонецЕсли;
				КонецЕсли;
				
			КонецЕсли;
		КонецЕсли;
		
		Для Каждого ЭлементСтека Из СтекПараметров Цикл 
			ЭлементСтека.ИмяПараметра = ЭлементСтека.ИмяПараметра + ТекСимвол;
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат СписокПараметров;
	
КонецФункции

// Функция - Возвращает список параметров макета табличного документа
//
// Параметры:
//  ТабличныйДокумент			 - ТабличныйДокумент - Документ, в котором необходимо найти параметры.
//  ПроверятьКорректность		 - Булево - Определяет, будут ли возвращены параметры с именем, не удовлетворяющим
//                                     требованиям платформы.
//  ИскатьПараметрыВШаблонах	 - Булево - Определяет, нужно ли пытаться искать параметры в тексте ячеек с видом
//                                       заполнения 'Шаблон'.
//  ВключатьПараметрыРасшифровки - Булево - Определяет, нужно ли включать в список параметры расшифровки.
//  ВключатьПараметрыКартинок	 - Булево - Определяет, нужно ли включать в список параметры картинок.
// 
// Возвращаемое значение:
// 	Массив из Неопределено - массив имен параметров табличного документа.
//
Функция ПолучитьСписокПараметровТабличногоДокумента(ТабличныйДокумент, ПроверятьКорректность = Истина, ИскатьПараметрыВШаблонах = Истина, ВключатьПараметрыРасшифровки = Истина, ВключатьПараметрыКартинок = Истина) Экспорт 
	
	Если Ложь Тогда ТабличныйДокумент = Новый ТабличныйДокумент; КонецЕсли;
	
	СтруктураДляПроверки = Новый Структура;
	
	СоответствиеПараметров = Новый Соответствие;
	
	Для СчС = 1 По ТабличныйДокумент.ВысотаТаблицы Цикл
		Для СчК = 1 По ТабличныйДокумент.ШиринаТаблицы Цикл
			Ячейка = ТабличныйДокумент.Область(СчС, СчК);
			
			Если ЗначениеЗаполнено(Ячейка.Параметр) И (Не ПроверятьКорректность Или ИмяПараметраКорректно(Ячейка.Параметр)) Тогда 
				СоответствиеПараметров.Вставить(НРег(Ячейка.Параметр), Ячейка.Параметр);
			КонецЕсли;
			
			Если ВключатьПараметрыРасшифровки И ЗначениеЗаполнено(Ячейка.ПараметрРасшифровки) И (Не ПроверятьКорректность Или ИмяПараметраКорректно(Ячейка.Параметр)) Тогда 
				СоответствиеПараметров.Вставить(НРег(Ячейка.ПараметрРасшифровки), Ячейка.ПараметрРасшифровки);
			КонецЕсли;
			Если ВключатьПараметрыКартинок И ЗначениеЗаполнено(Ячейка.ПараметрКартинки) И (Не ПроверятьКорректность Или ИмяПараметраКорректно(Ячейка.Параметр)) Тогда 
				СоответствиеПараметров.Вставить(НРег(Ячейка.ПараметрКартинки), Ячейка.ПараметрКартинки);
			КонецЕсли;
			
			Если ИскатьПараметрыВШаблонах И Ячейка.Заполнение = ТипЗаполненияОбластиТабличногоДокумента.Шаблон И ЗначениеЗаполнено(Ячейка.Текст) Тогда
				СписокПараметров = НайтиПараметрыВТексте(Ячейка.Текст, "[", "]");
				Для Каждого СтруктураПараметра Из СписокПараметров Цикл
					Если СтруктураПараметра.ПараметрКорректен Тогда
						СоответствиеПараметров.Вставить(НРег(СтруктураПараметра.ИмяПараметра), СтруктураПараметра.ИмяПараметра);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
			
		КонецЦикла;
	КонецЦикла;
	
	МассивПараметров = Новый Массив;
	Для Каждого кзПараметр Из СоответствиеПараметров Цикл
		МассивПараметров.Добавить(кзПараметр.Значение);
	КонецЦикла;
	
	Возврат МассивПараметров;
	
КонецФункции


////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с внешними приложениями.

// Возвращает структуру параметров для см. процедуру ЗапуститьПрограмму.
//
// Возвращаемое значение:
//  ТекущийКаталог              - Строка - Задает текущий каталог запускаемого приложения.
//  ДождатьсяЗавершения         - Булево - Истина - дожидаться завершения запущенного приложения 
//                                         перед продолжением работы.
//  ПолучитьПотокВывода         - Булево - Истина - результат, направленный в поток stdout,
//                                         если не указан ДождатьсяЗавершения - игнорируется.
//  ПолучитьПотокОшибок         - Булево - Истина - ошибки, направленные в поток stderr,
//                                         если не указан ДождатьсяЗавершения - игнорируется.
//  ВыполнитьСНаивысшимиПравами - Булево - Истина - требуется запустить программу на исполнение 
//                                         с повышением привилегий системы:
//                                         - подтверждение UAC для Windows;
//                                         - интерактивным запросом c GUI sudo и перенаправлением
//                                           $DISPLAY и $XAUTHORITY текущего пользователя для Linux;
//                                         Не совместим с параметром ДождатьсяЗавершения.
//                                         В MacOS игнорируется.
//
Функция ПараметрыЗапускаПрограммы() Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("ТекущийКаталог", "");
	Параметры.Вставить("ДождатьсяЗавершения", Ложь);
	Параметры.Вставить("ПолучитьПотокВывода", Ложь);
	Параметры.Вставить("ПолучитьПотокОшибок", Ложь);
	Параметры.Вставить("ВыполнитьСНаивысшимиПравами", Ложь); // Для переводчиков: RunWithElevatedPermissions.
	
	Возврат Параметры;
	
КонецФункции

// Запускает внешнюю программу в соответствии с параметрами запуска.
// Не доступно в веб-клиенте. 
//
// Параметры:
//  СтрокаКоманды             - Строка                  - Командная строка для запуска программы.
//  ПараметрыЗапускаПрограммы - Структура, Неопределено - см. функцию ПараметрыЗапускаПрограммы.
//
// Возвращаемое значение:
//  Структура - Результат работы программы.
//      КодВозврата - Число  - код возврата программы.
//      ПотокВывода - Строка - результат работы программы, направленный в поток stdout.
//      ПотокОшибок - Строка - ошибки исполнения программы, направленные в поток stderr.
//
// Пример:
//	ОбщегоНазначенияКлиентСервер.ЗапуститьПрограмму("calc");
//	
//	ПараметрыЗапускаПрограммы = ОбщегоНазначенияКлиентСервер.ПараметрыЗапускаПрограммы();
//	ПараметрыЗапускаПрограммы.ВыполнитьСНаивысшимиПравами = Истина;
//	ОбщегоНазначенияКлиентСервер.ЗапуститьПрограмму("C:\Program Files\1cv8\common\1cestart.exe", 
//		ПараметрыЗапускаПрограммы);
//	
//	ПараметрыЗапускаПрограммы = ОбщегоНазначенияКлиентСервер.ПараметрыЗапускаПрограммы();
//	ПараметрыЗапускаПрограммы.ДождатьсяЗавершения = Истина;
//	Результат = ОбщегоНазначенияКлиентСервер.ЗапуститьПрограмму("ping 127.0.0.1 -n 5", ПараметрыЗапускаПрограммы);
//
Функция ЗапуститьПрограмму(Знач СтрокаКоманды, ПараметрыЗапускаПрограммы = Неопределено) Экспорт 
	
#Если ВебКлиент Тогда
	ВызватьИсключение НСтр("ru = 'Запуск программ недоступен в веб-клиенте.'");
#Иначе
	
	Если СодержитНебезопасныеДействия(СтрокаКоманды) Тогда 
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Недопустимая строка команды
			           |%1
			           |по причине:
			           |Строка команды не должна содержать символы: ""$"", ""`"", ""|"", "";"", ""&"".'"),
			СтрокаКоманды);
	КонецЕсли;
	
	Если ПараметрыЗапускаПрограммы = Неопределено Тогда 
		ПараметрыЗапускаПрограммы = ПараметрыЗапускаПрограммы();
	КонецЕсли;
	
	ТекущийКаталог              = ПараметрыЗапускаПрограммы.ТекущийКаталог;
	ДождатьсяЗавершения         = ПараметрыЗапускаПрограммы.ДождатьсяЗавершения;
	ПолучитьПотокВывода         = ПараметрыЗапускаПрограммы.ПолучитьПотокВывода;
	ПолучитьПотокОшибок         = ПараметрыЗапускаПрограммы.ПолучитьПотокОшибок;
	ВыполнитьСНаивысшимиПравами = ПараметрыЗапускаПрограммы.ВыполнитьСНаивысшимиПравами;
	
	Если ВыполнитьСНаивысшимиПравами Тогда 
#Если ВнешнееСоединение Тогда
		ВызватьИсключение 
			НСтр("ru = 'Недопустимое значение параметра ПараметрыЗапускаПрограммы.ВыполнитьСНаивысшимиПравами.
			           |Повешение привилегий системы не доступно из внешнего соединения.'");
#КонецЕсли
		
#Если Сервер Тогда
		ВызватьИсключение 
			НСтр("ru = 'Недопустимое значение параметра ПараметрыЗапускаПрограммы.ВыполнитьСНаивысшимиПравами.
			           |Повешение привилегий системы не доступно на сервере.'");
#КонецЕсли
		
	КонецЕсли;
	
	Если ДождатьсяЗавершения Тогда 
		
		Если ПолучитьПотокВывода Тогда 
			ФайлПотокаВывода = ПолучитьИмяВременногоФайла("stdout.tmp");
			СтрокаКоманды = СтрокаКоманды + " > """ + ФайлПотокаВывода + """";
		КонецЕсли;
		
		Если ПолучитьПотокОшибок Тогда 
			ФайлПотокаОшибок = ПолучитьИмяВременногоФайла("stderr.tmp");
			СтрокаКоманды = СтрокаКоманды + " 2>""" + ФайлПотокаОшибок + """";
		КонецЕсли;
		
	КонецЕсли;
	
	КодВозврата = Неопределено;
	
	СистемнаяИнформация = Новый СистемнаяИнформация();
	Если (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86) 
		Или (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64) Тогда
		
		// Из-за запуска через shell перенаправление каталога требуется сделать командой.
		Если Не ПустаяСтрока(ТекущийКаталог) Тогда 
			СтрокаКоманды = "cd """ + ТекущийКаталог + """ && " + СтрокаКоманды;
		КонецЕсли;
		
		// Выполняется запуск через cmd.exe (для перенаправления stdout и stderr).
		СтрокаКоманды = "cmd /S /C "" " + СтрокаКоманды + " """;
		
#Если Сервер Тогда
		Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
			// В файловой информационной базе показывать окно консоли не следует и в серверном контексте.
			Оболочка = Новый COMОбъект("Wscript.Shell");
			// Run запускает новый процесс, не являющийся дочерним текущего процесса (в отличии от Exec).
			КодВозврата = Оболочка.Run(СтрокаКоманды, 0, ДождатьсяЗавершения);
			Оболочка = Неопределено;
		Иначе 
			ЗапуститьПриложение(СтрокаКоманды,, ДождатьсяЗавершения, КодВозврата);
		КонецЕсли;
#ИначеЕсли Не МобильныйКлиент Тогда 
		Если ВыполнитьСНаивысшимиПравами Тогда
			
			Если ДождатьсяЗавершения Тогда
				ВызватьИсключение 
					НСтр("ru = 'Недопустимо одновременно устанавливать параметры 
					           | - ПараметрыЗапускаПрограммы.ДождатьсяЗавершения и
					           | - ПараметрыЗапускаПрограммы.ВыполнитьСНаивысшимиПравами:
					           |Операционная система не позволяет отслеживать от имени пользователя процессы,
					           |запущенные администратором.'");
			КонецЕсли;
			
			// После начала исполнения файла команды отследить статус процесса будет невозможно,
			// Потому удалять batch файл следует последней строкой команды в самом batch файле.
			// Асинхронно удалять нельзя, иначе может наступить коллизия, 
			// когда идет попытка удаления, а запуск еще не состоялся.
			
			ФайлКоманды = ПолучитьИмяВременногоФайла("runas.bat");
			ЗаписьКоманды = Новый ЗаписьТекста(ФайлКоманды, КодировкаТекста.OEM);
			ЗаписьКоманды.ЗаписатьСтроку(СтрокаКоманды);
			ЗаписьКоманды.ЗаписатьСтроку("del /f /q """ + ФайлКоманды + """");
			ЗаписьКоманды.Закрыть();
			
			Оболочка = Новый COMОбъект("Shell.Application");
			// Запуск с передачей глагола действия - повышения привилегий.
			Оболочка.ShellExecute("cmd", "/c """ + ФайлКоманды + """",, "runas", 0);
			Оболочка = Неопределено;
			
		Иначе 
			Оболочка = Новый COMОбъект("Wscript.Shell");
			// Run запускает новый процесс, не являющийся дочерним текущего процесса (в отличии от Exec).
			КодВозврата = Оболочка.Run(СтрокаКоманды, 0, ДождатьсяЗавершения);
			Оболочка = Неопределено;
		КонецЕсли;
#КонецЕсли
		
	ИначеЕсли (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86) 
		Или (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86_64) Тогда
		
		Если ВыполнитьСНаивысшимиПравами Тогда
			
			ШаблонКоманды = "pkexec env DISPLAY=[DISPLAY] XAUTHORITY=[XAUTHORITY] [СтрокаКоманды]";
			
			ПараметрыШаблона = Новый Структура;
			ПараметрыШаблона.Вставить("СтрокаКоманды", СтрокаКоманды);
			
			ПараметрыЗапускаПодпрограммы = ПараметрыЗапускаПрограммы();
			ПараметрыЗапускаПодпрограммы.ДождатьсяЗавершения = Истина;
			ПараметрыЗапускаПодпрограммы.ПолучитьПотокВывода = Истина;;
			
			Результат = ЗапуститьПрограмму("echo $DISPLAY", ПараметрыЗапускаПодпрограммы);
			ПараметрыШаблона.Вставить("DISPLAY", Результат.ПотокВывода);
			
			Результат = ЗапуститьПрограмму("echo $XAUTHORITY", ПараметрыЗапускаПодпрограммы);
			ПараметрыШаблона.Вставить("XAUTHORITY", Результат.ПотокВывода);
			
			СтрокаКоманды = СтроковыеФункцииКлиентСервер.ВставитьПараметрыВСтроку(ШаблонКоманды, ПараметрыШаблона);
			ДождатьсяЗавершения = Истина;
			
		КонецЕсли;
		
		ЗапуститьПриложение(СтрокаКоманды, ТекущийКаталог, ДождатьсяЗавершения, КодВозврата);
		
	Иначе
		
		// Для MacOS просто запускаем команду.
		// Параметр ПараметрыЗапускаПрограммы.ВыполнитьСНаивысшимиПравами игнорируется.
		ЗапуститьПриложение(СтрокаКоманды, ТекущийКаталог, ДождатьсяЗавершения, КодВозврата);
		
	КонецЕсли;
	
	// Переопределение возвращенного оболочной значения.
	Если КодВозврата = Неопределено Тогда 
		КодВозврата = 0;
	КонецЕсли;
	
	ПотокВывода = "";
	ПотокОшибок = "";
	
	Если ДождатьсяЗавершения Тогда 
		
		Если ПолучитьПотокВывода Тогда
			
			ЧтениеПотокаВывода = Новый ЧтениеТекста(ФайлПотокаВывода, КодировкаСтандартныхПотоков()); 
			ПотокВывода = ЧтениеПотокаВывода.Прочитать();
			ЧтениеПотокаВывода.Закрыть();
			
			УдалитьВременныйФайл(ФайлПотокаВывода);
			
			Если ПотокВывода = Неопределено Тогда 
				ПотокВывода = "";
			КонецЕсли;
			
		КонецЕсли;
		
		Если ПолучитьПотокОшибок Тогда 
			
			ЧтениеПотокаОшибок = Новый ЧтениеТекста(ФайлПотокаОшибок, КодировкаСтандартныхПотоков());
			ПотокОшибок = ЧтениеПотокаОшибок.Прочитать();
			ЧтениеПотокаОшибок.Закрыть();
			
			УдалитьВременныйФайл(ФайлПотокаОшибок);
			
			Если ПотокОшибок = Неопределено Тогда 
				ПотокОшибок = "";
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("КодВозврата", КодВозврата);
	Результат.Вставить("ПотокВывода", ПотокВывода);
	Результат.Вставить("ПотокОшибок", ПотокОшибок);
	
	Возврат Результат;
	
#КонецЕсли
	
КонецФункции

// Запускает диагностику сетевого ресурса.
// Не доступно в веб-клиенте.
// В модели сервиса функциональность ограничена получением описания ошибки.
//
// Параметры:
//  URL - Строка - адрес URL ресурса, диагностику которого надо выполнить.
//
// Возвращаемое значение:
//  Структура - Результат работы программы.
//      ОписаниеОшибки    - Строка - краткое описание ошибки.
//      ЖурналДиагностики - Строка - подробный журнал диагностики с техническими подробностями.
//
// Пример:
//	// Диагностика веб-сервиса адресного классификатора.
//	Результат = ОбщегоНазначенияКлиентСервер.ДиагностикаСоединения("https://api.orgaddress.1c.ru/orgaddress/v1?wsdl");
//	
//	ОписаниеОшибки    = Результат.ОписаниеОшибки;
//	ЖурналДиагностики = Результат.ЖурналДиагностики;
//
Функция ДиагностикаСоединения(URL) Экспорт
	
#Если ВебКлиент Тогда
	ВызватьИсключение НСтр("ru = 'Выполнение диагностики соединения недоступно в веб-клиенте.'");
#Иначе
	
	Описание = Новый Массив;
	Описание.Добавить(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'При обращении по URL: %1'"), 
		URL));
	Описание.Добавить(ПредставлениеМестаДиагностики());
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	Если ОбщегоНазначения.РазделениеВключено() Тогда
		Описание.Добавить(
			НСтр("ru = 'Обратитесь к администратору.'"));
		
		ОписаниеОшибки = СтрСоединить(Описание, Символы.ПС);
		
		Результат = Новый Структура;
		Результат.Вставить("ОписаниеОшибки", ОписаниеОшибки);
		Результат.Вставить("ЖурналДиагностики", "");
		
		Возврат Результат;
	КонецЕсли;
#КонецЕсли
	
	Журнал = Новый Массив;
	Журнал.Добавить(
		НСтр("ru = 'Журнал диагностики:
		           |Выполняется проверка доступности сервера.
		           |Описание диагностируемой ошибки см. в следующем сообщении журнала.'"));
	Журнал.Добавить();
	
	СоединениеЧерезПрокси = Ложь;
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ПолучениеФайловИзИнтернета") Тогда
		МодульПолучениеФайловИзИнтернетаКлиентСервер = 
			ОбщегоНазначения.ОбщийМодуль("ПолучениеФайловИзИнтернетаКлиентСервер");
		СостояниеНастроекПрокси = МодульПолучениеФайловИзИнтернетаКлиентСервер.СостояниеНастроекПрокси();
		
		СоединениеЧерезПрокси = СостояниеНастроекПрокси.СоединениеЧерезПрокси;
		
		Журнал.Добавить(СостояниеНастроекПрокси.Представление);
	КонецЕсли;
#Иначе
	Если ОбщегоНазначенияКлиент.ПодсистемаСуществует("СтандартныеПодсистемы.ПолучениеФайловИзИнтернета") Тогда
		МодульПолучениеФайловИзИнтернетаКлиентСервер = 
			ОбщегоНазначенияКлиент.ОбщийМодуль("ПолучениеФайловИзИнтернетаКлиентСервер");
		СостояниеНастроекПрокси = МодульПолучениеФайловИзИнтернетаКлиентСервер.СостояниеНастроекПрокси();
		
		СоединениеЧерезПрокси = СостояниеНастроекПрокси.СоединениеЧерезПрокси;
		
		Журнал.Добавить(СостояниеНастроекПрокси.Представление);
	КонецЕсли;
#КонецЕсли
	
	Если СоединениеЧерезПрокси Тогда 
		
		Описание.Добавить(
			НСтр("ru = 'Диагностика соединения не выполнена, т.к. настроен прокси-сервер.
			           |Обратитесь к администратору.'"));
		
	Иначе 
		
		СтруктураСсылки = СтруктураURI(URL);
		АдресСервераРесурса = СтруктураСсылки.Хост;
		АдресСервераКонтрольнойПроверки = "1c.com";
		
		РезультатДоступностиРесурса = ПроверитьДоступностьСервера(АдресСервераРесурса);
		
		Журнал.Добавить();
		Журнал.Добавить("1) " + РезультатДоступностиРесурса.ЖурналДиагностики);
		
		Если РезультатДоступностиРесурса.Доступен Тогда 
			
			Описание.Добавить(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Выполнено обращение к несуществующему ресурсу на сервере %1
				           |или возникли неполадки на удаленном сервере.'"),
				АдресСервераРесурса));
			
		Иначе 
			
			РезультатКонтрольнойПроверки = ПроверитьДоступностьСервера(АдресСервераКонтрольнойПроверки);
			Журнал.Добавить("2) " + РезультатКонтрольнойПроверки.ЖурналДиагностики);
			
			Если Не РезультатКонтрольнойПроверки.Доступен Тогда
				
				Описание.Добавить(
					НСтр("ru = 'Отсутствует доступ в сеть интернет по причине:
					           |- компьютер не подключен к интернету;
					           |- неполадки у интернет-провайдера;
					           |- подключение к интернету блокирует межсетевой экран, 
					           |  антивирусная программа или другое программное обеспечение.'"));
				
			Иначе 
				
				Описание.Добавить(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Сервер %1 не доступен по причине:
					           |- неполадки у интернет-провайдера;
					           |- подключение к серверу блокирует межсетевой экран, 
					           |  антивирусная программа или другое программное обеспечение;
					           |- сервер отключен или на техническом обслуживании.'"),
					АдресСервераРесурса));
				
				ЖурналТрассировки = ЖурналТрассировкиМаршрутаСервера(АдресСервераРесурса);
				Журнал.Добавить("3) " + ЖурналТрассировки);
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	ОписаниеОшибки = СтрСоединить(Описание, Символы.ПС);
	
	Журнал.Вставить(0);
	Журнал.Вставить(0, ОписаниеОшибки);
	
	ЖурналДиагностики = СтрСоединить(Журнал, Символы.ПС);
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	ЗаписьЖурналаРегистрации(
		НСтр("ru = 'Диагностика соединения'", КодОсновногоЯзыка()),
		УровеньЖурналаРегистрации.Ошибка,,, ЖурналДиагностики);
#Иначе
	ЖурналРегистрацииКлиент.ДобавитьСообщениеДляЖурналаРегистрации(
		НСтр("ru = 'Диагностика соединения'", КодОсновногоЯзыка()),
		"Ошибка", ЖурналДиагностики,, Истина);
#КонецЕсли
	
	Результат = Новый Структура;
	Результат.Вставить("ОписаниеОшибки", ОписаниеОшибки);
	Результат.Вставить("ЖурналДиагностики", ЖурналДиагностики);
	
	Возврат Результат;
	
#КонецЕсли
	
КонецФункции

// Создает объект описания защищенного соединения OpenSSL.
// Параметры:
//  СертификатКлиента - СертификатКлиентаФайл, 
//                      СертификатКлиентаWindows, 
//                      Неопределено - ЗащищенноеСоединениеOpenSSL.
//  СертификатыУдостоверяющихЦентров - СертификатыУдостоверяющихЦентровФайл, 
//                                     СертификатыУдостоверяющихЦентровWindows, 
//                                     СертификатыУдостоверяющихЦентровLinux, 
//                                     СертификатыУдостоверяющихЦентровОС, 
//                                     Неопределено - ЗащищенноеСоединениеOpenSSL.
//
// Возвращаемое значение:
//  ЗащищенноеСоединениеOpenSSL - описание защищенного соединения.
//
Функция НовоеЗащищенноеСоединение(СертификатКлиента = Неопределено, СертификатыУдостоверяющихЦентров = Неопределено) Экспорт
	
#Если ВебКлиент Тогда
	Возврат Неопределено;
#ИначеЕсли МобильныйКлиент Тогда 
	Возврат Новый ЗащищенноеСоединениеOpenSSL;
#Иначе
	Возврат Новый ЗащищенноеСоединениеOpenSSL(СертификатКлиента, СертификатыУдостоверяющихЦентров);
#КонецЕсли
	
КонецФункции

// Возвращает кодировку стандартных поток вывода и ошибок, используемую в текущей ОС.
//
// Возвращаемое значение:
//  КодировкаТекста - кодировка стандартных потоков вывода и ошибок.
//
Функция КодировкаСтандартныхПотоков()
	
	СистемнаяИнформация = Новый СистемнаяИнформация();
	Если (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86) 
		Или (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64) Тогда
		
		Кодировка = КодировкаТекста.OEM;
	Иначе
		Кодировка = КодировкаТекста.Системная;
	КонецЕсли;
	
	Возврат Кодировка;
	
КонецФункции

Процедура УдалитьВременныйФайл(ПолноеИмяФайла)
	
	Если ПустаяСтрока(ПолноеИмяФайла) Тогда
		Возврат;
	КонецЕсли;
		
	Попытка
		УдалитьФайлы(ПолноеИмяФайла);
	Исключение
#Если Сервер Тогда
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Базовая функциональность'", КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Предупреждение,,, 
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Не удалось удалить временный файл
				           |%1 по причине: %2'"), 
				ПолноеИмяФайла, 
				КраткоеПредставлениеОшибки(ИнформацияОбОшибке())));
#КонецЕсли
	КонецПопытки;
	
КонецПроцедуры

#Область ДиагностикаСоединения

#Если Не ВебКлиент Тогда

Функция ПредставлениеМестаДиагностики()
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	Если ОбщегоНазначения.РазделениеВключено() Тогда
		Возврат НСтр("ru = 'Подключение проводится на сервере 1С:Предприятия в интернете.'");
	Иначе 
		Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
			Если КлиентПодключенЧерезВебСервер() Тогда 
				Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Подключение проводится из файловой базы на веб-сервере <%1>.'"), ИмяКомпьютера());
			Иначе 
				Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Подключение проводится из файловой базы на компьютере <%1>.'"), ИмяКомпьютера());
			КонецЕсли;
		Иначе
			Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Подключение проводится на сервере 1С:Предприятие <%1>.'"), ИмяКомпьютера());
		КонецЕсли;
	КонецЕсли;
#Иначе 
	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Подключение проводится на компьютере (клиенте) <%1>.'"), ИмяКомпьютера());
#КонецЕсли
	
КонецФункции

#КонецЕсли

#КонецОбласти

Функция ПроверитьДоступностьСервера(АдресСервера)
	
	ПараметрыЗапускаПрограммы = ПараметрыЗапускаПрограммы();
	ПараметрыЗапускаПрограммы.ДождатьсяЗавершения = Истина;
	ПараметрыЗапускаПрограммы.ПолучитьПотокВывода = Истина;
	ПараметрыЗапускаПрограммы.ПолучитьПотокОшибок = Истина;
	
	СистемнаяИнформация = Новый СистемнаяИнформация();
	ЭтоWindows = (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86) 
		Или (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64);
		
	Если ЭтоWindows Тогда
		ШаблонКоманды = "ping %1 -n 2 -w 500";
	Иначе
		ШаблонКоманды = "ping -c 2 -w 500 %1";
	КонецЕсли;
	
	СтрокаКоманды = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонКоманды, АдресСервера);
	
	Результат = ЗапуститьПрограмму(СтрокаКоманды, ПараметрыЗапускаПрограммы);
	
	// Разные операционные системы могут выводить ошибки в разные потоки:
	// - для Windows все всегда в потоке вывода;
	// - для Debian или RHEL ошибки падают в поток ошибок.
	ЖурналДоступности = Результат.ПотокВывода + Результат.ПотокОшибок;
	
	Если ЭтоWindows Тогда
		ФактНедоступности = (СтрНайти(ЖурналДоступности, "Заданный узел недоступен") > 0)
			Или (СтрНайти(ЖурналДоступности, "Destination host unreachable") > 0);
		
		БезПотерь = (СтрНайти(ЖурналДоступности, "(0% потерь)") > 0)
			Или (СтрНайти(ЖурналДоступности, "(0% loss)") > 0);
	Иначе 
		ФактНедоступности = (СтрНайти(ЖурналДоступности, "Destination Host Unreachable") > 0);
		БезПотерь = (СтрНайти(ЖурналДоступности, "0% packet loss") > 0)
	КонецЕсли;
	
	Доступен = Не ФактНедоступности И БезПотерь;
	СостояниеДоступности = ?(Доступен, НСтр("ru = 'доступен'"), НСтр("ru = 'не доступен'"));
	
	Журнал = Новый Массив;
	Журнал.Добавить(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Удаленный сервер %1 %2:'"), 
		АдресСервера, 
		СостояниеДоступности));
	
	Журнал.Добавить("> " + СтрокаКоманды);
	Журнал.Добавить(ЖурналДоступности);
	
	Возврат Новый Структура("Доступен, ЖурналДиагностики", Доступен, СтрСоединить(Журнал, Символы.ПС));
	
КонецФункции

Функция ЖурналТрассировкиМаршрутаСервера(АдресСервера)
	
	ПараметрыЗапускаПрограммы = ПараметрыЗапускаПрограммы();
	ПараметрыЗапускаПрограммы.ДождатьсяЗавершения = Истина;
	ПараметрыЗапускаПрограммы.ПолучитьПотокВывода = Истина;
	ПараметрыЗапускаПрограммы.ПолучитьПотокОшибок = Истина;
	
	СистемнаяИнформация = Новый СистемнаяИнформация();
	ЭтоWindows = (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86) 
		Или (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64);
	
	Если ЭтоWindows Тогда
		ШаблонКоманды = "tracert -w 100 -h 15 %1";
	Иначе 
		// Если вдруг пакет traceroute не установлен - в потоке вывода будет ошибка.
		// Т.к. результат все равно не разбирается, на поток вывода можно не обращать внимания.
		// По нему администратор поймет что ему надо доставить.
		ШаблонКоманды = "traceroute -w 100 -m 100 %1";
	КонецЕсли;
	
	СтрокаКоманды = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонКоманды, АдресСервера);
	
	Результат = ЗапуститьПрограмму(СтрокаКоманды, ПараметрыЗапускаПрограммы);
	
	Журнал = Новый Массив;
	Журнал.Добавить(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Трассировка маршрута к удаленному серверу %1:'"), АдресСервера));
	
	Журнал.Добавить("> " + СтрокаКоманды);
	Журнал.Добавить(Результат.ПотокВывода);
	Журнал.Добавить(Результат.ПотокОшибок);
	
	Возврат СтрСоединить(Журнал, Символы.ПС);
	
КонецФункции

// Формирует путь к заданной строке НомерСтроки и колонке ИмяРеквизита 
// табличной части ИмяТабличнойЧасти для выдачи сообщений в форме.
// Для совместного использования с процедурой СообщитьПользователю
// (для передачи в параметры Поле или ПутьКДанным). 
//
// Параметры:
//  ИмяТабличнойЧасти - Строка - имя табличной части.
//  НомерСтроки       - Число - номер строки табличной части.
//  ИмяРеквизита      - Строка - имя реквизита.
//
// Возвращаемое значение:
//  Строка.
//
Функция ПутьКТабличнойЧасти(Знач ИмяТабличнойЧасти, Знач НомерСтроки, 
	Знач ИмяРеквизита) Экспорт

	Возврат ИмяТабличнойЧасти + "[" + Формат(НомерСтроки - 1, "ЧН=0; ЧГ=0") + "]." + ИмяРеквизита;

КонецФункции

// Дополняет таблицу значений-приемник данными из таблицы значений-источник.
//
// Параметры:
//  ТаблицаИсточник - ТаблицаЗначений - таблица из которой будут браться строки для заполнения.
//  ТаблицаПриемник - ТаблицаЗначений - таблица в которую будут добавлены строки из таблицы-источника.
//
Процедура ДополнитьТаблицу(ТаблицаИсточник, ТаблицаПриемник) Экспорт
	
	Для каждого СтрокаТаблицыИсточник Из ТаблицаИсточник Цикл
		
		ЗаполнитьЗначенияСвойств(ТаблицаПриемник.Добавить(), СтрокаТаблицыИсточник);
		
	КонецЦикла;
	
КонецПроцедуры

// Дополняет таблицу значений Таблица значениями из массива Массив.
//
// Параметры:
//  Таблица - ТаблицаЗначений - таблица, которую необходимо заполнить значениями из массива.
//  Массив - Массив - массив значений для заполнения таблицы.
//  ИмяПоля - Строка - имя поля таблицы значений, в которое необходимо загрузить значения из массива.
//
Процедура ДополнитьТаблицуИзМассива(Таблица, Массив, ИмяПоля) Экспорт

	Для каждого Значение Из Массив Цикл
		
		Таблица.Добавить()[ИмяПоля] = Значение;
		
	КонецЦикла;
	
КонецПроцедуры

// Снимает один элемент условного оформления, если это список значений
//
// Параметры:
// 	УсловноеОформление - Неопределено - условное оформление элемента формы
// 	ИдентификаторПользовательскойНастройки - Строка - идентификатор настройки
// 	Значение - Произвольный - значение, которое требуется удалить из списка оформления
//
Процедура СнятьУсловноеОформлениеСпискаЗначений(
						УсловноеОформление,
						знач ИдентификаторПользовательскойНастройки,
						знач Значение) Экспорт
	
	Для каждого ЭлементУО Из УсловноеОформление.Элементы Цикл
		Если ЭлементУО.ИдентификаторПользовательскойНастройки = ИдентификаторПользовательскойНастройки Тогда
			Если ЭлементУО.Отбор.Элементы.Количество() = 0 Тогда
				Возврат;
			КонецЕсли;
			ЭлементСписокОтбора = ЭлементУО.Отбор.Элементы[0];
			Если ЭлементСписокОтбора.ПравоеЗначение = Неопределено Тогда
				Возврат;
			КонецЕсли;
			ЭлементСписка = ЭлементСписокОтбора.ПравоеЗначение.НайтиПоЗначению(Значение);
			Если ЭлементСписка <> Неопределено Тогда
				ЭлементСписокОтбора.ПравоеЗначение.Удалить(ЭлементСписка);
			КонецЕсли;
			ЭлементСписокОтбора.ПравоеЗначение = ЭлементСписокОтбора.ПравоеЗначение;
			Возврат;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Удаляет одно значение из массива.
//
// Параметры:
//  Массив - массив, из которого необходимо удалить значение.
//  Значение - удаляемое значение из массива.
//
Процедура УдалитьЗначениеИзМассива(Массив, Значение) Экспорт
	
	Индекс = Массив.Найти(Значение);
	
	Если Индекс <> Неопределено Тогда
		
		Массив.Удалить(Индекс);
		
	КонецЕсли;
	
КонецПроцедуры

// Удаляет повторяющиеся элементы массива.
//
// Параметры:
//  Массив - Массив - массив произвольных значений.
//
// Возвращаемое значение:
//  Массив - коллекция уникальных элементов.
//
Функция СвернутьМассив(Массив) Экспорт
	Результат = Новый Массив;
	ДополнитьМассив(Результат, Массив, Истина);
	Возврат Результат;
КонецФункции

// Вычисляет разность массивов. Разностью массивов А и В является массив, содержащий
// все элементы массива А, не существующие в массиве В.
//
// Параметры:
//  Массив - Массив - массив элементов, из которого необходимо выполнить вычитание;
//  МассивВычитания - Массив - массив элементов, который будет вычитаться.
// 
// Возвращаемое значение:
//  Массив - дополнение массива В до А.
//
// Пример:
//	//А = [1, 3, 5, 7];
//	//В = [3, 7, 9];
//	Результат = РазностьМассивов(А, В);
//	//Результат = [1, 5];
//
Функция РазностьМассивов(Массив, МассивВычитания) Экспорт
	
	Результат = Новый Массив;
	
	Для Каждого Элемент Из Массив Цикл
		
		Если МассивВычитания.Найти(Элемент) = Неопределено Тогда
			
			Результат.Добавить(Элемент);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Удаляет все вхождения переданного значения из массива.
//
// Параметры:
//  Массив - массив, из которого необходимо удалить значение.
//  Значение - удаляемое значение из массива.
//
Процедура УдалитьВсеВхожденияЗначенияИзМассива(Массив, Значение) Экспорт
	
	КолвоЭлементовКоллекции = Массив.Количество();
	
	Для ОбратныйИндекс = 1 По КолвоЭлементовКоллекции Цикл
		
		Индекс = КолвоЭлементовКоллекции - ОбратныйИндекс;
		
		Если Массив[Индекс] = Значение Тогда
			
			Массив.Удалить(Индекс);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Удаляет все вхождения значений указанного типа.
//
// Параметры:
//  Массив - Массив - массив, из которого необходимо удалить значения;
//  Тип - Тип - тип значений, которые подлежат удалению из массива.
//
Процедура УдалитьВсеВхожденияТипаИзМассива(Массив, Тип) Экспорт
	
	КолвоЭлементовКоллекции = Массив.Количество();
	
	Для ОбратныйИндекс = 1 По КолвоЭлементовКоллекции Цикл
		
		Индекс = КолвоЭлементовКоллекции - ОбратныйИндекс;
		
		Если ТипЗнч(Массив[Индекс]) = Тип Тогда
			
			Массив.Удалить(Индекс);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Заполняет коллекцию-приемник значениями из коллекции-источник.
// В качестве коллекций источника и приемника могут выступать типы:
// ТаблицаЗначений; ДеревоЗначений; СписокЗначений и пр.
//
// Параметры:
//  КоллекцияИсточник - коллекция значений, которая является источником для заполнения данных.
//  КоллекцияПриемник - коллекция значений, которая является приемником для заполнения данных.
//
Процедура ЗаполнитьКоллекциюСвойств(КоллекцияИсточник, КоллекцияПриемник) Экспорт
	
	Для Каждого Элемент Из КоллекцияИсточник Цикл
		
		ЗаполнитьЗначенияСвойств(КоллекцияПриемник.Добавить(), Элемент);
		
	КонецЦикла;
	
КонецПроцедуры

// Вычитает один массив элементов из другого массива. Возвращает результат вычитания
//
// Параметры:
//  Массив			 - Массив	 - массив элементов, из которого необходимо выполнить вычитание
//  МассивВычитания	 - Массив	 - массив элементов, который будет вычитаться
// 
// Возвращаемое значение:
//  Массив - результат вычитания двух массивов
//
Функция СократитьМассив(Массив, МассивВычитания) Экспорт
	
	Результат = Новый Массив;
	
	Для Каждого Элемент Из Массив Цикл
		
		Если МассивВычитания.Найти(Элемент) = Неопределено Тогда
			
			Результат.Добавить(Элемент);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Преобразует РасписаниеРегламентногоЗадания в структуру.
//
// Параметры:
//  Расписание - РасписаниеРегламентногоЗадания
// 
// Возвращаемое значение:
//  Структура.
//
Функция РасписаниеВСтруктуру(Знач Расписание) Экспорт
	
	ЗначениеРасписания = Расписание;
	Если ЗначениеРасписания = Неопределено Тогда
		ЗначениеРасписания = Новый РасписаниеРегламентногоЗадания();
	КонецЕсли;
	СписокПолей = "ВремяЗавершения,ВремяКонца,ВремяНачала,ДатаКонца,ДатаНачала,ДеньВМесяце,ДеньНеделиВМесяце," + 
		"ДниНедели,ИнтервалЗавершения,Месяцы,ПаузаПовтора,ПериодНедель,ПериодПовтораВТечениеДня,ПериодПовтораДней";
	Результат = Новый Структура(СписокПолей);
	ЗаполнитьЗначенияСвойств(Результат, ЗначениеРасписания, СписокПолей);
	ДетальныеРасписанияДня = Новый Массив;
	Для каждого РасписаниеДля Из Расписание.ДетальныеРасписанияДня Цикл
		ДетальныеРасписанияДня.Добавить(РасписаниеВСтруктуру(РасписаниеДля));
	КонецЦикла;
	Результат.Вставить("ДетальныеРасписанияДня", ДетальныеРасписанияДня);
	Возврат Результат;
	
КонецФункции		

// Преобразует структуру в РасписаниеРегламентногоЗадания.
//
// Параметры:
//  СтруктураРасписания - Структура
// 
// Возвращаемое значение:
//  РасписаниеРегламентногоЗадания.
//
Функция СтруктураВРасписание(Знач СтруктураРасписания) Экспорт
	
	Если СтруктураРасписания = Неопределено Тогда
		Возврат Новый РасписаниеРегламентногоЗадания();
	КонецЕсли;
	СписокПолей = "ВремяЗавершения,ВремяКонца,ВремяНачала,ДатаКонца,ДатаНачала,ДеньВМесяце,ДеньНеделиВМесяце," + 
		"ДниНедели,ИнтервалЗавершения,Месяцы,ПаузаПовтора,ПериодНедель,ПериодПовтораВТечениеДня,ПериодПовтораДней";
	Результат = Новый РасписаниеРегламентногоЗадания;
	ЗаполнитьЗначенияСвойств(Результат, СтруктураРасписания, СписокПолей);
	ДетальныеРасписанияДня = Новый Массив;
	Для каждого Расписание Из СтруктураРасписания.ДетальныеРасписанияДня Цикл
		  ДетальныеРасписанияДня.Добавить(СтруктураВРасписание(Расписание));
	КонецЦикла;
	Результат.ДетальныеРасписанияДня = ДетальныеРасписанияДня;  
	Возврат Результат;
	
КонецФункции		

// Создает полную копию структуры, соответствия, массива, списка или таблицы значений, рекурсивно, 
// с учетом типов дочерних элементов. При этом содержимое значений объектных типов 
// (СправочникОбъект, ДокументОбъект и т.п.) не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  Источник - Структура, Соответствие, Массив, СписокЗначений, ТаблицаЗначений - объект, который необходимо 
//             скопировать.
//
// Возвращаемое значение:
//  Структура, Соответствие, Массив, СписокЗначений, ТаблицаЗначений - копия объекта, переданного в параметре Источник.
//
Функция СкопироватьРекурсивно(Источник) Экспорт
	
	Перем Приемник;
	
	ТипИсточника = ТипЗнч(Источник);
	Если ТипИсточника = Тип("Структура") Тогда
		Приемник = СкопироватьСтруктуру(Источник);
	ИначеЕсли ТипИсточника = Тип("Соответствие") Тогда
		Приемник = СкопироватьСоответствие(Источник);
	ИначеЕсли ТипИсточника = Тип("Массив") Тогда
		Приемник = СкопироватьМассив(Источник);
	ИначеЕсли ТипИсточника = Тип("СписокЗначений") Тогда
		Приемник = СкопироватьСписокЗначений(Источник);
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	ИначеЕсли ТипИсточника = Тип("ТаблицаЗначений") Тогда
		Приемник = Источник.Скопировать();
#КонецЕсли
	Иначе
		Приемник = Источник;
	КонецЕсли;
	
	Возврат Приемник;
	
КонецФункции

// Создает новый экземпляр объекта Структура, заполняет объект данными указанной структуры
//
// Параметры:
//  СтруктураИсточник	 - Структура	 - структура, копию которой необходимо получить
// 
// Возвращаемое значение:
//  Структура.
//
Функция СкопироватьСтруктуру(СтруктураИсточник) Экспорт
	
	СтруктураРезультат = Новый Структура;
	
	Для Каждого Элемент Из СтруктураИсточник Цикл
		
		Если ТипЗнч(Элемент.Значение) = Тип("СписокЗначений") Тогда
			СтруктураРезультат.Вставить(Элемент.Ключ, Элемент.Значение.Скопировать());
		Иначе
			СтруктураРезультат.Вставить(Элемент.Ключ, Элемент.Значение);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат СтруктураРезультат;
	
КонецФункции

// Создает копию значения типа Соответствие, рекурсивно, с учетом типов значений.
// Если значения соответствия содержат значения объектных типов (СправочникОбъект, ДокументОбъект и т.п.),
// то их содержимое не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  СоответствиеИсточник - Соответствие - соответствие, копию которого необходимо получить.
// 
// Возвращаемое значение:
//  Соответствие - копия исходного соответствия.
//
Функция СкопироватьСоответствие(СоответствиеИсточник) Экспорт
	
	СоответствиеРезультат = Новый Соответствие;
	
	Для Каждого КлючИЗначение Из СоответствиеИсточник Цикл
		СоответствиеРезультат.Вставить(КлючИЗначение.Ключ, СкопироватьРекурсивно(КлючИЗначение.Значение));
	КонецЦикла;
	
	Возврат СоответствиеРезультат;

КонецФункции

// Создает копию значения типа Массив, рекурсивно, с учетом типов значений элементов массива.
// Если элементы массива содержат значения объектных типов (СправочникОбъект, ДокументОбъект и т.п.),
// то их содержимое не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  МассивИсточник - Массив - массив, копию которого необходимо получить.
// 
// Возвращаемое значение:
//  Массив - копия исходного массива.
//
Функция СкопироватьМассив(МассивИсточник) Экспорт
	
	МассивРезультат = Новый Массив;
	
	Для Каждого Элемент Из МассивИсточник Цикл
		МассивРезультат.Добавить(СкопироватьРекурсивно(Элемент));
	КонецЦикла;
	
	Возврат МассивРезультат;
	
КонецФункции

// Создает копию значения типа СписокЗначений, рекурсивно, с учетом типов его значений.
// Если в списке значений есть значения объектных типов (СправочникОбъект, ДокументОбъект и т.п.),
// то их содержимое не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  СписокИсточник - СписокЗначений - список значений, копию которого необходимо получить.
// 
// Возвращаемое значение:
//  СписокЗначений - копия исходного списка значений.
//
Функция СкопироватьСписокЗначений(СписокИсточник) Экспорт
	
	СписокРезультат = Новый СписокЗначений;
	
	Для Каждого ЭлементСписка Из СписокИсточник Цикл
		СписокРезультат.Добавить(
			СкопироватьРекурсивно(ЭлементСписка.Значение), 
			ЭлементСписка.Представление, 
			ЭлементСписка.Пометка, 
			ЭлементСписка.Картинка);
	КонецЦикла;
	
	Возврат СписокРезультат;
	
КонецФункции

// Создает массив и помещает в него переданное значение.
//
// Параметры:
//  Значение - Произвольный - любое значение.
//
// Возвращаемое значение:
//  Массив - массив из одного элемента.
//
Функция ЗначениеВМассиве(Значение) Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Значение);
	
	Возврат Массив;
	
КонецФункции


// Функция выполняет поиск элемента в коллекции: списке значений или массиве.
//
Функция НайтиВСписке(Список, Элемент)
	
	Перем ЭлементВСписке;
	
	Если ТипЗнч(Список) = Тип("СписокЗначений") Тогда
		Если ТипЗнч(Элемент) = Тип("ЭлементСпискаЗначений") Тогда
			ЭлементВСписке = Список.НайтиПоЗначению(Элемент.Значение);
		Иначе
			ЭлементВСписке = Список.НайтиПоЗначению(Элемент);
		КонецЕсли;
	КонецЕсли;
	
	Если ТипЗнч(Список) = Тип("Массив") Тогда
		ЭлементВСписке = Список.Найти(Элемент);
	КонецЕсли;
	
	Возврат ЭлементВСписке;
	
КонецФункции // ЭлементПрисутствуетВСписке

// Сравнивает элементы списков значений или массивов по значениям.
//
// Параметры:
//  Список1 - Неопределено
//  Список2 - Неопределено
//
// Возвращаемое значение:
//  Неопределено.
//
Функция СпискиЗначенийИдентичны(Список1, Список2) Экспорт
	
	СпискиИдентичны = Истина;
	
	Для Каждого ЭлементСписка1 Из Список1 Цикл
		Если НайтиВСписке(Список2, ЭлементСписка1) = Неопределено Тогда
			СпискиИдентичны = Ложь;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если СпискиИдентичны Тогда
		Для Каждого ЭлементСписка2 Из Список2 Цикл
			Если НайтиВСписке(Список1, ЭлементСписка2) = Неопределено Тогда
				СпискиИдентичны = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат СпискиИдентичны;
	
КонецФункции // СпискиЗначенийИдентичны

// Возвращает шаблон структуры параметров для установки внешнего соединения.
// Параметрам необходимо задать требуемые значения и передать
// в метод ОбщегоНазначения.УстановитьВнешнееСоединение().
//
// Возвращаемое значение:
//  Неопределено.
//
Функция СтруктураПараметровДляУстановкиВнешнегоСоединения() Экспорт
	
	СтруктураПараметров = Новый Структура;
	СтруктураПараметров.Вставить("ВариантРаботыИнформационнойБазы", 0);
	СтруктураПараметров.Вставить("КаталогИнформационнойБазы", "");
	СтруктураПараметров.Вставить("ИмяСервера1СПредприятия", "");
	СтруктураПараметров.Вставить("ИмяИнформационнойБазыНаСервере1СПредприятия", "");
	СтруктураПараметров.Вставить("АутентификацияОперационнойСистемы", Ложь);
	СтруктураПараметров.Вставить("ИмяПользователя", "");
	СтруктураПараметров.Вставить("ПарольПользователя", "");
	
	Возврат СтруктураПараметров;
КонецФункции

// Получает идентификатор (метод ПолучитьИдентификатор()) строки дерева значений для заданного значения поля строки
// дерева.
// Используется для позиционирования курсора в иерархических списках.
// 
// Параметры:
//  ИмяПоля - Строка
//  ИдентификаторСтроки - Неопределено
//  КоллекцияЭлементовДерева - Неопределено
//  КлючСтроки - Неопределено
//  ПрекратитьПоиск - Неопределено
//
Процедура ПолучитьИдентификаторСтрокиДереваПоЗначениюПоля(ИмяПоля, ИдентификаторСтроки, КоллекцияЭлементовДерева, КлючСтроки, ПрекратитьПоиск) Экспорт
	
	Для Каждого СтрокаДерева Из КоллекцияЭлементовДерева Цикл
		
		Если ПрекратитьПоиск Тогда
			Возврат;
		КонецЕсли;
		
		Если СтрокаДерева[ИмяПоля] = КлючСтроки Тогда
			
			ИдентификаторСтроки = СтрокаДерева.ПолучитьИдентификатор();
			
			ПрекратитьПоиск = Истина;
			
			Возврат;
			
		КонецЕсли;
		
		КоллекцияЭлементов = СтрокаДерева.ПолучитьЭлементы();
		
		Если КоллекцияЭлементов.Количество() > 0 Тогда
			
			ПолучитьИдентификаторСтрокиДереваПоЗначениюПоля(ИмяПоля, ИдентификаторСтроки, КоллекцияЭлементов, КлючСтроки, ПрекратитьПоиск);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Заменяет недопустимые символы в XML-строке на заданные символы
//
// Параметры:
//  Текст		 - Строка	 - строка, в которой требуется выполнить замену недопустимых символов
//  СимволЗамены - Строка	 - строка, на которую требуется выполнить замену недопустимого символа в XML-строке
// 
// Возвращаемое значение:
//  Строка - cтрока, полученная заменой недопустимых символов в XML-строке.
//
Функция ЗаменитьНедопустимыеСимволыXML(Знач Текст, СимволЗамены = " ") Экспорт
	
#Если НЕ ВебКлиент И НЕ МобильныйКлиент Тогда
	ПозицияНачала = 1;
	Пока Истина Цикл
		Позиция = НайтиНедопустимыеСимволыXML(Текст, ПозицияНачала);
		Если Позиция = 0 Тогда
			Прервать;
		КонецЕсли;
		// Если возращается позиция, больше чем должна быть, то корректируем ее.
		Если Позиция > 1 Тогда
			НедопустимыйСимвол = Сред(Текст, Позиция - 1, 1);
			Если НайтиНедопустимыеСимволыXML(НедопустимыйСимвол) > 0 Тогда
				Текст = СтрЗаменить(Текст, НедопустимыйСимвол, СимволЗамены);
			КонецЕсли;
		КонецЕсли;
		НедопустимыйСимвол = Сред(Текст, Позиция, 1);
		Если НайтиНедопустимыеСимволыXML(НедопустимыйСимвол) > 0 Тогда
			Текст = СтрЗаменить(Текст, НедопустимыйСимвол, СимволЗамены);
		КонецЕсли;
		ПозицияНачала = Позиция + 1;
	КонецЦикла;
#КонецЕсли

	Возврат Текст;
КонецФункции

// Удаляет недопустимые символы в XML-строке
//
// Параметры:
//  Текст	 - Строка	 - строка, в которой требуется удалить недопустимые символы
// 
// Возвращаемое значение:
//  Строка - Строка, полученная при удалении недопустимых символов в XML-строке
//
Функция УдалитьНедопустимыеСимволыXML(Знач Текст) Экспорт
	
	Возврат ЗаменитьНедопустимыеСимволыXML(Текст, "");
	
КонецФункции

// Сравнивает расписания между собой
//
// Параметры:
// 	Расписание1 - Неопределено - РасписаниеРегламентногоЗадания 
//	Расписание2 - Неопределено - РасписаниеРегламентногоЗадания
//
// Возвращаемое значение:
//  Булево - истина, если расписания идентичны, иначе ложь
//
Функция РасписанияОдинаковые(Знач Расписание1, Знач Расписание2) Экспорт
	Расписание1 = РасписаниеВСтруктуру(Расписание1);
	Расписание2 = РасписаниеВСтруктуру(Расписание2);
	
	Для Каждого РеквизитРасписания Из Расписание1 Цикл
		Если ТипЗнч(РеквизитРасписания.Значение) <> Тип("Массив") Тогда
			Если РеквизитРасписания.Значение <> Расписание2[РеквизитРасписания.Ключ] Тогда
				Возврат Ложь;
			КонецЕсли;
		Иначе
			Если РеквизитРасписания.Значение.Количество() <> Расписание2[РеквизитРасписания.Ключ].Количество() Тогда
				Возврат Ложь;
			КонецЕсли;
			
			Для НомерЭлемента = 0 По РеквизитРасписания.Значение.Количество()-1 Цикл
				Если РеквизитРасписания.Ключ = "ДетальныеРасписанияДня" Тогда
					Если Не РасписанияОдинаковые(РеквизитРасписания.Значение[НомерЭлемента],Расписание2[РеквизитРасписания.Ключ][НомерЭлемента]) Тогда
						Возврат Ложь;
					КонецЕсли;
				Иначе
					Если РеквизитРасписания.Значение[НомерЭлемента] <> Расписание2[РеквизитРасписания.Ключ][НомерЭлемента] Тогда
						Возврат Ложь;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
КонецФункции

// Функция ПреобразоватьСтрокуВДату.
//
// Параметры:
//  ПредставлениеДаты - Неопределено
//
// Возвращаемое значение:
//  Неопределено.
//
Функция ПреобразоватьСтрокуВДату(Знач ПредставлениеДаты) Экспорт 
	ПредставлениеДаты = СтрЗаменить(ПредставлениеДаты, "-", "."); 
	ПредставлениеДаты = СтрЗаменить(ПредставлениеДаты, "/", "."); 
	ПредставлениеДаты = СтрЗаменить(ПредставлениеДаты, "\", "."); 
	
		
	ПозицияПробела = СтрНайти(ПредставлениеДаты, " ", НаправлениеПоиска.СНачала);
	Если ПозицияПробела > 0 Тогда
		ПредставлениеДаты = Лев(ПредставлениеДаты, ПозицияПробела - 1);
	КонецЕсли;
	ПредставлениеДаты = СокрЛП(СтрЗаменить(ПредставлениеДаты, ".", ""));
	ПредставлениеДаты = Сред(ПредставлениеДаты, 5) + Сред(ПредставлениеДаты, 3, 2) + Лев(ПредставлениеДаты, 2);
	Если СтрДлина(ПредставлениеДаты) = 6 Тогда
		ПредставлениеДаты = "20" + ПредставлениеДаты;
	КонецЕсли;
	
	ОписаниеТипа = Новый ОписаниеТипов("Дата");
	Результат    = ОписаниеТипа.ПривестиЗначение(ПредставлениеДаты);
	
	Возврат Результат;
КонецФункции

// Добавляет к переданному пути каталога конечный символ-разделитель, если он отсутствует
//
// Параметры:
//  ПутьКаталога - Строка - путь к каталогу
//	Удалить_Платформа - Булево - По умолчанию Неопределено
//
// Возвращаемое значение:
//  Строка - путь к каталогу с конечным символом-разделителем.
//
// Пример:
//  Результат = ДобавитьКонечныйРазделительПути("C:\Мой каталог"); // возвращает "C:\Мой каталог\".
//  Результат = ДобавитьКонечныйРазделительПути("C:\Мой каталог\"); // возвращает "C:\Мой каталог\".
//  Результат = ДобавитьКонечныйРазделительПути("%APPDATA%"); // возвращает "%APPDATA%\".
//
Функция ДобавитьКонечныйРазделительПути(Знач ПутьКаталога, Знач Удалить_Платформа = Неопределено) Экспорт
	Если ПустаяСтрока(ПутьКаталога) Тогда
		Возврат ПутьКаталога;
	КонецЕсли;
	
	ДобавляемыйСимвол = ПолучитьРазделительПути();
	
	Если СтрЗаканчиваетсяНа(ПутьКаталога, ДобавляемыйСимвол) Тогда
		Возврат ПутьКаталога;
	Иначе 
		Возврат ПутьКаталога + ДобавляемыйСимвол;
	КонецЕсли;
КонецФункции

// Составляет полное имя файла из имени каталога и имени файла.
//
// Параметры:
//  ИмяКаталога  - Строка - путь к каталогу файла на диске.
//  ИмяФайла     - Строка - имя файла, без имени каталога.
//
// Возвращаемое значение:
// 	Строка - полное имя файла с учетом каталога.
//
Функция ПолучитьПолноеИмяФайла(Знач ИмяКаталога, Знач ИмяФайла) Экспорт

	Если НЕ ПустаяСтрока(ИмяФайла) Тогда
		
		Слэш = "";
		Если (Прав(ИмяКаталога, 1) <> "\") И (Прав(ИмяКаталога, 1) <> "/") Тогда
			Слэш = ?(Найти(ИмяКаталога, "\") = 0, "/", "\");
		КонецЕсли;
		
		Возврат ИмяКаталога + Слэш + ИмяФайла;
		
	Иначе
		
		Возврат ИмяКаталога;
		
	КонецЕсли;

КонецФункции

// Преобразует расширение файла в нижний регистр без точки.
//
// Параметры:
//  Расширение - Строка. Расширение для преобразования.
//
// Возвращаемое значение:
//  Строка.
//
Функция РасширениеБезТочки(Знач Расширение) Экспорт
	
	Расширение = НРег(СокрЛП(Расширение));
	
	Если Сред(Расширение, 1, 1) = "." Тогда
		Расширение = Сред(Расширение, 2);
	КонецЕсли;
	
	Возврат Расширение;
	
КонецФункции

// Возвращает строку недопустимых символов.
//
// Возвращаемое значение:
//   Строка - строка недопустимых символов.
//
Функция ПолучитьНедопустимыеСимволыВИмениФайла() Экспорт

	НедопустимыеСимволы = """/\[]:;|=,?*<>";
	Возврат НедопустимыеСимволы;

КонецФункции

// Проверяет наличение недопустимых символов в имени файла.
//
// Параметры:
//  ИмяФайла  - Строка 
// Возвращаемое значение:
//   Массив   - массив обнаруженных в имени файла недопустимых символов.
//              Если недопустимых символов не обнаружено возвращается пустой массив.
Функция НайтиНедопустимыеСимволыВИмениФайла(ИмяФайла) Экспорт

	НедопустимыеСимволы = ПолучитьНедопустимыеСимволыВИмениФайла();
	
	МассивНайденныхНедопустимыхСимволов = Новый Массив;
	
	Для ПозицияСимвола = 1 По СтрДлина(НедопустимыеСимволы) Цикл
		ПроверяемыйСимвол = Сред(НедопустимыеСимволы,ПозицияСимвола,1);
		Если Найти(ИмяФайла,ПроверяемыйСимвол) <> 0 Тогда
			МассивНайденныхНедопустимыхСимволов.Добавить(ПроверяемыйСимвол);
		КонецЕсли;
	КонецЦикла;
	
	Возврат МассивНайденныхНедопустимыхСимволов;

КонецФункции

// Заменяет недопустимые символы в имени файла.
//
// Параметры:
//  ИмяФайла     - Строка - исходное имя файла.
//  НаЧтоМенять  - Строка - строка на которые неоходимо заменить недопустимые символы.
//
// Возвращаемое значение:
//   Строка   - имя файла в котором недопустимые символы заменены.
//
Функция ЗаменитьНедопустимыеСимволыВИмениФайла(ИмяФайла, НаЧтоМенять = " ") Экспорт

	МассивНайденныхНедопустимыхСимволов = НайтиНедопустимыеСимволыВИмениФайла(ИмяФайла);
	Для Каждого НедопустимыйСимвол Из МассивНайденныхНедопустимыхСимволов Цикл
		ИмяФайла = СтрЗаменить(ИмяФайла,НедопустимыйСимвол,НаЧтоМенять);
	КонецЦикла;
	
	Возврат ИмяФайла;

КонецФункции

Функция ЗаменитьСимволыВСтрокеНаПробелы(Строка, ЗаменяемыеСимволы)
	Результат = Строка;
	Для Позиция = 1 По СтрДлина(Символы) Цикл
		Результат = СтрЗаменить(Результат, Сред(ЗаменяемыеСимволы, Позиция, 1), " ");
	КонецЦикла;
	Возврат Результат;
КонецФункции

Функция ЕстьСимволыВНачалеВКонце(Строка, ПроверяемыеСимволы)
	Для Позиция = 1 По СтрДлина(ПроверяемыеСимволы) Цикл
		Символ = Сред(ПроверяемыеСимволы, Позиция, 1);
		СимволНайден = (Лев(Строка,1) = Символ) Или (Прав(Строка,1) = Символ);
		Если СимволНайден Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
КонецФункции

Функция СтрокаСодержитТолькоДопустимыеСимволы(Строка, ДопустимыеСимволы)
	МассивСимволов = Новый Массив;
	Для Позиция = 1 По СтрДлина(ДопустимыеСимволы) Цикл
		МассивСимволов.Добавить(Сред(ДопустимыеСимволы,Позиция,1));
	КонецЦикла;
	
	Для Позиция = 1 По СтрДлина(Строка) Цикл
		Если МассивСимволов.Найти(Сред(Строка, Позиция, 1)) = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
КонецФункции

// Сдвигает маркер позиции пока встречается символ Символ.
// Возвращает номер позиции в строке, на которое установился маркер.
//
Функция ПропуститьПробелы(знач Строка,
                          знач ТекущийИндекс,
                          знач ПропускаемыйСимвол)
	
	Результат = ТекущийИндекс;
	
	// Убираем лишние пробелы если они есть.
	Пока ТекущийИндекс < СтрДлина(Строка) Цикл
		Если Сред(Строка, ТекущийИндекс, 1) <> ПропускаемыйСимвол Тогда
			Возврат ТекущийИндекс;
		КонецЕсли;
		ТекущийИндекс = ТекущийИндекс + 1;
	КонецЦикла;
	
	Возврат ТекущийИндекс;
	
КонецФункции

#Если НЕ ВебКлиент И НЕ МобильныйКлиент Тогда
// Возвращает полный путь к новому каталогу в каталоге временных файлов.
//
// Параметры:
//  Идентификатор - Строка, начальная часть имени каталога во временном каталоге.
//
// Возвращаемое значение:
//  Строка - полное имя временного каталога, например "КаталогВременныхФайлов() + Обработка123\".
//
Функция ПолучитьИмяКаталога(знач Идентификатор) Экспорт
	
	Индекс = 0;
	
	Пока Истина Цикл
		
		ПутьККаталогу = КаталогВременныхФайлов () + Идентификатор + строка(Индекс) + "/";
		КаталогНаДиске = Новый Файл(ПутьККаталогу);
		Если НЕ КаталогНаДиске.Существует() Тогда
			СоздатьКаталог(ПутьККаталогу);
			Возврат ПутьККаталогу;
		КонецЕсли;
		Индекс = Индекс + 1;
		
	КонецЦикла;
	
КонецФункции // ПолучитьИмяКаталога()
#КонецЕсли

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с отборами динамических списков.
//

// Найти элемент или группу отбора по заданному имени поля или представлению.
//
// Параметры:
//  ОбластьПоиска - ОтборКомпоновкиДанных, КоллекцияЭлементовОтбораКомпоновкиДанных,
//                  ГруппаЭлементовОтбораКомпоновкиДанных - контейнер
//                  с элементами и группами отбора, например Список.Отбор или группа в отборе.
//  ИмяПоля       - Строка - имя поля компоновки (не используется для групп).
//  Представление - Строка - представление поля компоновки.
//
// Возвращаемое значение:
//  Массив - коллекция отборов.
//
Функция НайтиЭлементыИГруппыОтбора(Знач ОбластьПоиска,
									Знач ИмяПоля = Неопределено,
									Знач Представление = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;
	
	МассивЭлементов = Новый Массив;
	
	НайтиРекурсивно(ОбластьПоиска.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
	
	Возврат МассивЭлементов;
	
КонецФункции

// Добавление группы отбора
//
// Параметры:
//  КоллекцияЭлементов - Неопределено - контейнер с элементами и группами отбора, например
//                      Список.Отбор.Элементы или группа в отборе
//  ТипГруппы - ТипГруппыЭлементовОтбораКомпоновкиДанных - тип группы
//  Представление - Cтрока - представление группы
//
// Возвращаемое значение:
//  Неопределено.
//
Функция СоздатьГруппуЭлементовОтбора(КоллекцияЭлементов, Представление, ТипГруппы) Экспорт
	
	ГруппаЭлементовОтбора = НайтиЭлементОтбораПоПредставлению(КоллекцияЭлементов, Представление);
	Если ГруппаЭлементовОтбора = Неопределено Тогда
		ГруппаЭлементовОтбора = КоллекцияЭлементов.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
	Иначе
		ГруппаЭлементовОтбора.Элементы.Очистить();
	КонецЕсли;
	
	ГруппаЭлементовОтбора.Представление    = Представление;
	ГруппаЭлементовОтбора.Применение       = ТипПримененияОтбораКомпоновкиДанных.Элементы;
	ГруппаЭлементовОтбора.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
	ГруппаЭлементовОтбора.ТипГруппы        = ТипГруппы;
	ГруппаЭлементовОтбора.Использование    = Истина;
	
	Возврат ГруппаЭлементовОтбора;
	
КонецФункции

// Изменить элемент отбора с заданным именем поля или представлением.
//
// Параметры:
//  ОбластьПоиска - КоллекцияЭлементовОтбораКомпоновкиДанных - контейнер с элементами и группами отбора,
//                                                             например, Список.Отбор или группа в отборе.
//  ИмяПоля                 - Строка - имя поля компоновки данных (заполняется всегда).
//  Представление           - Строка - представление элемента компоновки данных.
//  ПравоеЗначение          - Произвольный - сравниваемое значение.
//  ВидСравнения            - ВидСравненияКомпоновкиДанных - вид сравнения.
//  Использование           - Булево - использование элемента.
//  РежимОтображения        - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения.
//  ИдентификаторПользовательскойНастройки - Строка - см. ОтборКомпоновкиДанных.ИдентификаторПользовательскойНастройки
//                                                    в синтакс-помощнике.
//
// Возвращаемое значение:
//  Число - количество измененных элементов.
//
Функция ИзменитьЭлементыОтбора(ОбластьПоиска,
								Знач ИмяПоля = Неопределено,
								Знач Представление = Неопределено,
								Знач ПравоеЗначение = Неопределено,
								Знач ВидСравнения = Неопределено,
								Знач Использование = Неопределено,
								Знач РежимОтображения = Неопределено,
								Знач ИдентификаторПользовательскойНастройки = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;
	
	МассивЭлементов = Новый Массив;
	
	НайтиРекурсивно(ОбластьПоиска.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
	
	Для Каждого Элемент Из МассивЭлементов Цикл
		Если ИмяПоля <> Неопределено Тогда
			Элемент.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);
		КонецЕсли;
		Если Представление <> Неопределено Тогда
			Элемент.Представление = Представление;
		КонецЕсли;
		Если Использование <> Неопределено Тогда
			Элемент.Использование = Использование;
		КонецЕсли;
		Если ВидСравнения <> Неопределено Тогда
			Элемент.ВидСравнения = ВидСравнения;
		КонецЕсли;
		Если ПравоеЗначение <> Неопределено Тогда
			Элемент.ПравоеЗначение = ПравоеЗначение;
		КонецЕсли;
		Если РежимОтображения <> Неопределено Тогда
			Элемент.РежимОтображения = РежимОтображения;
		КонецЕсли;
		Если ИдентификаторПользовательскойНастройки <> Неопределено Тогда
			Элемент.ИдентификаторПользовательскойНастройки = ИдентификаторПользовательскойНастройки;
		КонецЕсли;
	КонецЦикла;
	
	Возврат МассивЭлементов.Количество();
	
КонецФункции

// Удалить элементы отбора с заданным именем поля или представлением.
//
// Параметры:
//  ОбластьУдаления - КоллекцияЭлементовОтбораКомпоновкиДанных - контейнер с элементами и группами отбора,
//                                                               например, Список.Отбор или группа в отборе.
//  ИмяПоля         - Строка - имя поля компоновки (не используется для групп).
//  Представление   - Строка - представление поля компоновки.
//
Процедура УдалитьЭлементыГруппыОтбора(Знач ОбластьУдаления, Знач ИмяПоля = Неопределено, Знач Представление = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;
	
	МассивЭлементов = Новый Массив;
	
	НайтиРекурсивно(ОбластьУдаления.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
	
	Для Каждого Элемент Из МассивЭлементов Цикл
		Если Элемент.Родитель = Неопределено Тогда
			ОбластьУдаления.Элементы.Удалить(Элемент);
		Иначе
			Элемент.Родитель.Элементы.Удалить(Элемент);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Добавить или заменить существующий элемент отбора.
//
// Параметры:
//  ОбластьПоискаДобавления - КоллекцияЭлементовОтбораКомпоновкиДанных - контейнер с элементами и группами отбора,
//                                     например, Список.Отбор или группа в отборе.
//  ИмяПоля                 - Строка - имя поля компоновки данных (заполняется всегда).
//  ПравоеЗначение          - произвольный - сравниваемое значение.
//  ВидСравнения            - ВидСравненияКомпоновкиДанных - вид сравнения.
//  Представление           - Строка - представление элемента компоновки данных.
//  Использование           - Булево - использование элемента.
//  РежимОтображения        - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения.
//  ИдентификаторПользовательскойНастройки - Строка - см. ОтборКомпоновкиДанных.ИдентификаторПользовательскойНастройки
//                                                    в синтакс-помощнике.
//
Процедура УстановитьЭлементОтбора(ОбластьПоискаДобавления,
								Знач ИмяПоля,
								Знач ПравоеЗначение = Неопределено,
								Знач ВидСравнения = Неопределено,
								Знач Представление = Неопределено,
								Знач Использование = Неопределено,
								Знач РежимОтображения = Неопределено,
								Знач ИдентификаторПользовательскойНастройки = Неопределено) Экспорт
	
	ЧислоИзмененных = ИзменитьЭлементыОтбора(ОбластьПоискаДобавления, ИмяПоля, Представление,
							ПравоеЗначение, ВидСравнения, Использование, РежимОтображения, ИдентификаторПользовательскойНастройки);
	
	Если ЧислоИзмененных = 0 Тогда
		Если ВидСравнения = Неопределено Тогда
			Если ТипЗнч(ПравоеЗначение) = Тип("Массив")
				Или ТипЗнч(ПравоеЗначение) = Тип("ФиксированныйМассив")
				Или ТипЗнч(ПравоеЗначение) = Тип("СписокЗначений") Тогда
				ВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке;
			Иначе
				ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
			КонецЕсли;
		КонецЕсли;
		Если РежимОтображения = Неопределено Тогда
			РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
		КонецЕсли;
		ДобавитьЭлементКомпоновки(ОбластьПоискаДобавления, ИмяПоля, ВидСравнения,
								ПравоеЗначение, Представление, Использование, РежимОтображения, ИдентификаторПользовательскойНастройки);
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает значение Значение параметра ИмяПараметра динамического списка Список 
// или отключает его использование в зависимости от признака Использование.
//
// Параметры:
//  Список - Неопределено
//  ИмяПараметра - Строка
//  Значение - Неопределено
//  Использование - Булево - По умолчанию Истина
//
Процедура УстановитьПараметрДинамическогоСписка(Список, ИмяПараметра, Значение, Использование = Истина) Экспорт
	
	Если Использование Тогда
		Список.Параметры.УстановитьЗначениеПараметра(ИмяПараметра, Значение);
	Иначе
		ЗначениеПараметра = Список.Параметры.НайтиЗначениеПараметра(Новый ПараметрКомпоновкиДанных(ИмяПараметра));
		Если ЗначениеПараметра <> Неопределено Тогда
			ЗначениеПараметра.Значение = Значение;
			ЗначениеПараметра.Использование = Ложь;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры 

// Устанавливает значение реквизиту формы 
//
// Параметры:
// 	Форма - Неопределено
// 	ПутьРеквизита - Строка - путь к данным, например: "Объект.МесяцНачисления"
// 	Значение - Неопределено
// 	ТолькоЕслиНеЗаполнен - Булево - По умолчанию Ложь
//
Процедура УстановитьРеквизитФормыПоПути(Форма, ПутьРеквизита, Значение, ТолькоЕслиНеЗаполнен = Ложь) Экспорт
	
	МассивИмен = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьРеквизита, ".");
	
	Объект        = Форма;
	ПоследнееПоле = МассивИмен[МассивИмен.Количество()-1];
	
	Для Сч = 0 По МассивИмен.Количество()-2 Цикл
		Объект = Объект[МассивИмен[Сч]]
	КонецЦикла;
	Если НЕ ТолькоЕслиНеЗаполнен ИЛИ НЕ ЗначениеЗаполнено(Объект[ПоследнееПоле]) Тогда
		Объект[ПоследнееПоле] = Значение;
	КонецЕсли;
	
КонецПроцедуры

// Выполняет поиск элемента отбора в коллекции по заданному представлению.
//
// Параметры:
//  КоллекцияЭлементов - Неопределено - контейнер с элементами и группами отбора, например
//                      Список.Отбор.Элементы или группа в отборе
//  Представление - Строка - представление группы
// 
// Возвращаемое значение:
//  Неопределено.
//
Функция НайтиЭлементОтбораПоПредставлению(КоллекцияЭлементов, Представление) Экспорт
	
	ВозвращаемоеЗначение = Неопределено;
	
	Для каждого ЭлементОтбора Из КоллекцияЭлементов Цикл
		Если ЭлементОтбора.Представление = Представление Тогда
			ВозвращаемоеЗначение = ЭлементОтбора;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ВозвращаемоеЗначение
	
КонецФункции

// Устанавливает свойство ИмяСвойства элемента формы с именем ИмяЭлемента в значение Значение.
// Применяется в тех случаях, когда элемент формы может не быть на форме из-за отсутствия прав у пользователя
// на объект, реквизит объекта или команду.
//
// Параметры:
//  ЭлементыФормы - свойство ЭлементыФормы управляемой формы.
//  ИмяЭлемента   - Строка       - имя элемента формы.
//  ИмяСвойства   - Строка       - имя устанавливаемого свойства элемента формы.
//  Значение      - Произвольный - новое значение элемента.
//
Процедура УстановитьСвойствоЭлементаФормы(ЭлементыФормы, ИмяЭлемента, ИмяСвойства, Значение) Экспорт

	ЭлементФормы = ЭлементыФормы.Найти(ИмяЭлемента);
	Если ЭлементФормы <> Неопределено  Тогда
		ЭлементФормы[ИмяСвойства] = Значение;
	КонецЕсли;

КонецПроцедуры 

// Возвращает значение свойства ИмяСвойства элемента формы с именем ИмяЭлемента.
// Применяется в тех случаях, когда элемент формы может не быть на форме из-за отсутствия прав у пользователя
// на объект, реквизит объекта или команду.
//
// Параметры:
//  ЭлементыФормы - свойство ЭлементыФормы управляемой формы.
//  ИмяЭлемента   - Строка       - имя элемента формы.
//  ИмяСвойства   - Строка       - имя свойства элемента формы.
// 
// Возвращаемое значение:
//   Произвольный - значение свойства ИмяСвойства элемента формы ИмяЭлемента.
//
Функция ЗначениеСвойстваЭлементаФормы(ЭлементыФормы, ИмяЭлемента, ИмяСвойства) Экспорт

	ЭлементФормы = ЭлементыФормы.Найти(ИмяЭлемента);
	Возврат ?(ЭлементФормы <> Неопределено, ЭлементФормы[ИмяСвойства], Неопределено);

КонецФункции 

////////////////////////////////////////////////////////////////////////////////
// Математические процедуры и функции.

// Выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения.
//
// Параметры:
//  РаспределяемаяСумма - Число  - сумма, которую надо распределить, если сумма равна 0 - то возвращается Неопределено;
//                                 Если передана отрицательная - расчет по модулю и после инверсия знаков результата.
//  Коэффициенты        - Массив - коэффициенты распределения, должны быть положительны или отрицательными одновременно.
//  Точность            - Число  - точность округления при распределении. Необязателен.
//
// Возвращаемое значение:
//  Массив - массив размерностью равный массиву коэффициентов, содержит
//           суммы в соответствии с весом коэффициента (из массива коэффициентов).
//           В случае, если распределить невозможно (кол-во коэффициентов = 0,
//           есть коэффициенты с отрицательным значением или суммарный вес коэффициентов = 0),
//           тогда будет возвращено Неопределено.
//
// Пример:
//
//	Коэффициенты = Новый Массив;
//	Коэффициенты.Добавить(1);
//	Коэффициенты.Добавить(2);
//	Результат = ОбщегоНазначенияКлиентСервер.РаспределитьСуммуПропорциональноКоэффициентам(1, Коэффициенты);
//	// Результат = [0.33, 0.67]
//
Функция РаспределитьСуммуПропорциональноКоэффициентам(Знач РаспределяемаяСумма, Знач Коэффициенты, Знач Точность = 2) Экспорт
	
	КоэффициентыАбсолютные = Новый Массив(Новый ФиксированныйМассив(Коэффициенты)); // cpy
	
	// Старое поведение при неуказанной сумме - для обратной совместимости.
	Если Не ЗначениеЗаполнено(РаспределяемаяСумма) Тогда 
		Возврат Неопределено;
	КонецЕсли;
	
	Если КоэффициентыАбсолютные.Количество() = 0 Тогда 
		// Недопустимо значение параметра Коэффициенты.
		// Ожидалось: хотя бы один коэффициент будет задан.
		Возврат Неопределено;
	КонецЕсли;
	
	ИндексМаксимальногоКоэффициента = 0;
	МаксимальныйКоэффициент = 0;
	СуммаКоэффициентов = 0;
	КоэффициентыОтрицательны = (КоэффициентыАбсолютные[0] < 0);
	
	Для Индекс = 0 По КоэффициентыАбсолютные.Количество() - 1 Цикл
		Коэффициент = КоэффициентыАбсолютные[Индекс];
		
		Если КоэффициентыОтрицательны И Коэффициент > 0 Тогда 
			// Недопустимо значение параметра Коэффициенты.
			// Ожидалось: все коэффициенты положительны или все отрицательны одновременно.
			Возврат Неопределено;
		КонецЕсли;
		
		Если Коэффициент < 0 Тогда 
			Коэффициент = -Коэффициент; // Abs(Коэффициент)
			КоэффициентыАбсолютные[Индекс] = Коэффициент; // move
		КонецЕсли;
		
		Если МаксимальныйКоэффициент < Коэффициент Тогда
			МаксимальныйКоэффициент = Коэффициент;
			ИндексМаксимальногоКоэффициента = Индекс;
		КонецЕсли;
		
		СуммаКоэффициентов = СуммаКоэффициентов + Коэффициент;
	КонецЦикла;
	
	Если СуммаКоэффициентов = 0 Тогда
		// Недопустимо значение параметра Коэффициенты.
		// Ожидалось: хотя бы один коэффициент будет отличен от нуля.
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = Новый Массив(КоэффициентыАбсолютные.Количество());
	
	ВыполнятьИнверсию = (РаспределяемаяСумма < 0);
	Если ВыполнятьИнверсию Тогда 
		РаспределяемаяСумма = -РаспределяемаяСумма; // Abs(РаспределяемаяСумма).
	КонецЕсли;
	
	РаспределеннаяСумма = 0;
	
	Для Индекс = 0 По КоэффициентыАбсолютные.Количество() - 1 Цикл
		Результат[Индекс] = Окр(РаспределяемаяСумма * КоэффициентыАбсолютные[Индекс] / СуммаКоэффициентов, Точность, 1);
		РаспределеннаяСумма = РаспределеннаяСумма + Результат[Индекс];
	КонецЦикла;
	
	СуммарнаяПогрешность = РаспределяемаяСумма - РаспределеннаяСумма;
	
	Если СуммарнаяПогрешность > 0 Тогда 
		
		// Погрешности округления отнесем на коэффициент с максимальным весом.
		Если Не РаспределеннаяСумма = РаспределяемаяСумма Тогда
			Результат[ИндексМаксимальногоКоэффициента] = Результат[ИндексМаксимальногоКоэффициента] + СуммарнаяПогрешность;
		КонецЕсли;
		
	ИначеЕсли СуммарнаяПогрешность < 0 Тогда 
		
		// Если распределили больше чем положено, размазываем погрешность по ближайшим максимальным весам.
		ЗначениеПогрешности = 1 / Pow(10, Точность);
		КоличествоЭлементовПогрешности = -СуммарнаяПогрешность / ЗначениеПогрешности;
		
		Для Сч = 1 По КоличествоЭлементовПогрешности Цикл 
			МаксимальныйКоэффициент = МаксимальноеЗначениеВМассиве(КоэффициентыАбсолютные);
			Индекс = КоэффициентыАбсолютные.Найти(МаксимальныйКоэффициент);
			Результат[Индекс] = Результат[Индекс] - ЗначениеПогрешности;
			КоэффициентыАбсолютные[Индекс] = 0;
		КонецЦикла;
		
	Иначе 
		// Если СуммарнаяПогрешность = 0, то все идеально.
	КонецЕсли;
	
	Если ВыполнятьИнверсию Тогда 
		Для Индекс = 0 По КоэффициентыАбсолютные.Количество() - 1 Цикл
			Результат[Индекс] = -Результат[Индекс];
		КонецЦикла;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Служебные и вспомогательные функции.
//

Процедура НайтиРекурсивно(КоллекцияЭлементов, МассивЭлементов, СпособПоиска, ЗначениеПоиска)
	
	Для каждого ЭлементОтбора Из КоллекцияЭлементов Цикл
		
		Если ТипЗнч(ЭлементОтбора) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
			
			Если СпособПоиска = 1 Тогда
				Если ЭлементОтбора.ЛевоеЗначение = ЗначениеПоиска Тогда
					МассивЭлементов.Добавить(ЭлементОтбора);
				КонецЕсли;
			ИначеЕсли СпособПоиска = 2 Тогда
				Если ЭлементОтбора.Представление = ЗначениеПоиска Тогда
					МассивЭлементов.Добавить(ЭлементОтбора);
				КонецЕсли;
			КонецЕсли;
		Иначе
			
			НайтиРекурсивно(ЭлементОтбора.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
			
			Если СпособПоиска = 2 И ЭлементОтбора.Представление = ЗначениеПоиска Тогда
				МассивЭлементов.Добавить(ЭлементОтбора);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#Если ВебКлиент Или МобильныйКлиент Тогда
// Составляет полное имя файла из имени каталога и имени файла
//
// Параметры:
//  ИмяКаталога  - Строка - содержащая путь к каталогу файла на диске
//  ИмяФайла     - Строка - содержащая имя файла, без имени каталога
//
// Возвращаемое значение:
//	Строка - полное имя файла с учетом каталога.
//
Функция ПолучитьИмяФайла(Знач ИмяКаталога, Знач ИмяФайла) Экспорт

	Если НЕ ПустаяСтрока(ИмяФайла) Тогда
		
		Слэш = "";
		Если (Прав(ИмяКаталога, 1) <> "\") И (Прав(ИмяКаталога, 1) <> "/") Тогда
			Слэш = ?(Найти(ИмяКаталога, "\") = 0, "/", "\");
		КонецЕсли;
		
		Возврат ИмяКаталога + Слэш + ИмяФайла;
		
	Иначе
		
		Возврат ИмяКаталога;
		
	КонецЕсли;

КонецФункции
#КонецЕсли

// Процедура управляет состояние поля табличного документа.
//
// Параметры:
//  ПолеТабличногоДокумента - ПолеФормы - поле формы с видом ПолеТабличногоДокумента,
//                            Для которого необходимо установить состояние.
//  Состояние               - Строка - задает вид состояния.
//
Процедура УстановитьСостояниеПоляТабличногоДокумента(ПолеТабличногоДокумента, Состояние = "НеИспользовать") Экспорт
	
	Если ТипЗнч(ПолеТабличногоДокумента) = Тип("ПолеФормы") 
		И ПолеТабличногоДокумента.Вид = ВидПоляФормы.ПолеТабличногоДокумента Тогда
		ОтображениеСостояния = ПолеТабличногоДокумента.ОтображениеСостояния;
		Если ВРег(Состояние) = "НЕИСПОЛЬЗОВАТЬ" Тогда
			ОтображениеСостояния.Видимость                      = Ложь;
			ОтображениеСостояния.ДополнительныйРежимОтображения = ДополнительныйРежимОтображения.НеИспользовать;
			ОтображениеСостояния.Картинка                       = Новый Картинка;
			ОтображениеСостояния.Текст                          = "";
		ИначеЕсли ВРег(Состояние) = "НЕАКТУАЛЬНОСТЬ" Тогда
			ОтображениеСостояния.Видимость                      = Истина;
			ОтображениеСостояния.ДополнительныйРежимОтображения = ДополнительныйРежимОтображения.Неактуальность;
			ОтображениеСостояния.Картинка                       = Новый Картинка;
			ОтображениеСостояния.Текст                          = НСтр("ru = 'Отчет не сформирован. Нажмите ""Сформировать"" для получения отчета.'");;
		ИначеЕсли ВРег(Состояние) = "ФОРМИРОВАНИЕОТЧЕТА" Тогда  
			ОтображениеСостояния.Видимость                      = Истина;
			ОтображениеСостояния.ДополнительныйРежимОтображения = ДополнительныйРежимОтображения.Неактуальность;
			ОтображениеСостояния.Картинка                       = БиблиотекаКартинок.ДлительнаяОперация48;
			ОтображениеСостояния.Текст                          = НСтр("ru = 'Отчет формируется...'");
		Иначе
			ВызватьИсключение(НСтр("ru = 'Недопустимое значение параметра (параметр номер ''2'')'"));
		КонецЕсли;
	Иначе
		ВызватьИсключение(НСтр("ru = 'Недопустимое значение параметра (параметр номер ''1'')'"));
	КонецЕсли;
	
КонецПроцедуры

// Возвращает Истина, если клиентское приложение подключено к базе через веб-сервер.
// Если нет клиентского приложения, возвращается Ложь.
//
// Возвращаемое значение:
//  Булево - Истина, если подключен.
//
Функция КлиентПодключенЧерезВебСервер() Экспорт
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Тогда
	УстановитьПривилегированныйРежим(Истина);
	
	СтрокаСоединенияИнформационнойБазы = СтандартныеПодсистемыСервер.ПараметрыКлиентаНаСервере().Получить("СтрокаСоединенияИнформационнойБазы");
	
	Если СтрокаСоединенияИнформационнойБазы = Неопределено Тогда
		Возврат Ложь; // Нет клиентского приложения.
	КонецЕсли;
#Иначе
	СтрокаСоединенияИнформационнойБазы = СтрокаСоединенияИнформационнойБазы();
#КонецЕсли
	
	Возврат СтрНайти(ВРег(СтрокаСоединенияИнформационнойБазы), "WS=") = 1;
	
КонецФункции

// Возвращает Истина, если клиентское приложение запущено под управлением ОС Windows.
//
// Возвращаемое значение:
//  Булево - если нет клиентского приложения, возвращается Ложь.
//
Функция ЭтоWindowsКлиент() Экспорт
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Тогда
	УстановитьПривилегированныйРежим(Истина);
	
	ЭтоWindowsКлиент = СтандартныеПодсистемыСервер.ПараметрыКлиентаНаСервере().Получить("ЭтоWindowsКлиент");
	
	Если ЭтоWindowsКлиент = Неопределено Тогда
		Возврат Ложь; // Нет клиентского приложения.
	КонецЕсли;
#Иначе
	СистемнаяИнформация = Новый СистемнаяИнформация;
	
	ЭтоWindowsКлиент = СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86
	             ИЛИ СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64;
#КонецЕсли
	
	Возврат ЭтоWindowsКлиент;
	
КонецФункции

// Возвращает Истина, если клиентское приложение запущено под управлением ОС X.
//
// Возвращаемое значение:
//  Булево - если нет клиентского приложения, возвращается Ложь.
//
Функция ЭтоOSXКлиент() Экспорт
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Тогда
	УстановитьПривилегированныйРежим(Истина);
	
	ЭтоOSXКлиент = СтандартныеПодсистемыСервер.ПараметрыКлиентаНаСервере().Получить("ЭтоOSXКлиент");
	
	Если ЭтоOSXКлиент = Неопределено Тогда
		Возврат Ложь; // Нет клиентского приложения.
	КонецЕсли;
#Иначе
	СистемнаяИнформация = Новый СистемнаяИнформация;
	
	ЭтоOSXКлиент = СистемнаяИнформация.ТипПлатформы = ТипПлатформы.MacOS_x86
	             ИЛИ СистемнаяИнформация.ТипПлатформы = ТипПлатформы.MacOS_x86_64;
#КонецЕсли
	
	Возврат ЭтоOSXКлиент;
	
КонецФункции

// Возвращает Истина, если клиентское приложение запущено под управлением ОС Linux.
//
// Возвращаемое значение:
//  Булево - если нет клиентского приложения, возвращается Ложь.
//
Функция ЭтоLinuxКлиент() Экспорт
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Тогда
	УстановитьПривилегированныйРежим(Истина);
	
	ЭтоLinuxКлиент = СтандартныеПодсистемыСервер.ПараметрыКлиентаНаСервере().Получить("ЭтоLinuxКлиент");
	
	Если ЭтоLinuxКлиент = Неопределено Тогда
		Возврат Ложь; // Нет клиентского приложения.
	КонецЕсли;
#Иначе
	СистемнаяИнформация = Новый СистемнаяИнформация;
	
	ЭтоLinuxКлиент = СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86
	             ИЛИ СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86_64;
#КонецЕсли
	
	Возврат ЭтоLinuxКлиент;
	
КонецФункции

// Возвращает Истина, если клиентское приложение является Веб-клиентом.
//
// Возвращаемое значение:
//  Булево - если нет клиентского приложения, возвращается Ложь.
//
Функция ЭтоВебКлиент() Экспорт
	
#Если ВебКлиент Или МобильныйКлиент Тогда
	Возврат Истина;
#ИначеЕсли Сервер Или ТолстыйКлиентОбычноеПриложение Тогда
	УстановитьПривилегированныйРежим(Истина);
	
	ЭтоВебКлиент = СтандартныеПодсистемыСервер.ПараметрыКлиентаНаСервере().Получить("ЭтоВебКлиент");
	
	Если ЭтоВебКлиент = Неопределено Тогда
		Возврат Ложь; // Нет клиентского приложения.
	КонецЕсли;
	
	Возврат ЭтоВебКлиент;
#Иначе
	Возврат Ложь;
#КонецЕсли
	
КонецФункции

// Устарела. Следует использовать ОбщегоНазначенияКлиент.ЭтоMacOSКлиент с инструкцией препроцессора ВебКлиент,
// или на сервере (ОбщегоНазначения.ЭтоMacOSКлиент И ОбщегоНазначения.ЭтоВебКлиент).
// Возвращает Истина, если это веб-клиент в ОС X.
//
// Возвращаемое значение:
//  Булево - Истина, если сеанс запущен под веб-клиентом и в ОС X.
//
Функция ЭтоВебКлиентПодMacOS() Экспорт
	
#Если ВебКлиент Тогда
	Возврат ОбщегоНазначенияКлиент.ЭтоMacOSКлиент();
#ИначеЕсли Сервер Или ТолстыйКлиентОбычноеПриложение Тогда
	Возврат ЭтоOSXКлиент() И ЭтоВебКлиент();
#Иначе
	Возврат Ложь;
#КонецЕсли
	
КонецФункции

// Возвращает Истина, если включен режим отладки.
//
// Возвращаемое значение:
//  Булево - Истина, если включен режим отладки.
Функция РежимОтладки() Экспорт
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	ПараметрЗапускаПриложения = ПараметрыСеанса.ПараметрыКлиентаНаСервере.Получить("ПараметрЗапуска");
#Иначе
	ПараметрЗапускаПриложения = ПараметрЗапуска;
#КонецЕсли
	
	Возврат СтрНайти(ПараметрЗапускаПриложения, "РежимОтладки") > 0;
КонецФункции

// Дополняет массив МассивПриемник значениями из массива МассивИсточник
//
// Параметры:
//  МассивПриемник - Массив из Неопределено - Массив, в который необходимо добавить значения
//  МассивИсточник - Массив из Неопределено - Массив значений для заполнения,
// 	ТолькоУникальныеЗначения - Булево - необязательный, если истина, 
// 		то в массив будут включены только те значения, которых в нем еще нет, причем единожды
//
Процедура ДополнитьМассив(МассивПриемник, МассивИсточник, ТолькоУникальныеЗначения = Ложь) Экспорт

	УникальныеЗначения = Новый Соответствие;
	
	Если ТолькоУникальныеЗначения Тогда
		Для каждого Значение Из МассивПриемник Цикл
			УникальныеЗначения.Вставить(Значение, Истина);
		КонецЦикла;
	КонецЕсли;
	
	Для каждого Значение Из МассивИсточник Цикл
		Если ТолькоУникальныеЗначения И УникальныеЗначения[Значение] <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		МассивПриемник.Добавить(Значение);
		УникальныеЗначения.Вставить(Значение, Истина);
	КонецЦикла;
	
КонецПроцедуры

Функция МаксимальноеЗначениеВМассиве(Массив)
	
	МаксимальноеЗначение = 0;
	
	Для Индекс = 0 По Массив.Количество() - 1 Цикл
		Значение = Массив[Индекс];
		
		Если МаксимальноеЗначение < Значение Тогда
			МаксимальноеЗначение = Значение;
		КонецЕсли;
	КонецЦикла;
	
	Возврат МаксимальноеЗначение;
	
КонецФункции

// Вызывает исключение с текстом Сообщение, если Условие не равно Истина.
// Применяется для самодиагностики кода.
//
// Параметры:
//   Условие                - Булево - если не равно Истина, то вызывается исключение.
//   КонтекстПроверки       - Строка - например, имя процедуры или функции, в которой выполняется проверка.
//   Сообщение              - Строка - текст сообщения. Если не задан, то исключение вызывается с сообщением по
//                                     умолчанию.
//
Процедура Проверить(Знач Условие, Знач Сообщение = "", Знач КонтекстПроверки = "") Экспорт
	
	Если Условие <> Истина Тогда
		Если ПустаяСтрока(Сообщение) Тогда
			ТекстИсключения = НСтр("ru = 'Недопустимая операция'"); // Assertion failed
		Иначе
			ТекстИсключения = Сообщение;
		КонецЕсли;
		Если Не ПустаяСтрока(КонтекстПроверки) Тогда
			ТекстИсключения = ТекстИсключения + " " + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'в %1'"), КонтекстПроверки);
		КонецЕсли;
		ВызватьИсключение ТекстИсключения;
	КонецЕсли;
	
КонецПроцедуры

// Вызывает исключение, если тип значения параметра ИмяПараметра процедуры или функции ИмяПроцедурыИлиФункции
// отличается от ожидаемого.
// Для диагностики типов параметров, передаваемых в процедуры и функции программного интерфейса.
//
// Параметры:
//   ИмяПроцедурыИлиФункции - Строка             - имя процедуры или функции, параметр которой проверяется.
//   ИмяПараметра           - Строка             - имя проверяемого параметра процедуры или функции.
//   ЗначениеПараметра      - Произвольный       - фактическое значение параметра.
//   ОжидаемыеТипы  - ОписаниеТипов, Тип, Массив - тип(ы) параметра процедуры или функции.
//   ОжидаемыеТипыСвойств   - Структура          - если ожидаемый тип - структура, то 
//                                                 в этом параметре можно указать типы ее свойств.
//
Процедура ПроверитьПараметр(Знач ИмяПроцедурыИлиФункции, Знач ИмяПараметра, Знач ЗначениеПараметра, 
	Знач ОжидаемыеТипы, Знач ОжидаемыеТипыСвойств = Неопределено) Экспорт
	
	Контекст = "ОбщегоНазначенияКлиентСервер.ПроверитьПараметр";
	Проверить(ТипЗнч(ИмяПроцедурыИлиФункции) = Тип("Строка"), 
		НСтр("ru = 'Недопустимо значение параметра ИмяПроцедурыИлиФункции'"), Контекст);
	Проверить(ТипЗнч(ИмяПараметра) = Тип("Строка"), 
		НСтр("ru = 'Недопустимо значение параметра ИмяПараметра'"), Контекст);
		
	ЭтоКорректныйТип = ЗначениеОжидаемогоТипа(ЗначениеПараметра, ОжидаемыеТипы);
	Проверить(ЭтоКорректныйТип <> Неопределено, 
		НСтр("ru = 'Недопустимо значение параметра ОжидаемыеТипы'"), Контекст);
		
	НедопустимыйПараметр = НСтр("ru = 'Недопустимое значение параметра %1 в %2. 
		|Ожидалось: %3; передано значение: %4 (тип %5).'");
	Проверить(ЭтоКорректныйТип, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НедопустимыйПараметр,
		ИмяПараметра,
		ИмяПроцедурыИлиФункции,
		ПредставлениеТипов(ОжидаемыеТипы), 
		?(ЗначениеПараметра <> Неопределено, ЗначениеПараметра, НСтр("ru = 'Неопределено'")),
		ТипЗнч(ЗначениеПараметра)));
			
	Если ТипЗнч(ЗначениеПараметра) = Тип("Структура") И ОжидаемыеТипыСвойств <> Неопределено Тогда
		
		Проверить(ТипЗнч(ОжидаемыеТипыСвойств) = Тип("Структура"), 
			НСтр("ru = 'Недопустимо значение параметра ИмяПроцедурыИлиФункции'"), Контекст);
			
		НетСвойства = НСтр("ru = 'Недопустимое значение параметра %1 (Структура) в %2. 
			|В структуре ожидалось свойство %3 (тип %4).'");
		НедопустимоеСвойство = НСтр("ru = 'Недопустимое значение свойства %1 в параметре %2 (Структура) в %3. 
			|Ожидалось: %4; передано значение: %5 (тип %6).'");
		Для каждого Свойство Из ОжидаемыеТипыСвойств Цикл
			
			ОжидаемоеИмяСвойства = Свойство.Ключ;
			ОжидаемыйТипСвойства = Свойство.Значение;
			ЗначениеСвойства = Неопределено;
			
			Проверить(ЗначениеПараметра.Свойство(ОжидаемоеИмяСвойства, ЗначениеСвойства), 
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НетСвойства, ИмяПараметра, ИмяПроцедурыИлиФункции, ОжидаемоеИмяСвойства, ОжидаемыйТипСвойства));
				
			ЭтоКорректныйТип = ЗначениеОжидаемогоТипа(ЗначениеСвойства, ОжидаемыйТипСвойства);
			Проверить(ЭтоКорректныйТип, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НедопустимоеСвойство, 
				ОжидаемоеИмяСвойства,
				ИмяПараметра,
				ИмяПроцедурыИлиФункции,
				ПредставлениеТипов(ОжидаемыеТипы), 
				?(ЗначениеСвойства <> Неопределено, ЗначениеСвойства, НСтр("ru = 'Неопределено'")),
				ТипЗнч(ЗначениеСвойства)));
		КонецЦикла;
	КонецЕсли;		
	
КонецПроцедуры

// Добавить или заменить существующий элемент отбора динамического списка
// 	Смотрите также: Одноименные свойства объекта "ЭлементОтбораКомпоновкиДанных" в синтакс-помощнике.
//
// Параметры:
//   ДинамическийСписок - ДинамическийСписок - Список, в котором требуется установить отбор
//   ИмяПоля            - Строка - Поле, по которому необходимо установить отбор.
//   ПравоеЗначение     - Произвольный - Значение отбора.
//       Необязательный. Значение по умолчанию: Неопределено.
//       Внимание! Если передать Неопределено, то значение не будет изменено.
//   ВидСравнения  - ВидСравненияКомпоновкиДанных - Условие отбора.
//   Представление - Строка - Представление элемента компоновки данных.
//       Необязательный. Значение по умолчанию: Неопределено.
//       Если указано, то выводится только флажок использования с указанным представлением (значение не выводится).
//       Для очистки (чтобы значение снова выводилось) следует передать пустую строку.
//   Использование - Булево - Флажок использования этого отбора.
//       Необязательный. Значение по умолчанию: Неопределено.
//   РежимОтображения - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - Способ отображения этого отбора
//                                                                          пользователю.
//       * РежимОтображенияЭлементаНастройкиКомпоновкиДанных.БыстрыйДоступ - В группе быстрых настроек над списком.
//       * РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Обычный       - В настройка списка (в подменю Еще).
//       * РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный   - Запретить пользователю менять этот отбор.
//   ИдентификаторПользовательскойНастройки - Строка - Уникальный идентификатор этого отбора.
//       Используется для связи с пользовательскими настройками.
//
//
Процедура УстановитьЭлементОтбораДинамическогоСписка(ДинамическийСписок, ИмяПоля,
	ПравоеЗначение = Неопределено,
	ВидСравнения = Неопределено,
	Представление = Неопределено,
	Использование = Неопределено,
	РежимОтображения = Неопределено,
	ИдентификаторПользовательскойНастройки = Неопределено) Экспорт
	
	Если РежимОтображения = Неопределено Тогда
		РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
	КонецЕсли;
	
	Если РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный Тогда
		ОтборДинамическогоСписка = ДинамическийСписок.КомпоновщикНастроек.ФиксированныеНастройки.Отбор;
	Иначе
		ОтборДинамическогоСписка = ДинамическийСписок.КомпоновщикНастроек.Настройки.Отбор;
	КонецЕсли;
	
	УстановитьЭлементОтбора(
		ОтборДинамическогоСписка,
		ИмяПоля,
		ПравоеЗначение,
		ВидСравнения,
		Представление,
		Использование,
		РежимОтображения
		);
	
	КонецПроцедуры

// Сравнить две строки версий.
//
// Параметры:
//  СтрокаВерсии1  - Строка - номер версии в формате РР.{П|ПП}.ЗЗ.СС.
//  СтрокаВерсии2  - Строка - второй сравниваемый номер версии.
//
// Возвращаемое значение:
//   Число   - больше 0, если СтрокаВерсии1 > СтрокаВерсии2; 0, если версии равны.
//
Функция СравнитьВерсии(Знач СтрокаВерсии1, Знач СтрокаВерсии2) Экспорт
	
	Строка1 = ?(ПустаяСтрока(СтрокаВерсии1), "0.0.0.0", СтрокаВерсии1);
	Строка2 = ?(ПустаяСтрока(СтрокаВерсии2), "0.0.0.0", СтрокаВерсии2);
	Версия1 = СтрРазделить(Строка1, ".");
	Если Версия1.Количество() <> 4 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неправильный формат параметра СтрокаВерсии1: %1'"), СтрокаВерсии1);
	КонецЕсли;
	Версия2 = СтрРазделить(Строка2, ".");
	Если Версия2.Количество() <> 4 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
	    	НСтр("ru = 'Неправильный формат параметра СтрокаВерсии2: %1'"), СтрокаВерсии2);
	КонецЕсли;
	
	Результат = 0;
	Для Разряд = 0 По 3 Цикл
		Результат = Число(Версия1[Разряд]) - Число(Версия2[Разряд]);
		Если Результат <> 0 Тогда
			Возврат Результат;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;
	
КонецФункции

// Возвращает значение свойства структуры.
// Параметры:
//  Структура - Неопределено
//  Ключ - Неопределено
//  ЗначениеПоУмолчанию - Неопределено - По умолчанию Неопределено
//
// Возвращаемое значение:
//  Неопределено.
//
Функция СвойствоСтруктуры(Структура, Ключ, ЗначениеПоУмолчанию = Неопределено) Экспорт
	
	Если Структура = Неопределено Тогда
		Возврат ЗначениеПоУмолчанию;
	КонецЕсли;
	
	Результат = ЗначениеПоУмолчанию;
	Если Структура.Свойство(Ключ, Результат) Тогда
		Возврат Результат;
	Иначе
		Возврат ЗначениеПоУмолчанию;
	КонецЕсли;
	
КонецФункции

#Область НеИзБСП  // БИТ

// Возвращает значение реквизита или свойства объекта.
//
// Параметры:
//  Объект				 - Произвольный	 - Объект, предполагающий доступ по [] к атрибутам объекта.
//  Свойство			 - Строка		 - Имя свойства.
//  ЗначениеПоУмолчанию	 - Произвольный	 - Значение по умолчанию, если свойства нет у объекта.
// 
// Возвращаемое значение:
//   - Произвольный.
//
Функция СвойствоОбъекта(Объект, Свойство, ЗначениеПоУмолчанию = Неопределено) Экспорт
	
	Если Объект = Неопределено Тогда
		Возврат ЗначениеПоУмолчанию;
	КонецЕсли;
	
	Если ЕстьРеквизитИлиСвойствоОбъекта(Объект, Свойство) Тогда
		Возврат Объект[Свойство];
	Иначе
		Возврат ЗначениеПоУмолчанию;
	КонецЕсли;
	
КонецФункции

// Процедура КонкатенацияСтрок.
//
// Параметры:
//  Приемник - Неопределено
//  Источник - Неопределено
//  Разделитель - Строка - По умолчанию ", "
//  ДобавлятьТолькоЗаполненныйИсточник - Булево - По умолчанию Ложь
//
Процедура КонкатенацияСтрок(Приемник, Источник, Разделитель = ", ", ДобавлятьТолькоЗаполненныйИсточник = Ложь) Экспорт
	
	Если Не ДобавлятьТолькоЗаполненныйИсточник Или ЗначениеЗаполнено(Источник) Тогда
		Приемник = Приемник + ?(ПустаяСтрока(Приемник), "", Разделитель) + Источник;
	КонецЕсли;
	
КонецПроцедуры

// Установить параметр данных компоновки, если он отличается от нового значения.
// Предназначено для уменьшения неявных серверных вызовов при интерктивном редактировании 
// параметров произвольной формы с динамическим списком.
//
// Параметры:
//  Параметры		 - ПараметрыДанныхКомпоновкиДанных - Параметры.
//  ИмяПараметра	 - Строка - Имя устанавливаемого параметра.
//  НовоеЗначение	 - Произвольный - Новое значение параметра.
//
Процедура УстановитьПараметрКомпоновкиЕслиИзменился(Параметры, ИмяПараметра, НовоеЗначение) Экспорт
	
	// Сначала определяется текущее значение параметра, чтобы, если оно не изменилось, не выполнять дальше.
	ЗначениеПараметраКомпоновки = Параметры.НайтиЗначениеПараметра(Новый ПараметрКомпоновкиДанных(ИмяПараметра));
	Если ЗначениеПараметраКомпоновки <> Неопределено
		И ЗначениеПараметраКомпоновки.Значение = НовоеЗначение
	Тогда
		Возврат;
	КонецЕсли;
	
	// Установка значения
	Параметры.УстановитьЗначениеПараметра(ИмяПараметра, НовоеЗначение);
	
КонецПроцедуры

// Процедура добавляет данные из одной структуры в другую.
//
// Параметры:
//  Приемник - структура в которую добавляется данные.
//  Источник - структуры из которой берутся данные.
//  СписокПолей - Строка - имена полей источника разделенных запятыми,
//                         если пустая строка, то переносятся все поля.
//
Процедура ДобавитьВСтруктуру(Приемник, Знач Источник, Знач СписокПолей = "") Экспорт
	
	ВсеПоля = Истина;
	Если Не ПустаяСтрока(СписокПолей) Тогда
		ВсеПоля = Ложь;
		СписокПолей = Новый Структура(СписокПолей);
	КонецЕсли;
	
	ТипИсточника = ТипЗнч(Источник);
	Если ТипИсточника = Тип("Структура")
	 Или ТипИсточника = Тип("ФиксированнаяСтруктура") Тогда
		Для Каждого КлючИЗначение Из Источник Цикл
			Если ВсеПоля Или СписокПолей.Свойство(КлючИЗначение.Ключ) Тогда
				Приемник.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
			КонецЕсли;
		КонецЦикла;
	ИначеЕсли ТипИсточника = Тип("СтрокаТаблицыЗначений") Тогда
		Колонки = Источник.Владелец().Колонки;
		Для Каждого Колонка Из Колонки Цикл
			Если ВсеПоля Или СписокПолей.Свойство(Колонка.Имя) Тогда
				Приемник.Вставить(Колонка.Имя, Источник[Колонка.Имя]);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// Добавляет элемент в массив в том случае, если его в массиве еще нет
//
// Параметры:
//  Массив - Массив из Неопределено - Дополняемый массив
//  Значение - Неопределено - значение, добавляемое в массив
//
Процедура ДобавитьВМассивБезДублей(Массив, Значение) Экспорт
	
	Если Массив.Найти(Значение) = Неопределено Тогда
		Массив.Добавить(Значение);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает значение реквизита формы по заданному пути.
//
// Параметры:
//  Форма - Неопределено 
//  ПутьКДанным  - Строка - полное имя реквизита формы, содержащего значение. Например "Объект.Контрагент"
//                         или "Объект.Товары[5].Номенклатура"
// Возвращаемое значение:
//	Неопределено - Значение реквизита формы
//
Функция ЗначениеРеквизитаФормы(Знач Форма, Знач ПутьКДанным) Экспорт
	
	ТекущееЗначение = Форма;
	ЧастиПути = СтрЗаменить(СтрЗаменить(ПутьКДанным, " ", ""), ".", Символы.ПС);
	Для Позиция = 1 По СтрЧислоСтрок(ЧастиПути) Цикл
		ВладелецЗначения = ТекущееЗначение;
		ИмяРеквизита = СтрПолучитьСтроку(ЧастиПути, Позиция);
		Если Прав(ИмяРеквизита, 1) = "]" Тогда
			ПозицияСкобки = Найти(ИмяРеквизита, "[");
			Индекс = Число(Сред(Лев(ИмяРеквизита, СтрДлина(ИмяРеквизита) - 1), ПозицияСкобки + 1));
			ИмяРеквизита = Лев(ИмяРеквизита, ПозицияСкобки - 1);
			ТекущееЗначение = ВладелецЗначения[ИмяРеквизита].НайтиПоИдентификатору(Индекс);
		Иначе
			ТекущееЗначение = ВладелецЗначения[ИмяРеквизита];
		КонецЕсли;
	КонецЦикла;
	
	Возврат ТекущееЗначение;
	
КонецФункции

// Первая строка, найденная по отбору таблицы.
//
// Параметры:
//  Таблица	 - ТаблицаЗначений, ДанныеФормыКоллекция - Таблица, поддерживающая метод НайтиСтроки(СтруктураОтбора).
//  Отбор	 - Структура	 - Отбор строк.
// 
// Возвращаемое значение:
//   - СтрокатаблицыЗначений, Неопределено.
//
Функция ПерваяСтрокаОтбораТаблицы(Таблица, Отбор) Экспорт
	
	НайденныеСтроки = Таблица.НайтиСтроки(Отбор);
	Если НайденныеСтроки.Количество() > 0 Тогда
		Возврат НайденныеСтроки[0];
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

// Стандартная для данной конфигурации функция форматирования сумм.
//
// Параметры: 
//  Сумма  - Число - , которое мы хотим форматировать, 
//  Валюта - СправочникСсылка - ссылка на элемент справочника валют, если задан, то к в результирующую строку
//           будет добавлено представление валюты.
//  ЧН     - Строка - представляющая нулевое значение числа,
//  ЧРГ    - Строка - символ-разделитель групп целой части числа.
//
// Возвращаемое значение:
//  Неопределено - Отформатированная должным образом строковое представление суммы.
//
Функция ФорматСумм(Сумма, Валюта = Неопределено, ЧН = "", ЧРГ = "") Экспорт

	ФорматнаяСтрока = "ЧЦ=15;ЧДЦ=2" +
					?(НЕ ЗначениеЗаполнено(ЧН), "", ";" + "ЧН=" + ЧН) +
					?(НЕ ЗначениеЗаполнено(ЧРГ),"", ";" + "ЧРГ=" + ЧРГ);
	РезультирующаяСтрока = СокрЛ(Формат(Сумма, ФорматнаяСтрока));
	
	Если ЗначениеЗаполнено(Валюта) Тогда
		РезультирующаяСтрока = РезультирующаяСтрока + " " + СокрП(Валюта);
	КонецЕсли;

	Возврат РезультирующаяСтрока;

КонецФункции

// Приводит числовую строку к маске
//
// Параметры:
//  Строка	 - Строка	 - приводимая строка.
//  Маска	 - Строка	 - требуемая маска.
// 
// Возвращаемое значение:
//  Строка.
//
Функция ПривестиЧисловуюСтрокуКМаске(Строка, Маска) Экспорт
	
	Результат = СтрЗаменить(Маска,"9","N");
	
	ДлинаРез = СтрДлина(Результат);
	ДлинаСтроки = СтрДлина(Строка);
	
	Для Сч = 1 По ДлинаСтроки Цикл 
		СимволСтроки = Сред(Строка,Сч,1);
		Если Не СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(СимволСтроки) Тогда
			Продолжить;
		КонецЕсли;

		ПозицияN = СтрНайти(Результат,"N");
		Если ПозицияN = 0 Тогда
			Прервать;	
		КонецЕсли;
		Результат = Лев(Результат,ПозицияN-1) + СимволСтроки + Прав(Результат,ДлинаРез - ПозицияN);
	КонецЦикла;
	
	Результат = СтрЗаменить(Результат,"N"," ");
	Возврат Результат;
	
КонецФункции

// Инициализирует новый массив заданными значениями
//
// Параметры:
//  Значение1	 - Произвольный	 - значение инициализации.
//  Значение2	 - Произвольный	 - значение инициализации.
//  Значение3	 - Произвольный	 - значение инициализации.
//  Значение4	 - Произвольный	 - значение инициализации.
//  Значение5	 - Произвольный	 - значение инициализации.
// 
// Возвращаемое значение:
//  Массив.
//
Функция НовыйМассив(Значение1 = Неопределено, Значение2 = Неопределено, Значение3 = Неопределено, Значение4 = Неопределено, Значение5 = Неопределено) Экспорт
	
	Массив = Новый Массив;
	
	Если ЗначениеЗаполнено(Значение1) Тогда
		Массив.Добавить(Значение1);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Значение2) Тогда
		Массив.Добавить(Значение2);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Значение3) Тогда
		Массив.Добавить(Значение3);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Значение4) Тогда
		Массив.Добавить(Значение4);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Значение5) Тогда
		Массив.Добавить(Значение5);
	КонецЕсли;
	
	Возврат Массив
	
КонецФункции

#Область КОРП

Функция ВернутьСтрокойПериодДат(ДатаНачала, ДатаОкончания, ФорматнаяСтрока = "ДФ=dd.MM.yy", Разделитель = " - ") Экспорт
	
	Строка = "";
	Если ЗначениеЗаполнено(ДатаНачала) И ТипЗнч(ДатаНачала) = Тип("Дата") Тогда
		Строка = Формат(ДатаНачала,ФорматнаяСтрока);
	КонецЕсли;
	Строка = Строка + Разделитель;
	Если ЗначениеЗаполнено(ДатаОкончания) И ТипЗнч(ДатаОкончания) = Тип("Дата")  Тогда
		Строка = Строка + Формат(ДатаОкончания,ФорматнаяСтрока);
	КонецЕсли;
	Возврат Строка;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#КонецОбласти