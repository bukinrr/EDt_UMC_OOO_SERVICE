#Область ПрограммныйИнтерфейс

// Функции данного модуля должны работать как с полем HTML документа (COMОбъект в Windows, ВнешнийОбъект в Веб-клиенте и Linux),
// так и с документом DOM 1C.

// Проверяет, документ DOM ли передан.
//
// Параметры:
//  ИсследуемыйОбъект	 - ВнешнийОбъект, COMОбъект, ДокументDOM - проверяемый объект.
// 
// Возвращаемое значение:
//   Булево - это DOM документ.
//
Функция ЭтоДокументDOM(ИсследуемыйОбъект) Экспорт
	
	Возврат ТипЗнч(ИсследуемыйОбъект) <> Тип("COMОбъект") И Не ЭтоВнешнийОбъект(ИсследуемыйОбъект);
	
КонецФункции

// Проверяет, внешний объект ли передан.
//
// Параметры:
//  ИсследуемыйОбъект	 - Произвольный - проверяемый объект.
// 
// Возвращаемое значение:
//   Булево.
//
Функция ЭтоВнешнийОбъект(ИсследуемыйОбъект) Экспорт
	
	Возврат ТипЗнч(ИсследуемыйОбъект) = Тип("ВнешнийОбъект") Или Строка(ТипЗнч(ИсследуемыйОбъект)) = Строка(Тип("ВнешнийОбъект"));
	
КонецФункции

// Проверяет, является ли элемент в документе текстовым содержимым.
//
// Параметры:
//  ЭлементHTML	 - ТекстDOM, ЭлементDOM	 - элемент документа.
// 
// Возвращаемое значение:
//   Булево.
//
Функция ЭтоТекстовоеСодержимое(ЭлементHTML) Экспорт
	
	Если ТипЗнч(ЭлементHTML) = Тип("ТекстDOM") Тогда 
		Возврат Истина;
	Иначе
		Попытка
			Возврат ЭлементHTML.nodeType = 3;
		Исключение
			Возврат Ложь;
		КонецПопытки;
	КонецЕсли;
	
КонецФункции

// Проверяет, пустой ли элемент.
//
// Параметры:
//  ЭлементHTML	 - ТекстDOM, ЭлементDOM, Неопределено	 - элемент документа.
// 
// Возвращаемое значение:
//   Булево.
//
Функция ЭлементПустой(ЭлементHTML) Экспорт
	
	Возврат ЭлементHTML = Null Или ЭлементHTML = Неопределено;
	
КонецФункции

// Текст HTML пустого документа.
// 
// Возвращаемое значение:
//   Булево. 
//
Функция ПолучитьТекстHTMLПустогоДокумента() Экспорт
	
	Возврат "<HTML><BODY></BODY></HTML>";
	
КонецФункции

// Возвращает HTML-элементы с заданным значением атрибута.
//
// Параметры:
//  ДокументHTML		 - ДокументHTML, ДокументDOM - Документ, в котором производится поиск элементов
//  ЗначениеАтрибута	 - Строка					 - значение указанного атрибута искомого значения
//  ОграничениеПоТегам	 - Строка, Массив			 - перечень имен тегов для обработки.
//  ИмяАтрибута			 - Строка					 - наименование атрибута искомого элемента, по значению которого производится поиск HTML-элемента.
// 
// Возвращаемое значение:
//  Массив - список элементов HTML, найденных по значению атрибута.
//
Функция ПолучитьЭлементыПоЗначениюАтрибута(ДокументHTML, Знач ЗначениеАтрибута = Неопределено, ОграничениеПоТегам = Неопределено, ИмяАтрибута = "id") Экспорт
	
	Если ЗначениеАтрибута <> Неопределено И Не ЗначениеЗаполнено(ЗначениеАтрибута) Тогда
		Возврат Новый Массив;
	КонецЕсли;
	
	СтрЗначениеАтрибута = Строка(ЗначениеАтрибута);
	
	МассивТегов = ОграничениеПоТегам;
	Если ОграничениеПоТегам <> Неопределено И ТипЗнч(ОграничениеПоТегам) = Тип("Строка") Тогда 
		МассивТегов = Новый Массив;
		МассивТегов.Добавить(ОграничениеПоТегам);
	КонецЕсли;
	
	Если ЭтоДокументDOM(ДокументHTML) Тогда
		ЭлементыПоАтрибуту = Новый Массив;
		Если ТипЗнч(ДокументHTML) = Тип("ДокументHTML") Тогда
			Фильтр =
			"{
			|	""type"": ""intersection"", 
			|	""value"":
			|	[
			|";
			Если ЗначениеАтрибута <> Неопределено Тогда
				Фильтр = Фильтр +
				"		{
				|			""type"": ""attribute"",
				|			""value"":
				|				{
				|					""value"": """+СтрЗначениеАтрибута+""",
				|					""operation"": ""valueequals""
				|				}
				|		},
				|";
			КонецЕсли;
			Фильтр = Фильтр +
			"		{
			|			""type"": ""attribute"",
			|			""value"":
			|				{
			|					""value"": """ + ИмяАтрибута + """,
			|					""operation"": ""nameequals""
			|				}
			|		}
			|	]
			|}";
			АттрибутыЭлементовПоУИД = ДокументHTML.НайтиПоФильтру(Фильтр);
			Для Каждого Аттрибут Из АттрибутыЭлементовПоУИД Цикл
				ЭлементыПоАтрибуту.Добавить(Аттрибут.ЭлементВладелец);
			КонецЦикла;
		ИначеЕсли МассивТегов <> Неопределено Тогда
			Для Каждого ИмяТега Из МассивТегов Цикл
				НайденныеЭлементы = ПолучитьЭлементыПоИмени(ДокументHTML, ИмяТега);
				Для Каждого ЭлементHTML Из НайденныеЭлементы Цикл
					Попытка
						Если (ЗначениеАтрибута = Неопределено
								И ЭлементHTML.ЕстьАтрибут(ИмяАтрибута))
							Или (ЗначениеАтрибута <> Неопределено
								И ЭлементHTML.ПолучитьАтрибут(ИмяАтрибута) = СтрЗначениеАтрибута)
						Тогда
							ЭлементыПоАтрибуту.Добавить(ЭлементHTML);
						КонецЕсли;
					Исключение КонецПопытки;
				КонецЦикла;
			КонецЦикла;
		КонецЕсли;
		
	Иначе
		ЭлементыПоАтрибуту = ДокументHTML.querySelectorAll("[" + ИмяАтрибута + ?(ЗначениеАтрибута <> Неопределено, "='" + СтрЗначениеАтрибута + "'","") + "]");
	КонецЕсли;
	
	Если ТипЗнч(МассивТегов) = Тип("Массив") Тогда
		
		ЭлементыHTML = Новый Массив;
		
		Для Каждого Узел Из ЭлементыПоАтрибуту Цикл
			Если МассивТегов.Найти(Нрег(ПолучитьСвойствоЭлемента(Узел, "tagName"))) <> Неопределено Тогда
				ЭлементыHTML.Добавить(Узел);
			КонецЕсли;
		КонецЦикла;
	Иначе
		ЭлементыHTML = ЭлементыПоАтрибуту;
	КонецЕсли;
	
	Возврат ЭлементыHTML;
	
КонецФункции

// Получить идентификатор элемента
//
// Параметры:
//  ЭлементHTML	 - ЭлементDOM, ВнешнийОбъект	 - элемент документа.
// 
// Возвращаемое значение:
//   Строка.
//
Функция ПолучитьИдентификаторЭлемента(ЭлементHTML) Экспорт
	
	Если Не ЭтоДокументDOM(ЭлементHTML) Тогда	
		Возврат ЭлементHTML.id;
	Иначе
		Атрибут = ЭлементHTML.Атрибуты.ПолучитьИменованныйЭлемент("id");
		Если Атрибут = Неопределено Тогда 
			Возврат Неопределено;
		Иначе
			Возврат Атрибут.ЗначениеУзла;
		КонецЕсли;
	КонецЕсли;
	
КонецФункции

// Позволяет из документа получить элементы по имени тега.
//
// Параметры:
//  ДокументHTML	 - ВнешнийОбъект, ДокументDOM	 - документ.
//  ИмяЭлемента		 - Строка	 - имя тега.
//  ВернутьМассив1С	 - Булево	 - вернуть ли в виде массива.
// 
// Возвращаемое значение:
//   Массив, ВнешнийОбъект.
//
Функция ПолучитьЭлементыПоИмени(ДокументHTML, Знач ИмяЭлемента, ВернутьМассив1С = Ложь) Экспорт
	
	Если Не ЭтоДокументDOM(ДокументHTML) Тогда	
		Коллекция = ДокументHTML.getElementsByTagName(ИмяЭлемента);
	Иначе
		Коллекция = ДокументHTML.getElementByTagName(ИмяЭлемента);
	КонецЕсли;
	
	Если Не ВернутьМассив1С Тогда
		Возврат Коллекция;
	Иначе
		мЭлементов = Новый Массив();
		Для Каждого элементКоллекции Из Коллекция Цикл
			мЭлементов.Добавить(элементКоллекции);
		КонецЦикла;
		Возврат мЭлементов;
	КонецЕсли;
	
КонецФункции

Функция ПолучитьСоответствиеСвойствПараметров()
	
	СоответствиеСвойств = Новый Соответствие;
	СоответствиеСвойств.Вставить("innertext", "ТекстовоеСодержимое");
	Возврат СоответствиеСвойств;
	
КонецФункции

// Свойство элемента HTML документа по имени атрибута.
//
// Параметры:
//  ЭлементHTML	 - ВнешнийОбъект, ЭлементDOM - элемент.
//  ИмяСвойства	 - Строка					 - имя атрибута.
// 
// Возвращаемое значение:
//   Строка.
//
Функция ПолучитьСвойствоЭлемента(ЭлементHTML, Знач ИмяСвойства) Экспорт
	
	Если Не ЭтоДокументDOM(ЭлементHTML) Тогда	
		Возврат ЭлементHTML[ИмяСвойства];
	КонецЕсли;
	
	СоответствиеСвойств = ПолучитьСоответствиеСвойствПараметров();
	
	АналогСвойства = СоответствиеСвойств[НРег(ИмяСвойства)];
	Если АналогСвойства = Неопределено Тогда 
		Попытка
			Возврат ЭлементHTML[ИмяСвойства];
		Исключение
			Возврат Неопределено;
		КонецПопытки;
	Иначе
		Возврат ЭлементHTML[АналогСвойства];
	КонецЕсли;
	
КонецФункции

// Установить свойство элемента HTML.
//
// Параметры:
//  ЭлементHTML	 - ВнешнийОбъект, ЭлементDOM - элемент.
//  ИмяСвойства	 - Строка					 - имя атрибута.
//  Значение	 - Строка					 - значение.
//
Процедура УстановитьСвойствоЭлемента(ЭлементHTML, Знач ИмяСвойства, Знач Значение) Экспорт
	
	Если Не ЭтоДокументDOM(ЭлементHTML) Тогда	
		ЭлементHTML[ИмяСвойства] = Значение;
		Возврат;
	КонецЕсли;
	
	СоответствиеСвойств = ПолучитьСоответствиеСвойствПараметров();
	
	АналогСвойства = СоответствиеСвойств[НРег(ИмяСвойства)];
	Если АналогСвойства = Неопределено Тогда 
		Попытка
			ЭлементHTML[ИмяСвойства] = Значение;
		Исключение
			Возврат;
		КонецПопытки;
	Иначе
		ЭлементHTML[АналогСвойства] = Значение;
	КонецЕсли;
	
КонецПроцедуры

// Позволяет заменить элемент на новый, заданный как HTML текст.
//
// Параметры:
//  ЭлементHTML				 - ВнешнийОбъект, ЭлементDOM - исходный тег.
//  Значение				 - Строка		 - значение.
//  ВставлятьПереносыСтрок	 - Булево		 - добавлять ли переносы строк перед новым элементом в документе.
// 
// Возвращаемое значение:
//   ВнешнийОбъект - новый элемент html документа.
//
Функция ЗаменитьЭлементНаТекстовоеСодержимое(ЭлементHTML, Знач Значение, Знач ВставлятьПереносыСтрок = Истина) Экспорт
	
	Возврат РаботаСDOMКлиентСервер.ЗаменитьЭлементНаТекстовоеСодержимое(ЭлементHTML, Значение, ВставлятьПереносыСтрок);
	
КонецФункции

// Получить выбранное значение select
//
// Параметры:
//  ЭлементHTML					 - ВнешнийОбъект, ЭлементDOM - исходный тег.
//  ВозвращатьПервыйЕслиНеВыбран - Булево					 - венуть ли первый.
// 
// Возвращаемое значение:
//   Строка - значение.
//
Функция ПолучитьВыбранноеЗначениеSelect(ЭлементHTML, ВозвращатьПервыйЕслиНеВыбран = Истина) Экспорт 
	
	Если Не ЭтоДокументDOM(ЭлементHTML) Тогда			
		Возврат ЭлементHTML.value;
	Иначе	
		Возврат РаботаСDOMКлиентСервер.ПолучитьВыбранноеЗначениеSelect(ЭлементHTML, ВозвращатьПервыйЕслиНеВыбран);
	КонецЕсли;
		
КонецФункции

// Устанавливает выбранное значение в теге select документа на форме.
//
// Параметры:
//  ЭлементHTML	 - ВнешнийОбъект - исходный тег.
//  Значение	 - Строка		 - новое текущее значение выбора.
//
Процедура УстановитьВыбранноеЗначениеSelect(ЭлементHTML, Знач Значение) Экспорт
	
	Если Не ЭтоДокументDOM(ЭлементHTML) Тогда	
		
		ЕстьВыбранноеЗначение = Ложь;
		Значение = Строка(Значение);
		Для Каждого ЗначениеВыбора Из ЭлементHTML.childNodes Цикл
			ЗначениеЭлемента = ЗначениеВыбора.value;
			
			Если ЗначениеЭлемента <> Неопределено И ЗначениеЭлемента = Значение Тогда
				ЕстьВыбранноеЗначение = Истина;
				ЗначениеВыбора.setAttribute("selected", Истина);
			Иначе
				ЗначениеВыбора.removeAttribute("selected");
			КонецЕсли;
		КонецЦикла;
		
		Если ЕстьВыбранноеЗначение Тогда 
			ЭлементHTML.value = Значение;
			ЭлементHTML.setAttribute("value", Значение);
		Иначе
			ЭлементHTML.value = "";
			ЭлементHTML.removeAttribute("value");
		КонецЕсли;
		
	Иначе
		
		РаботаСDOMКлиентСервер.УстановитьВыбранноеЗначениеSelect(ЭлементHTML, Значение);
		
	КонецЕсли;
	
КонецПроцедуры

// Установить значение элементу поля ввода HTML
//
// Параметры:
//  ЭлементHTML	 - ВнешнийОбъект - исходный тег.
//  Значение	 - Строка		 - новое значение.
//  ТегЭлемента	 - Строка		 - имя тега.
//
Процедура УстановитьЗначениеЭлементуПоляВводаHTML(ЭлементHTML, Значение, ТегЭлемента) Экспорт
	
	Если ТегЭлемента = "TEXTAREA" Тогда
		УстановитьЗначениеTextarea(ЭлементHTML, Значение);
	Иначе
		УстановитьЗначениеПоляВводаInput(ЭлементHTML, Значение);
	КонецЕсли;
	
КонецПроцедуры

// Установить значение элементу поля ввода типа textarea.
//
// Параметры:
//  ЭлементHTML	 - ВнешнийОбъект - исходный тег.
//  Значение	 - Строка		 - новое значение.
//
Процедура УстановитьЗначениеTextarea(ЭлементHTML, Значение)
	
	Если Не ЭтоДокументDOM(ЭлементHTML) Тогда	
		ЭлементHTML.value = Значение;
		ЭлементHTML.innerText = Значение;
	Иначе
		ЭлементHTML.ТекстовоеСодержимое = Значение;
	КонецЕсли;
	
КонецПроцедуры

// Установить значение элементу поля ввода типа input.
//
// Параметры:
//  ЭлементHTML	 - ВнешнийОбъект - исходный тег.
//  Значение	 - Строка		 - новое значение.
//
Процедура УстановитьЗначениеПоляВводаInput(ЭлементHTML, Значение)
	
	Если Не ЭтоДокументDOM(ЭлементHTML) Тогда	
		ЭлементHTML.value = Значение;
	Иначе
		ЭлементHTML.Значение = Значение;
	КонецЕсли;
	
КонецПроцедуры

// Добавить произвольный текс HTML в элемент HTML документа.
//
// Параметры:
//  ЭлементHTML					 - ВнешнийОбъект - исходный тег.
//  ТекстHTML					 - Строка		 - текст вставки.
//  ЗамещатьВложенныеЭлементы	 - Булево		 - вставить ли текст не рядом, а в указанный элемент,
//  УзелПередКоторымВставить	 - ВнешнийОбъект - место вставки.
//
Процедура ДобавитьПроизвольныйHTMLВЭлемент(ЭлементHTML, Знач ТекстHTML, ЗамещатьВложенныеЭлементы = Ложь, УзелПередКоторымВставить = Неопределено) Экспорт
	
	Если Не ЭтоДокументDOM(ЭлементHTML) Тогда		
		ЭлементHTML.innerHTML = ?(ЗамещатьВложенныеЭлементы, "", ЭлементHTML.innerText) + ТекстHTML;
	Иначе
		РаботаСDOMКлиентСервер.ДобавитьПроизвольныйHTMLВЭлемент(ЭлементHTML, ТекстHTML, ЗамещатьВложенныеЭлементы, УзелПередКоторымВставить); 
	КонецЕсли;
	
КонецПроцедуры

// Замещает элемент HTML новый, зажанный как текст HTML.
//
// Параметры:
//  ЭлементHTML	 - ВнешнийОбъект - исходный тег.
//  ТекстHTML	 - Строка		 - текст замены.
//
Процедура ЗаменитьЭлементНаПроизвольныйHTML(ЭлементHTML, Знач ТекстHTML) Экспорт
	
	Если Не ЭтоДокументDOM(ЭлементHTML) Тогда
		ЭлементHTML.outerHTML = ТекстHTML;
	Иначе
		РаботаСDOMКлиентСервер.ЗаменитьЭлементНаПроизвольныйHTML(ЭлементHTML, ТекстHTML);
	КонецЕсли;
	
КонецПроцедуры

// Перемещает внутренний HTML текст элемента на один уровень с ним в HTML документе.
//
// Параметры:
//  ЭлементHTML		 - ВнешнийОбъект - элемент документа
//  УдалитьЭлемент	 - Булево - удалить ли заданный элемент.
//
Процедура ВынестиСодержимоеЭлементаНаружу(ЭлементHTML, УдалитьЭлемент = Ложь) Экспорт
	
	РодительЭлемента = ЭлементHTML.parentNode;
	Если ЭлементПустой(РодительЭлемента) Тогда 
		Возврат;
	КонецЕсли;
	
	Пока Не ЭлементПустой(ЭлементHTML.firstChild) Цикл 		
		РодительЭлемента.insertBefore(ЭлементHTML.firstChild, ЭлементHTML);		
	КонецЦикла;
	
	Если УдалитьЭлемент Тогда 
		РодительЭлемента.removeChild(ЭлементHTML);
	КонецЕсли;
	
КонецПроцедуры

// Переместить элемент "на дно" дерева тегов.
//
// Параметры:
//  ЭлементHTML						 - ВнешнийОбъект - элемент документа
//  УдалятьВложенныеУзлыКромеПервого - Булево		 - удалить ли подчиненные элементы узла.
//
Процедура ПоместитьЭлементВглубьДерева(ЭлементHTML, УдалятьВложенныеУзлыКромеПервого = Ложь) Экспорт
	
	СамыйГлубокийЭлемент = ПолучитьСамыйГлубокийЭлемент(ЭлементHTML, УдалятьВложенныеУзлыКромеПервого);	
	Если ЭлементHTML = СамыйГлубокийЭлемент Тогда 
		Возврат;
	КонецЕсли;
	
	ТекстовоеСодержимое = ЭлементHTML.textContent;
	
	Если ЭтоТекстовоеСодержимое(СамыйГлубокийЭлемент) Тогда
		Если ЭлементHTML = СамыйГлубокийЭлемент.parentNode Тогда // В ссылке кроме текста ничего нет.
			Возврат;
		Иначе
			РодительскийУзел = СамыйГлубокийЭлемент.parentNode;
			РодительскийУзел.removeChild(СамыйГлубокийЭлемент);
			СамыйГлубокийЭлемент = РодительскийУзел;
		КонецЕсли;
	КонецЕсли;
	
	ВынестиСодержимоеЭлементаНаружу(ЭлементHTML);
	СамыйГлубокийЭлемент.appendChild(ЭлементHTML);	
	ЭлементHTML.textContent = ТекстовоеСодержимое;
	
КонецПроцедуры

// Получает дно ветки дерева тегов документа.
//
// Параметры:
//  ЭлементHTML						 - ВнешнийОбъект - элемент документа
//  УдалятьВложенныеУзлыКромеПервого - Булево		 - удалить ли подчиненные элементы узла.
//  СКонца							 - Булево		 - направление анализа.
// 
// Возвращаемое значение:
//  ВнешнийОбъект - элемент html документа.
//
Функция ПолучитьСамыйГлубокийЭлемент(ЭлементHTML, УдалятьВложенныеУзлыКромеПервого = Ложь, СКонца = Ложь) Экспорт
	
	Если ЭтоДокументDOM(ЭлементHTML) Тогда 
		КоличествоДочерних = ЭлементHTML.ДочерниеУзлы.Количество();
	Иначе
		КоличествоДочерних = ЭлементHTML.childNodes.length;
	КонецЕсли;
	
	Если КоличествоДочерних = 0 Тогда
		Возврат ЭлементHTML;
	Иначе
		Если УдалятьВложенныеУзлыКромеПервого Тогда 
			Для Сч = 1 По КоличествоДочерних - 1 Цикл 
				ЭлементHTML.removeChild(ЭлементHTML.childNodes.item(Сч));
			КонецЦикла;
		КонецЕсли;
		Возврат ПолучитьСамыйГлубокийЭлемент(ЭлементHTML.childNodes.item(?(СКонца, КоличествоДочерних-1, 0)), , СКонца);
	КонецЕсли;
	
КонецФункции

// Удаляет вложенности тега вычисляемых блоков в документе HTML, исключая тег блока в теге блока.
//
// Параметры:
//  ЭлементHTML	 - ВнешнийОбъект, ЭлементDOM - узел документа.
//
Процедура ОчиститьНезначащиеОхватывающиеТегиВычисляемыхБлоков(ЭлементHTML) Экспорт
	
	ДочерниеЭлементыТолькоВычисляемыеБлоки = Истина;
	Для Каждого ДочернийЭлемент Из ЭлементHTML.childNodes Цикл
		Если ВРег(ДочернийЭлемент.nodeName) <> "TT" Тогда
			ДочерниеЭлементыТолькоВычисляемыеБлоки = Ложь;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если ДочерниеЭлементыТолькоВычисляемыеБлоки Тогда
		Если ЭтоДокументDOM(ЭлементHTML) Тогда 
			ВынестиСодержимоеЭлементаНаружу(ЭлементHTML, Истина);
		Иначе
			ЭлементHTML.outerHtml = ЭлементHTML.innerHtml;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Позволяет получить код base64 картинки для встави в тег HTML.
//
// Параметры:
//  КартинкаИлиДвоичныеДанные	 - ДвоичныеДанные, Картинка	 - картинка.
//  Формат						 - Строка	 - разрешение файла.
// 
// Возвращаемое значение:
//   Строка.
//
Функция ПолучитьBase64КартинкиДляHTML(КартинкаИлиДвоичныеДанные, Знач Формат = Неопределено) Экспорт
	
	мсДопустимыеФорматы = Новый Массив;
	мсДопустимыеФорматы.Добавить("jpg");
	мсДопустимыеФорматы.Добавить("jpeg");
	мсДопустимыеФорматы.Добавить("png");
	мсДопустимыеФорматы.Добавить("gif");
	
	ЭтоКартинка = (ТипЗнч(КартинкаИлиДвоичныеДанные) = Тип("Картинка"));
	Если ЭтоКартинка Тогда
		ДвоичныеДанные = КартинкаИлиДвоичныеДанные.ПолучитьДвоичныеДанные();
	Иначе
		ДвоичныеДанные = КартинкаИлиДвоичныеДанные;
	КонецЕсли;
	
	Если Формат = Неопределено Тогда
		Попытка
			Если ЭтоКартинка Тогда 
				Формат = Строка(КартинкаИлиДвоичныеДанные.Формат());
			Иначе
				Картинка = Новый Картинка(КартинкаИлиДвоичныеДанные);
				Формат = Картинка.Формат();
			КонецЕсли;
		Исключение
			Формат = "";
		КонецПопытки;
	КонецЕсли;
	Формат = НРег(Формат);
	Если Лев(Формат, 1) = "." Тогда 
		Формат = Прав(Формат, СтрДлина(Формат) - 1);
	КонецЕсли;	
	
	Если мсДопустимыеФорматы.Найти(Формат) = Неопределено Тогда 
		Возврат "";
	КонецЕсли; 
	
	Возврат "data:image/" + Формат + ";base64," + Base64Строка(ДвоичныеДанные);
	
КонецФункции

// Позволяет получить кода base64 и тега с картинкой HTML, заданной двоичными данными.
//
// Параметры:
//  СтрокаBase64 - Стрка	 - шифрованная картинка.
// 
// Возвращаемое значение:
//   Строка.
//
Функция ПолучитьДанныеИзBase64КартинкиHTML(СтрокаBase64) Экспорт 
	
	ДлинаBase64 = СтрДлина(СтрокаBase64);
	Заголовок = ";base64,";
	КонецЗаголовка = СтрНайти(СтрокаBase64, Заголовок);
	
	Если КонецЗаголовка = 0 Тогда 
		Возврат "";
	КонецЕсли;
	
	Возврат Прав(СтрокаBase64, ДлинаBase64 - (КонецЗаголовка + СтрДлина(Заголовок) - 1));
	
КонецФункции

// Получить внутренний HTML узла документа.
//
// Параметры:
//  ЭлементHTML	 - ВнешнийОбъект, ЭлементDOM - узел документа.
// 
// Возвращаемое значение:
//   Строка.
//
Функция ПолучитьВнутреннийHTMLЭлемента(ЭлементHTML) Экспорт
	
	Если ЭтоДокументDOM(ЭлементHTML) Тогда
		Возврат РаботаСDOMКлиентСервер.ПолучитьВнутреннийHTMLЭлемента(ЭлементHTML);
	Иначе
		Возврат ЭлементHTML.innerHTML;
	КонецЕсли;
	
КонецФункции

// Получить внешний HTML узла документа.
//
// Параметры:
//  ЭлементHTML	 - ВнешнийОбъект, ЭлементDOM - узел документа.
// 
// Возвращаемое значение:
//   Строка.
//
Функция ПолучитьВнешнийHTMLЭлемента(ЭлементHTML) Экспорт
	
	Если ЭтоДокументDOM(ЭлементHTML) Тогда
		Возврат РаботаСDOMКлиентСервер.ПолучитьВнешнийHTMLЭлемента(ЭлементHTML);
	Иначе
		Возврат ЭлементHTML.innerHTML;
	КонецЕсли;	
	
КонецФункции

// Преобразовует произвольную коллекцию в массив
//
// Параметры:
//  Коллекция	 - Произвольный	 - произвольная коллекция.
// 
// Возвращаемое значение:
//   Массив.
//
Функция ПреобразоватьОбходимуюКоллекциюВМассив(Коллекция) Экспорт
	
	Если ЭтоДокументDOM(Коллекция) Тогда
		Возврат РаботаСDOMКлиентСервер.ПреобразоватьОбходимуюКоллекциюВМассив(Коллекция);
	Иначе
		мсКоллекция = Новый Массив;
		ЧислоЭлементов = Коллекция.length;
		Для Сч = 1 По ЧислоЭлементов - 1 Цикл
			мсКоллекция.Добавить(Коллекция.item(Сч));
		КонецЦикла;
		Возврат мсКоллекция;
	КонецЕсли;
	
КонецФункции

// Удаляет из текста HTML все теги, оставляя только внутренний текст.
//
// Параметры:
//  Текст	 - Строка	 - исходный текст.
// 
// Возвращаемое значение:
//   Строка - текст html.
//
Функция УдалитьВсеТегиИзТекста(Знач Текст) Экспорт
	
	ТекстВых = "";
	ДлинаСтроки = СтрДлина(Текст);
	Для Сч = 1 По ДлинаСтроки Цикл
		ТекСимвол = Сред(Текст, Сч, 1);
		Если ТекСимвол = "<" Тогда // Пропускаем символы до закрывающего тега.
			Для СчТ = Сч + 1 По ДлинаСтроки Цикл
				ТекСимвол = Сред(Текст, СчТ, 1);
				Если ТекСимвол = ">" Тогда
					Сч = СчТ;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		Иначе
			ТекстВых = ТекстВых + ТекСимвол;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ТекстВых;
	
КонецФункции

Функция ПолучитьСоответствиеСпецсимволовТегамHTML()
	
	соотвСимволыТеги = Новый Соответствие;
	соотвСимволыТеги.Вставить(Символы.ПС, "<br>");
	Возврат соотвСимволыТеги;
	
КонецФункции

// Замещает обычные пробелы в тексте на спецсимволы HTML.
//
// Параметры:
//  Текст	 - Строка	 - произвольный текст.
// 
// Возвращаемое значение:
//   Строка - текст html.
//
Функция СформироватьТекстHTMLСПереносами(Знач Текст) Экспорт
	
	соотвСимволыТеги = ПолучитьСоответствиеСпецсимволовТегамHTML();
		
	ТекстБезТегов = РаботаСDOMКлиентСервер.ПолучитьВнутреннийHTMLТекстовогоСодержимого(Текст);
	ДлинаСтроки = СтрДлина(ТекстБезТегов);
	
	ТекстHTML = "";
	ДлинаПоследовательностиПробелов = 0;
	Для Сч = 1 По ДлинаСтроки Цикл
		ТекСимвол = Сред(ТекстБезТегов, Сч, 1);
		ВставляемыйСимвол = "";
		ТегСоответствие = соотвСимволыТеги.Получить(ТекСимвол);
		Если ТекСимвол = " " Тогда
			ДлинаПоследовательностиПробелов = ДлинаПоследовательностиПробелов + 1;
		ИначеЕсли ТегСоответствие = Неопределено Тогда 
			ВставляемыйСимвол = ТекСимвол;
		Иначе
			ВставляемыйСимвол = ТегСоответствие;
		КонецЕсли;
		
		Если ВставляемыйСимвол <> "" Тогда
			ПоследовательностьПробелов = "";
			Если ДлинаПоследовательностиПробелов > 0 Тогда 
				Если ДлинаПоследовательностиПробелов = 1 Тогда
					ПоследовательностьПробелов = " ";
				ИначеЕсли ДлинаПоследовательностиПробелов > 1 Тогда 
					ПоследовательностьПробелов = СтроковыеФункцииКлиентСервер.СформироватьСтрокуСимволов("&nbsp;", ДлинаПоследовательностиПробелов - 1) + " ";
				КонецЕсли;	
			КонецЕсли;
			ДлинаПоследовательностиПробелов = 0;
			ТекстHTML = ТекстHTML + ПоследовательностьПробелов + ВставляемыйСимвол;
		КонецЕсли;
			
	КонецЦикла;
	
	Возврат ТекстHTML;
		
КонецФункции

// Формирует из таблицы значений отобржаемую таблицу HTML документа.
//
// Параметры:
//  ТабЗначений	 - ТаблицаЗначений	 - таблица.
// 
// Возвращаемое значение:
//  Строка - текст html.
//
Функция ТаблицаЗначенийВТаблицуHTML(ТабЗначений) Экспорт
	
	МассивИменКолонок = Новый Массив;
	
	КоличествоКолонок = ТабЗначений.Колонки.Количество();
	
	Если КоличествоКолонок < 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
			
	ШиринаТаблицы = " style=""width: 21 cm"""; 
	ТаблицаHTML = "<table border=""1"" cellpadding=""1"" cellspacing=""0"" " + ШиринаТаблицы + ">
				|<tbody>
				|<tr>";
		
	// Формируем шапку
	Для Счетчик = 1 по КоличествоКолонок Цикл
		ИмяКолонки = ТабЗначений.Колонки[Счетчик-1].Заголовок;
		ТаблицаHTML = ТаблицаHTML + " 
				|<td align=""center"">" + ИмяКолонки + "</td>";	
		МассивИменКолонок.Добавить(ТабЗначений.Колонки[Счетчик-1].Имя);
	КонецЦикла;
	ТаблицаHTML = ТаблицаHTML + "
				|</tr>";
	
	// Заполняем таблицу	
	Для каждого СтрокаТаблицы Из ТабЗначений Цикл
		ТаблицаHTML = ТаблицаHTML + "
				|<tr>";
		Для Счетчик = 0 по КоличествоКолонок - 1 Цикл
			ТаблицаHTML = ТаблицаHTML + "
				|<td>" + ?(СтрокаТаблицы[МассивИменКолонок[Счетчик]] = "", "&nbsp;", СтрокаТаблицы[МассивИменКолонок[Счетчик]]) + "</td>";			
		КонецЦикла;				
		ТаблицаHTML = ТаблицаHTML + "
				|</tr>";
	КонецЦикла;	
	
	ТаблицаHTML = ТаблицаHTML + " 
				|</tbody>
				|</table>";
	
	Возврат ТаблицаHTML;

КонецФункции

// Возвращает текст HTML-документа, получаемого  из исходного переносом стилей из тега HEAD в тело документа.
//
// Параметры:
//  ТекстHTML	 - Строка	 - Текст HTML.
// 
// Возвращаемое значение:
//  Строка - текст html.
//
Функция ПеренестиСтилиИзHeadВТелоДокумента(ТекстHTML) Экспорт
	
	ДокументHTML = РаботаСDOMКлиентСервер.СоздатьДокументDOM(ТекстHTML);
	
	// Перенести все стили в body
	Для Каждого ЭлементЗаголовка Из ДокументHTML.ПолучитьЭлементыПоИмени("head") Цикл
		Для Каждого ЭлементСтиляЗаголовка Из ЭлементЗаголовка.ПолучитьЭлементыПоИмени("style") Цикл
			ДокументHTML.Тело.ВставитьПеред(ЭлементСтиляЗаголовка, ДокументHTML.Тело.ПервыйДочерний);
		КонецЦикла;
	КонецЦикла;
	
	ОсновныеСтили = Новый Соответствие;
	МассивСтилейКУдалению = Новый Массив;
	Для Каждого ЭлементСтиля Из ДокументHTML.ПолучитьЭлементыПоИмени("style") Цикл
		
		ТипМедиа = ЭлементСтиля.ПолучитьАтрибут("media");
		ОсновнойСтиль = ОсновныеСтили.Получить(ТипМедиа);
		Если ОсновнойСтиль = Неопределено Тогда
			ОсновныеСтили.Вставить(ТипМедиа, ЭлементСтиля);
		Иначе
			// Перенести значение стиля в основной стиль соответствующего типа
			ОсновнойСтиль.ПервыйДочерний.ЗначениеУзла = ОсновнойСтиль.ПервыйДочерний.ЗначениеУзла + Символы.ПС + ЭлементСтиля.ПервыйДочерний.ЗначениеУзла;
			МассивСтилейКУдалению.Добавить(ЭлементСтиля);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ЭлементСтиля Из МассивСтилейКУдалению Цикл
		Попытка
			ЭлементСтиля.РодительскийУзел.УдалитьДочерний(ЭлементСтиля);
		Исключение КонецПопытки;
	КонецЦикла;
	
	Возврат РаботаСDOMКлиентСервер.ПолучитьТекстHTMLДокументаDOM(ДокументHTML);
	
КонецФункции

// Возвращает Истина, если в HTML-тексте тега атрибут встречается чаще, чем в его внутреннем HTML-тексте.
//
// Параметры:
//  ИмяАтрибута	 - Строка - Искомый атрибут с достаточно уникальным именем.
//  outerHTML	 - Строка - outer HTML тега.
//  innerText	 - Строка - inner HTML тега.
// 
// Возвращаемое значение:
//   Булево.
//
Функция ЕстьАтрибутВТекстеТега(ИмяАтрибута, outerHTML, innerText) Экспорт
	Возврат СтрЧислоВхождений(outerHTML,ИмяАтрибута) <> СтрЧислоВхождений(innerText,ИмяАтрибута);
КонецФункции

// Возвращает ближайший родительский элемент (или сам элемент) по заданному имени узла
//
// Параметры:
//  ЭлементHTML	 - ЭлементHTML, ВнешнийОбъект	 - Объект HTML
//  ИмяУзла		 - Строка						 - Имя разыскиваемого узла
// 
// Возвращаемое значение:
//  ЭлементHTML, ВнешнийОбъект, Неопределено - 
//
Функция ПолучитьБлижайшийУзел(ЭлементHTML, ИмяУзла) Экспорт
	
	Если ЭлементHTML = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ЭтоВнешнийОбъект(ЭлементHTML) Тогда
		Возврат ЭлементHTML.closest(ИмяУзла);
	КонецЕсли;
	
	ТекущийУзел = ЭлементHTML;
	Пока ТекущийУзел <> Неопределено
		И ВРег(ТекущийУзел.ИмяУзла) <> "BODY"
	Цикл
		Если ВРег(ТекущийУзел.ИмяУзла) = ВРег(ИмяУзла) Тогда
			Возврат ТекущийУзел;
		КонецЕсли;
		ТекущийУзел = ТекущийУзел.РодительскийУзел;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

#Область ТабличныеДокументы // Табличные документы в HTML-шаблонах приёма.

// Переносит стили табличного документа, сохраненного в HTML, из тега HEAD в тело html-документа.
//
// Параметры:
//  ТекстHTML	 - Строка - текст документа, полученного из табличного документа.
// 
// Возвращаемое значение:
//   Строка.
//
Функция ПеренестиСтилиИзHeadВТелоДокументаСЗаменойИменКлассов(ТекстHTML) Экспорт
	
	ДокументHTML = РаботаСDOMКлиентСервер.СоздатьДокументDOM(ТекстHTML);
	Head = ДокументHTML.ПолучитьЭлементыПоИмени("head");
	Если Head.Количество() > 0 Тогда		
		Стили = Head[0].ПолучитьЭлементыПоИмени("style");
		Если Стили.Количество() > 0 Тогда
			
			УИД					= Новый УникальныйИдентификатор;
			КлассыДляИзменения	= Новый Соответствие;
			НовыеКлассы			= Новый Массив;
			ПолучитьИменаКассовHTMLДокумента(ДокументHTML.Тело, Стили[0].ПервыйДочерний.ЗначениеУзла, КлассыДляИзменения, НовыеКлассы, УИД);
			
			// Переименование классов 
			Для Каждого Класс Из КлассыДляИзменения Цикл				
				
				Список = ДокументHTML.ПолучитьЭлементыПоИмени(Класс.Значение.ИмяУзла);
				Если ЗначениеЗаполнено(Класс.Ключ) Тогда
					Для Каждого Элемент Из Список Цикл
						Если Элемент.ИмяКласса = Класс.Ключ Тогда
							Элемент.ИмяКласса = Элемент.ИмяКласса + "_" + УИД;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
				
				Стили[0].ПервыйДочерний.ЗначениеУзла = СтрЗаменить(Стили[0].ПервыйДочерний.ЗначениеУзла, Класс.Значение.ИсхдныйКлассВСтилях, Класс.Значение.НовыйКлассВСтилях);				
			КонецЦикла;
			
			// Для каждого td и table создается, либо добавляется новый класс
			Для Каждого ИмяУзла Из НовыеКлассы Цикл
				
				ИсходнаяСтрокаЭлементаВСтилях = Сред(Стили[0].ПервыйДочерний.ЗначениеУзла, Найти(Стили[0].ПервыйДочерний.ЗначениеУзла, ИмяУзла + " {"));
				ОкончаниеТекста = Найти(ИсходнаяСтрокаЭлементаВСтилях, "}");
				ИсходнаяСтрокаЭлементаВСтилях = Лев(ИсходнаяСтрокаЭлементаВСтилях, ОкончаниеТекста);
				
				Если ЗначениеЗаполнено(ИсходнаяСтрокаЭлементаВСтилях) Тогда
					
					Список = ДокументHTML.ПолучитьЭлементыПоИмени(ИмяУзла);
					Для Каждого Элемент Из Список Цикл
						Если ЗначениеЗаполнено(Элемент.ИмяКласса) Тогда
							Элемент.ИмяКласса = Элемент.ИмяКласса + " " + ИмяУзла + "_" + УИД;
						Иначе
							Элемент.ИмяКласса = ИмяУзла + "_" + УИД;
						КонецЕсли;
					КонецЦикла;
					
					НоваяСтрокаЭлементаВСтилях = СтрЗаменить(ИсходнаяСтрокаЭлементаВСтилях, ИмяУзла + " {", ИмяУзла + "." + ИмяУзла + "_" + УИД + " {");
					
					Стили[0].ПервыйДочерний.ЗначениеУзла = СтрЗаменить(Стили[0].ПервыйДочерний.ЗначениеУзла, ИсходнаяСтрокаЭлементаВСтилях, НоваяСтрокаЭлементаВСтилях);
				КонецЕсли;
			КонецЦикла;
			
			// Перенести тег стиля из head в body
			ДокументHTML.Тело.ВставитьПеред(Стили[0],ДокументHTML.Тело.ПервыйДочерний);
			Возврат РаботаСDOMКлиентСервер.ПолучитьТекстHTMLДокументаDOM(ДокументHTML);
		КонецЕсли;
	КонецЕсли;
	
	Возврат ТекстHTML;
	
КонецФункции

// Удаляет глобальные и внутренние стили элемента из текста html-документа.
//
// Параметры:
//  ТекстHTML	 - Строка - текст html-документа.
//  ИмяЭлемента	 - Строка - имя элемента, стиль которого необходимо удалить.
// 
// Возвращаемое значение:
//   Строка.
//
Функция УдалитьСтильЭлемента(ТекстHTML, ИмяЭлемента = "body") Экспорт
	
	ДокументHTML = РаботаСDOMКлиентСервер.СоздатьДокументDOM(ТекстHTML);
	
	// Удаление внутренних стилей
	Элементы = ПолучитьЭлементыПоИмени(ДокументHTML, ИмяЭлемента);
	Для Каждого Элемент Из Элементы Цикл
		Попытка
			Элемент.Атрибуты.УдалитьИменованныйЭлемент("style");
		Исключение
			Продолжить;
		КонецПопытки;
	КонецЦикла;
	
	// Удаление глобальных стилей
	СтилиТела = ДокументHTML.Тело.ПолучитьЭлементыПоИмени("style");
	Для Каждого СтильТела Из СтилиТела Цикл
		
		Попытка
			НовыеСтрокиЭлементов = Новый Массив;
			ЗначениеСтиля = СтильТела.ПервыйДочерний.ЗначениеУзла;
			СтрокиЭлементов = СтрРазделить(ЗначениеСтиля, "}");
			Для Каждого СтрокаЭлемента Из СтрокиЭлементов Цикл
				
				СтильЭлемента = СтрЗаменить(СтрокаЭлемента, Символы.ПС, "");
				Если ПустаяСтрока(СтильЭлемента) Тогда
					Продолжить;
				КонецЕсли;
				
				СтруктураСтиляЭлемента = СтрРазделить(СтильЭлемента, "{");
				
				Если НРег(СокрЛП(СтруктураСтиляЭлемента[0])) = "body" Тогда
					Продолжить;
				Иначе
					НовыеСтрокиЭлементов.Добавить(СтильЭлемента + "}");
				КонецЕсли;
			КонецЦикла;
			
			СтильТела.ПервыйДочерний.ЗначениеУзла = СтрСоединить(НовыеСтрокиЭлементов, Символы.ПС);
			
		Исключение КонецПопытки;
	КонецЦикла;
	
	Возврат РаботаСDOMКлиентСервер.ПолучитьТекстHTMLДокументаDOM(ДокументHTML);
	
КонецФункции

// Получить имена кассов HTML документа и сформировать заменяющие уникальные имена классов.
//
// Параметры:
//  ДокументHTML		 - ДокументDOM	 - документ.
//  Стили				 - Строка	 - стили через запятую
//  КлассыДляИзменения	 - Массив	 - имена старых классов.
//  НовыеКлассы			 - Массив	 - имена новых классов для возврата из процедуры.
//  УИД					 - Строка	 - идентификатор для присвоения к имени класса.
//
Процедура ПолучитьИменаКассовHTMLДокумента(ДокументHTML, Стили, КлассыДляИзменения, НовыеКлассы, УИД)
	
	Если Не ДокументHTML.Атрибуты = Неопределено
		И Не ДокументHTML.ПолучитьАтрибут("class") = Неопределено
	Тогда
		Если Найти(Стили, ДокументHTML.ИмяКласса+"{") <> 0 Тогда
			Если КлассыДляИзменения[ДокументHTML.ИмяКласса] = Неопределено Тогда
				ЗначениеКласса = Новый Структура;
				ЗначениеКласса.Вставить("ИсхдныйКлассВСтилях", ДокументHTML.ИмяУзла + "." + ДокументHTML.ИмяКласса);
				ЗначениеКласса.Вставить("НовыйКлассВСтилях", ДокументHTML.ИмяУзла + "." + ДокументHTML.ИмяКласса + "_" + УИД);
				ЗначениеКласса.Вставить("ИмяУзла", ДокументHTML.ИмяУзла);
				КлассыДляИзменения.Вставить(ДокументHTML.ИмяКласса, ЗначениеКласса);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если ДокументHTML.ИмяУзла = "td" Или ДокументHTML.ИмяУзла = "table" Тогда
		Если НовыеКлассы.Найти(ДокументHTML.ИмяУзла) = Неопределено Тогда
			НовыеКлассы.Добавить(ДокументHTML.ИмяУзла);
		КонецЕсли;
	КонецЕсли;
	
	Для Каждого ДочернийУзел Из ДокументHTML.ДочерниеУзлы Цикл
		
		ПолучитьИменаКассовHTMLДокумента(ДочернийУзел, Стили, КлассыДляИзменения, НовыеКлассы, УИД);
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти