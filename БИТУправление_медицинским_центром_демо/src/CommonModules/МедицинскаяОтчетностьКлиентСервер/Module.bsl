 
#Область ПрограммныйИнтерфейс

// Возвращает свойства раздела.
//
Функция ПолучитьСвойствоРаздела(Форма, Знач ИмяСтраницы, Знач ИмяСвойства, ВозвращаемоеЗначение = Неопределено) Экспорт

	Результат = Неопределено;

	Если ТипЗнч(Форма.мСвойстваРазделовДекларации) <> Тип("ДанныеФормыДерево") Тогда
		Возврат Результат;
	КонецЕсли;
    	
	ИмяСтраницыП = ИмяСтраницы;
	
	Для Каждого СтрокаУровня1 Из Форма.мСвойстваРазделовДекларации.ПолучитьЭлементы() Цикл
		Если ИмяСтраницыП = СтрокаУровня1.ИмяСтраницы Тогда
			
			Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(СтрокаУровня1, ИмяСвойства) Тогда
				
				Результат = СтрокаУровня1[ИмяСвойства];
				
			Иначе
				
				Результат = ВозвращаемоеЗначение;
				
			КонецЕсли;

			Прервать;
		КонецЕсли;
	КонецЦикла;

	Возврат Результат;

КонецФункции

// Возвращает признак определения свойства.
//
Функция СвойствоОпределено(Объект, ИмяСвойства) Экспорт
	
	ГУИД = Новый УникальныйИдентификатор;
	ВремСтрукт = Новый Структура(ИмяСвойства, ГУИД);
	ЗаполнитьЗначенияСвойств(ВремСтрукт, Объект);
	Возврат (ВремСтрукт[ИмяСвойства] <> ГУИД);
	
КонецФункции

// Сохраняет данные многостраничного раздела текущей страницы.
//
Процедура СохранитьДанныеМногостраничногоРазделаВактивнойСтранице(Форма, ИмяТекущейСтраницы, ОчищатьРазделЕслиЕстьМногострочность) Экспорт
	Перем ТаблицаСтраницРаздела;

	ИмяТекТабличногоПоля = "ТабличныйДокумент";
	ТекТабличноеПоле     = Форма[ИмяТекТабличногоПоля];
    	
	Если Не Форма.мСтруктураМногостраничныхРазделов.Свойство(ИмяТекущейСтраницы, ТаблицаСтраницРаздела) Тогда
		Возврат;
	КонецЕсли;
	
	ТаблицаСтраницРаздела = Форма[ТаблицаСтраницРаздела];

	// Возьмем активную страницу
	СтрТаблицаСтраницы = ТаблицаСтраницРаздела.НайтиСтроки(Новый Структура("АктивнаяСтраница", Истина));

	// Если нет активной страницы - то выход
	Если СтрТаблицаСтраницы.Количество() = 0 Тогда
		
		Если ОчищатьРазделЕслиЕстьМногострочность Тогда
			#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
				Форма.ОчиститьТабличноеПолеНаКлиенте(ИмяТекущейСтраницы);
			#Иначе
				Форма.ОчиститьТабличноеПолеНаСервере(ИмяТекущейСтраницы);
			#КонецЕсли
		КонецЕсли;
		
		Возврат;
		
	Иначе
		СтрТаблицаСтраницы = СтрТаблицаСтраницы[0];
	КонецЕсли;
    
	// Сохраним данные текущей страницы.
	// В каждой декларации функция СобратьДанныеТекущегоТаблПоля - разные !
	#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
		СтруктураДанныхТекущейТаблицы = Форма.СобратьДанныеТекущегоТаблПоляНаКлиенте(ИмяТекТабличногоПоля);
	#Иначе
		СтруктураДанныхТекущейТаблицы = Форма.СобратьДанныеТекущегоТаблПоляНаСервере(ИмяТекТабличногоПоля);
	#КонецЕсли
	
	КолМногострочныхЧастей = ПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницы, "МногострочностьВРазделе").Количество();
		
	// Определяет, как работать с многострочностью в документе, либо как с ТаблЗначений или со структурой

	СохранятьМногострКакТЗ = ПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницы, "СохранятьМногострКакТЗ");

	// Если лист является многострочным и многостраничным, то необходимо добавить в поле данные доп. строк
	// в этой декларации не используется, т.к. многострочность одна на листе
	Если (КолМногострочныхЧастей > 0) И (НЕ СохранятьМногострКакТЗ) Тогда

		ВРазделеДекларацииЕстьМногострочность = Истина;
		// Определим ИмяГруппы дополнительных строк, по необходимой страницы
		// Если на листе больше одной многострочной части, то алгорит сбора будет другим

		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			СтруктураДанныхДопСтрокРаздела = Форма.СформироватьСтруктуруДанныхДопСтрокСтраницыКлиент(ИмяТекущейСтраницы);
		#Иначе
			СтруктураДанныхДопСтрокРаздела = Форма.СформироватьСтруктуруДанныхДопСтрокСтраницы(ИмяТекущейСтраницы);
		#КонецЕсли
			
		ТаблицаДопСтрокРаздела = СтруктураДанныхДопСтрокРаздела;

	ИначеЕсли (КолМногострочныхЧастей > 0) И (СохранятьМногострКакТЗ) Тогда

		ВРазделеДекларацииЕстьМногострочность = Истина;
		// Блок для разделов, где хранится только одна многострочная часть
		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			ИмяГруппыДопСтрок = Форма.ОпределитьИдМногострочногоРазделаПоАктивнойСтраницеНаКлиенте(ИмяТекущейСтраницы);
			Форма.ОбновитьСтруктуруМногострочногоРазделаНаКлиенте(ИмяГруппыДопСтрок);
		#Иначе
			ИмяГруппыДопСтрок = Форма.ОпределитьИдМногострочногоРазделаПоАктивнойСтраницеНаСервере(ИмяТекущейСтраницы);
			Форма.ОбновитьСтруктуруМногострочногоРазделаНаСервере(ИмяГруппыДопСтрок);
		#КонецЕсли

		// Получим таблицу значений, содержащую данные дополнительных строк.
		ПромТаблицаДопСтрокРаздела = Неопределено;
		Форма.мСтруктураМногострочныхРазделов.Свойство(ИмяГруппыДопСтрок, ПромТаблицаДопСтрокРаздела);
		ПромТаблицаДопСтрокРаздела = Форма[ПромТаблицаДопСтрокРаздела];
											
		ТаблицаДопСтрокРаздела = Форма["Хранилище" + ИмяГруппыДопСтрок].Добавить().Таблица;
						
		КопироватьДанныеФормы(ПромТаблицаДопСтрокРаздела, ТаблицаДопСтрокРаздела);
		                        		
	ИначеЕсли КолМногострочныхЧастей = 0 Тогда

		ВРазделеДекларацииЕстьМногострочность = Ложь;

	КонецЕсли;

	// Сохраним данные
	СтрТаблицаСтраницы.Данные.Очистить();
	СтрТаблицаСтраницы.Данные.Добавить(СтруктураДанныхТекущейТаблицы);
		
	Если ВРазделеДекларацииЕстьМногострочность Тогда
        		
		Если ОчищатьРазделЕслиЕстьМногострочность Тогда
			#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
				Форма.ОчиститьТабличноеПолеНаКлиенте(ИмяТекущейСтраницы);
			#Иначе
				Форма.ОчиститьТабличноеПолеНаСервере(ИмяТекущейСтраницы);
			#КонецЕсли
		КонецЕсли;
        		
		// Запишем данные доп. строк
						
		Если (СтрТаблицаСтраницы.ДанныеДопСтрок.Количество() > 0) 
		   И (СтрТаблицаСтраницы.ДанныеДопСтрок[0].Представление = "ДанныеФормыКоллекцияТаблицаДопСтрокРаздела") Тогда
			
			СтрТаблицаСтраницы.ДанныеДопСтрок[0].Значение = ТаблицаДопСтрокРаздела;
			
		Иначе
			
		   СтрТаблицаСтраницы.ДанныеДопСтрок.Добавить(ТаблицаДопСтрокРаздела, "ДанныеФормыКоллекцияТаблицаДопСтрокРаздела");
			
		КонецЕсли;
		
	КонецЕсли;

	// Попытаемся определить представление, только по текущей странице (по активной), последний параметр Истина
	ОпределитьПредставлениеДопСтраниц(Форма, ИмяТекущейСтраницы, Истина);

КонецПроцедуры

// Дополняет строку.
//
Функция ДополнитьСтроку(Знач Стр, Длина, Чем=" ", Режим = 0) Экспорт
	
	СимволовДополнить = Длина -  СтрДлина(Стр);
	Добавок = "";
	Для Н=1 По СимволовДополнить Цикл
		Добавок =	Добавок + Чем;
	КонецЦикла;
	Возврат ?(Режим=0, Добавок + Стр, Стр + Добавок);
	
КонецФункции

// Обновляет структуру многостраничных разделов.
//
Процедура ОбновитьСтруктуруМногостраничныхРазделов(Форма, ИмяСтраницы = Неопределено) Экспорт
    	
	Для Каждого Страница Из Форма.мСтруктураМногостраничныхРазделов Цикл
		ИмяТекущейСтраницыПанели = Страница.Ключ;
		ТаблицаТекущейСтраницы   = Форма[Страница.Значение];

		Если ИмяСтраницы <> Неопределено Тогда
			Если ИмяСтраницы <> ИмяТекущейСтраницыПанели Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;

		// Для декларации по прибыли, специальные два раздела сохраняются особым образом
		// пришлось внести изменения в общий модуль и процедуру для всех отчетов

		Если (ИмяТекущейСтраницыПанели = "Лист03_РазделыБВ1") Или (ИмяТекущейСтраницыПанели = "Лист03_РазделыБВ2") Тогда
			
			#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
				Форма.СохранитьДанныеМногостраничногоРазделаВактивнойСтраницеРешенияКлиент(ИмяТекущейСтраницыПанели);
			#Иначе
				Форма.СохранитьДанныеМногостраничногоРазделаВактивнойСтраницеРешения(ИмяТекущейСтраницыПанели);
			#КонецЕсли
			
		Иначе

		// Обновляя представления сохранения активного листа декларации
		// Параметр Ложь - не позволяет удалять многострочные части, если они есть на листе
			СохранитьДанныеМногостраничногоРазделаВактивнойСтранице(Форма, ИмяТекущейСтраницыПанели, Ложь);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Возвращает таблицу отчетов, действующих в выбранном отчетном периоде.
//
Функция ПолучитьТаблицуОтчетовДействующихВВыбранныйПериод(Форма) Экспорт

	Форма.РезультирующаяТаблица.Очистить();
	
	ЕстьКолонкаРедакцияФормы = Ложь;
	Для каждого ЭлФорма Из Форма.мТаблицаФормОтчета Цикл
		
		ЕстьКолонкаРедакцияФормы = ЭлФорма.Свойство("РедакцияФормы");
		Прервать;
			
	КонецЦикла;
	
	// Осуществим перебор по таблице содеражащей формы отчетов и периоды действий.
	// При занесении строк РезультирующаяТаблица попутно отсортируем,
	// это нужно чтобы избежать в дальнейшем метода ДанныеФормыКоллекция.Сортировать()
	// на Клиенте, который вызывает Серверный вызов.
	СписокДатКонца = Новый СписокЗначений;
	Для Каждого ЭлФорма Из Форма.мТаблицаФормОтчета Цикл
		
		ДатаНачалаДействияФормы = ЭлФорма.ДатаНачалоДействия;
		ДатаКонцаДействияФормы  = КонецДня(?(ЭлФорма.ДатаКонецДействия = ПустоеЗначениеТипа(Тип("Дата")), '20991231', ЭлФорма.ДатаКонецДействия));
		
		Если Форма.мДатаКонцаПериодаОтчета <= ДатаКонцаДействияФормы
		   И Форма.мДатаКонцаПериодаОтчета >= ДатаНачалаДействияФормы Тогда
			
			ТекущаяДатаКонца = СписокДатКонца.Добавить(ДатаКонцаДействияФормы);
			
			// Обход ошибки платформы: в тонком и веб клиентах сортировка списка значений,
			// состоящего из одинаковых значений типа Дата, ошибочно производится по-разному.
			КоличествоОдинаковыхЗначений = 0;
			ОбщееКоличествоЗначений      = СписокДатКонца.Количество();
			Для каждого ЭлемСписка Из СписокДатКонца Цикл
				Если ЭлемСписка.Значение = СписокДатКонца[0].Значение Тогда
					КоличествоОдинаковыхЗначений = КоличествоОдинаковыхЗначений + 1;
				КонецЕсли;
			КонецЦикла;
			Если КоличествоОдинаковыхЗначений <> ОбщееКоличествоЗначений Тогда
				СписокДатКонца.СортироватьПоЗначению(НаправлениеСортировки.Убыв);
			КонецЕсли;
			
			ПозицияТекущейДаты  = СписокДатКонца.Индекс(ТекущаяДатаКонца);
			
			// Перебираемая запись из таблицы форм удовлетворяет текущим параметрам
			// учитывая конец периода отчета.
			НоваяФорма = Форма.РезультирующаяТаблица.Добавить();
			НоваяФорма.ФормаОтчета        = ЭлФорма.ФормаОтчета;
			НоваяФорма.ОписаниеОтчета     = ЭлФорма.ОписаниеОтчета;
			НоваяФорма.ДатаНачалоДействия = ЭлФорма.ДатаНачалоДействия;
			НоваяФорма.ДатаКонецДействия  = ЭлФорма.ДатаКонецДействия;
			
			Если ЕстьКолонкаРедакцияФормы Тогда
			
				НоваяФорма.РедакцияФормы	  = ЭлФорма.РедакцияФормы;
			
			КонецЕсли;
			
			// Сдвигаем новую запись так чтобы коллекция оставалась отсортированной
			// по ДатаКонецДействия.
			ПозицияНовойФормы = Форма.РезультирующаяТаблица.Индекс(НоваяФорма);
			НаСколькоСдвинуть = ПозицияТекущейДаты - ПозицияНовойФормы;
			Форма.РезультирующаяТаблица.Сдвинуть(ПозицияНовойФормы, НаСколькоСдвинуть);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Форма.РезультирующаяТаблица;
	
КонецФункции

// Возвращает количество листов в разделе.
//
Функция КолвоЛистоВРазделе(Форма, ИмяСтраницыПанели) Экспорт

	ФлагИскл = 0;
	КолЛистовВОдномерномЛисте = 1;

	ТекТаблПоле = Форма["ПолеТабличногоДокумента" + ИмяСтраницыПанели];

	Пока ФлагИскл = 0 Цикл

		Если КолЛистовВОдномерномЛисте = 1 Тогда
			КолЛистовВОдномерномЛистеСтр = "";
		Иначе
			КолЛистовВОдномерномЛистеСтр = Формат(Число(КолЛистовВОдномерномЛисте)) + "_";
		КонецЕсли;

		Если ТекТаблПоле.Области.Найти("НомСтр" + КолЛистовВОдномерномЛистеСтр + "1") <> Неопределено Тогда

			КолЛистовВОдномерномЛисте = КолЛистовВОдномерномЛисте + 1;

		Иначе

			КолЛистовВОдномерномЛисте = КолЛистовВОдномерномЛисте - 1;
			ФлагИскл = 1;

		КонецЕсли;

	КонецЦикла;// пока искл = 0

	Возврат КолЛистовВОдномерномЛисте;

КонецФункции

// Возвращает представление Медицинского отчета.
//
Функция ПредставлениеДокументаМедОтч(Док) Экспорт
	
	Представление = "";
	
	#Если Сервер Тогда
		Если ТипЗнч(Док) = Тип("ДокументСсылка.МедицинскийОтчет") Тогда
			Представление = Док.НаименованиеОтчета + " ";
		КонецЕсли;
	#КонецЕсли
		
	Если ТипЗнч(Док) = Тип("ДанныеФормыЭлементКоллекции") Тогда
		
		Представление = Док.Отчет + " ";
		
	ИначеЕсли ТипЗнч(Док) = Тип("Структура") И Док.Свойство("НаименованиеОтчета") Тогда
		
		Представление = Док.НаименованиеОтчета + " ";
			
	КонецЕсли;
	
	Если СтрНачинаетсяС(Представление, "Страновой отчет") Тогда
		Представление = "Страновой отчет с " + Формат(Док.ДатаНачала, "ДФ=""дд.ММ.гггг""")
		+ " по " + Формат(Док.ДатаОкончания, "ДФ=""дд.ММ.гггг""");
		
	ИначеЕсли СтрНачинаетсяС(Представление, "Уведомление об участии в международной группе компаний") Тогда
		Представление = "Уведомление об участии в международной группе компаний на "
		+ ПредставлениеПериода(НачалоДня(Док.ДатаНачала), КонецДня(Док.ДатаОкончания), "ФП=Истина");
		
	ИначеЕсли СтрНачинаетсяС(Представление, "Исполнение контрактов ГОЗ") Тогда
		Представление = "Исполнение контрактов ГОЗ на "
		+ ПредставлениеПериода(НачалоДня(Док.ДатаНачала), КонецДня(Док.ДатаОкончания), "ФП=Истина");
		
		Возврат Представление;
		
	Иначе
		Представление = Представление + "за " + ПредставлениеПериода(НачалоДня(Док.ДатаНачала), КонецДня(Док.ДатаОкончания), "ФП=Истина");
		
	КонецЕсли;
	
	Если Док.Вид = 0 ИЛИ Док.Вид = "П" Тогда
		
		Представление = Представление + " (Первичный";
		
	Иначе
		
		Представление = Представление + " (Корректирующий, номер корректировки " + Док.Вид;
		
	КонецЕсли;
	
	Возврат Представление;
	
КонецФункции

// Процедура вызывается после вставки дополнительной страницы.
//
Процедура ПослеВставкиДополнительнойСтраницы(Форма, ИмяВставляемойСтраницы, ПерейтиНаВставленныйЛист = Истина) Экспорт
	
	ТекущийЭлемент = Форма.РазделыОтчета.НайтиПоИдентификатору(Форма.Элементы.РазделыОтчета.ТекущаяСтрока);
	
	Родитель = ТекущийЭлемент.ПолучитьРодителя();

	Если НЕ Родитель = Неопределено Тогда
		ТекущийЭлемент = Родитель;
	КонецЕсли;
    	
	НомерДобавляемойСтраницы = ТекущийЭлемент.ПолучитьЭлементы().Количество() + 1;
    	
	ДобавляемаяСтраница = ТекущийЭлемент.ПолучитьЭлементы().Добавить();
	ДобавляемаяСтраница.КолонкаРазделыОтчета              = "Стр. " + НомерДобавляемойСтраницы;
	ДобавляемаяСтраница.КолонкаРазделыОтчетаСокрНаим      = ТекущийЭлемент.КолонкаРазделыОтчетаСокрНаим;
	ДобавляемаяСтраница.КолонкаНомерСтраницыРазделаОтчета = НомерДобавляемойСтраницы;
	ДобавляемаяСтраница.ИндексКартинки                    = 1;
	ДобавляемаяСтраница.РазделМногостраничный             = ТекущийЭлемент.РазделМногостраничный;
	ДобавляемаяСтраница.РазделМногострочный               = ТекущийЭлемент.РазделМногострочный;
	
	Если ПерейтиНаВставленныйЛист Тогда
		Форма.Элементы.РазделыОтчета.ТекущаяСтрока = ДобавляемаяСтраница.ПолучитьИдентификатор();
	КонецЕсли;

КонецПроцедуры

// Устанавливает номера листов.
//
Процедура ПроставлениеНомеровЛистов(Объект, ПризнакНумеруемыхФорм, СписокПечатаемыхЛистов) Экспорт
	
	Если ТипЗнч(Объект) = Тип("ФормаКлиентскогоПриложения") Тогда
		
		СтруктураРеквизитовФормы = Объект.СтруктураРеквизитовФормы;
		
	ИначеЕсли ТипЗнч(Объект) = Тип("Структура") Тогда
		
		Если Объект.Свойство("СтруктураРеквизитовФормы") Тогда
		    СтруктураРеквизитовФормы = Объект.СтруктураРеквизитовФормы;
		Иначе	
		    СтруктураРеквизитовФормы = Объект;
		КонецЕсли;
		
	КонецЕсли;
		
	Если ПризнакНумеруемыхФорм = Неопределено Тогда
		ПризнакНумеруемыхФорм = Истина;
	КонецЕсли;
		
	Если ПризнакНумеруемыхФорм Тогда
		Если СтруктураРеквизитовФормы.мСчетчикСтраниц <> Истина Тогда
			НомерЛиста = 1;
			Для Каждого Эл Из СтруктураРеквизитовФормы.мПечатныеФормы Цикл
				Если НЕ УдалосьПроставитьНомерСтраницы(Эл, НомерЛиста) Тогда
										
					Сообщение = Новый СообщениеПользователю;

					Сообщение.Текст = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Не удалось проставить номер страницы для %1'"), Эл.Представление);

					Сообщение.Сообщить();
					
					Продолжить;
					
				КонецЕсли;
				НомерЛиста = НомерЛиста + 1;
			КонецЦикла;
			Если СтруктураРеквизитовФормы.мПечатныеФормы.Количество() <> 0 Тогда
				ТаблДок = СтруктураРеквизитовФормы.мПечатныеФормы.Получить(0).Значение;
				ЦифрВОбщемКоличествеЛистов = 0;
				Для ОбратныйИндекс = 1 По 9 Цикл
					Индекс = 10 - ОбратныйИндекс;
					Если ТаблДок.Области.Найти("СоставленаНа" + Индекс) <> Неопределено Тогда
						ЦифрВОбщемКоличествеЛистов = Индекс;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				ВсегоЛистов = Формат(НомерЛиста - 1, "ЧЦ=" + ЦифрВОбщемКоличествеЛистов + "; ЧН=0; ЧВН=; ЧГ=");
				Для Инд = 1 По ЦифрВОбщемКоличествеЛистов Цикл
					ТекИнд = ЦифрВОбщемКоличествеЛистов - Инд + 1;
					Попытка
						ТаблДок.Области["СоставленаНа" + ТекИнд].Значение = Сред(ВсегоЛистов, ТекИнд, 1);
					Исключение
					КонецПопытки;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	НомераЛистов = Новый СписокЗначений;
	
	НомерЛиста = 1;
	
	Для Каждого Эл Из СтруктураРеквизитовФормы.мПечатныеФормы Цикл
		
		НомЛиста = НомераЛистов.НайтиПоЗначению(Эл.Представление);
		
		Если НомЛиста = Неопределено Тогда
			
			НомЛиста = НомераЛистов.Добавить(Эл.Представление, "1");
			
			НЛиста = 1;
			
		Иначе
			
			НЛиста = Число(НомЛиста.Представление) + 1;
			
			НомЛиста.Представление = Строка(Число(НомЛиста.Представление) + 1);
			
		КонецЕсли;
		
		УИД = Новый УникальныйИдентификатор();
		
		Значение = Новый Массив;
		Значение.Добавить(ПоместитьВоВременноеХранилище(Эл.Значение, УИД));
		Значение.Добавить(УИД);
		
		Если ТипЗнч(Объект) = Тип("ФормаКлиентскогоПриложения") Тогда
			
			Значение.Добавить(Объект.Заголовок);
			
		ИначеЕсли ТипЗнч(Объект) = Тип("Структура") Тогда
			
			Если Объект.Свойство("Заголовок") Тогда
			    Значение.Добавить(Объект.Заголовок);
			Иначе	
			    Значение.Добавить("");
			КонецЕсли;
			
		КонецЕсли;
		
		Если НЛиста = 1 Тогда
			
			СписокПечатаемыхЛистов.Добавить(Значение, Эл.Представление);
			
		Иначе
			
			Если НЛиста = 2 Тогда
				
				Для Индекс = 0 По СписокПечатаемыхЛистов.Количество() - 1 Цикл
					
					ОбратныйИндекс = СписокПечатаемыхЛистов.Количество() - 1 - Индекс;
					
					Если СписокПечатаемыхЛистов[ОбратныйИндекс].Представление = Эл.Представление Тогда
						
						СписокПечатаемыхЛистов[ОбратныйИндекс].Представление
							= СписокПечатаемыхЛистов[ОбратныйИндекс].Представление + ". Лист 1";
						
						Прервать;
						
					КонецЕсли;
					
				КонецЦикла;
				
			КонецЕсли;
			
			СписокПечатаемыхЛистов.Добавить(Значение, Эл.Представление + ". Лист " + НЛиста);
			
		КонецЕсли;
		
		НомерЛиста = НомерЛиста + 1;
		
	КонецЦикла;
	
	СтруктураРеквизитовФормы.мПечатныеФормы.Очистить();
	УдалитьСлужебныеСимоволыИзПечатнойФормы(СписокПечатаемыхЛистов);
	
КонецПроцедуры

// Формирует структуру параметров файла выгрузки.
// 
Функция СформироватьСтруктуруПараметровФайлаВыгрузки(ФайлВыгрузки) Экспорт

	ПоказателиВыгрузки = Новый Соответствие;
	ОбъектЧтениеXML = Новый ЧтениеXML;
	Попытка
		ОбъектЧтениеXML.ОткрытьФайл(ФайлВыгрузки);
		ОбъектЧтениеXML.ИгнорироватьПробелы = Ложь;
		Пока ОбъектЧтениеXML.Прочитать() Цикл
			Если Строка(ОбъектЧтениеXML.ТипУзла) = "Начало элемента" И ОбъектЧтениеXML.Имя <> "СодПерСвед" Тогда
				Пока ОбъектЧтениеXML.ПрочитатьАтрибут() Цикл
					ПоказателиВыгрузки.Вставить(ОбъектЧтениеXML.Имя, ОбъектЧтениеXML.Значение);
				КонецЦикла;
			КонецЕсли;
		КонецЦикла;
		ОбъектЧтениеXML.Закрыть();
		ПоказателиВыгрузки.Вставить("ЭтоXML", Истина);
	Исключение
		Текст = Новый ЧтениеТекста;
		Текст.Открыть(ФайлВыгрузки, "cp866");
		ТекСтр = Текст.ПрочитатьСтроку();
		Пока ТекСтр <> Неопределено Цикл
			ТекСтр = СокрЛП(ТекСтр);
			ВхождениеДвоеточия = СтрНайти(ТекСтр, ":");
			Если ВхождениеДвоеточия <> 0 Тогда
				ПоказателиВыгрузки.Вставить(СокрЛП(Лев(ТекСтр, ВхождениеДвоеточия - 1)), СокрЛП(Сред(ТекСтр, ВхождениеДвоеточия + 1)));
			КонецЕсли;
			ТекСтр = Текст.ПрочитатьСтроку();
		КонецЦикла;
		Текст.Закрыть();
		ПоказателиВыгрузки.Вставить("ЭтоXML", Ложь);
	КонецПопытки;
	Возврат ПоказателиВыгрузки;

КонецФункции

// Преобразовывает строку в массив.
// 
Функция РазобратьСтрокуВМассивПоРазделителю(Знач Стр, СтрРазделитель = ".") Экспорт
	
	Результат = Новый Массив;
	
	ВхождениеРазделителя = СтрНайти(Стр, СтрРазделитель);
	Пока ВхождениеРазделителя <> 0 Цикл
		ЧастьДоРазделителя = СокрЛП(Лев(Стр, ВхождениеРазделителя - 1));
		Результат.Добавить(ЧастьДоРазделителя);
		Стр = СокрЛП(Сред(Стр, ВхождениеРазделителя + 1));
		ВхождениеРазделителя = СтрНайти(Стр, СтрРазделитель);
	КонецЦикла;
	
	Если НЕ ПустаяСтрока(Стр) Тогда
		Результат.Добавить(СокрЛП(Стр));
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Проверяет тип на пустое значение.
//
Функция ПустоеЗначениеТипа(ЗаданныйТип) Экспорт

	Если ЗаданныйТип = Тип("Число") Тогда
		Возврат 0;

	ИначеЕсли ЗаданныйТип = Тип("Строка") Тогда
		Возврат "";

	ИначеЕсли ЗаданныйТип = Тип("Дата") Тогда
		Возврат '00010101000000';

	ИначеЕсли ЗаданныйТип = Тип("Булево") Тогда
		Возврат Ложь;

	Иначе
		Возврат Новый (ЗаданныйТип);

	КонецЕсли;

КонецФункции

// Возвращает текст сообщения об ошибке.
//
Функция СформироватьТекстСообщения(Знач ТекстСообщения) Экспорт

	НачалоСлужебногоСообщения    = СтрНайти(ТекстСообщения, "{");
	ОкончаниеСлужебногоСообщения = СтрНайти(ТекстСообщения, "}:");
	
	Если ОкончаниеСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения Тогда
		
		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1))
					   + Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));
						 
	КонецЕсли;
	
	Возврат СокрЛП(ТекстСообщения);

КонецФункции

// Выводит сообщение об ошибке.
//
Процедура СообщитьОбОшибке(Знач ТекстСообщения, Отказ, Заголовок = "", Знач Статус = Неопределено, ВызыватьИсключение = Истина) Экспорт
    	
	ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
	Отказ = Истина;
	
	#Если Сервер Тогда
		
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Медицинская отчетность'"), УровеньЖурналаРегистрации.Ошибка, , , Заголовок + Символы.ПС + ТекстСообщения);
	
	#ИначеЕсли ВнешнееСоединение Тогда
		
		Если ВызыватьИсключение Тогда
			Если ЗначениеЗаполнено(Заголовок) Тогда
				ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
				Заголовок = "";
			КонецЕсли;
			
			ВызватьИсключение (ТекстСообщения);
		КонецЕсли;
		
	#Иначе
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			
			Сообщение = Новый СообщениеПользователю;

			Сообщение.Текст = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='%1'"), Заголовок);

			Сообщение.Сообщить();
						
			Заголовок = "";
			
		КонецЕсли;
		
		Сообщение = Новый СообщениеПользователю;

		Сообщение.Текст = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='%1'"), ТекстСообщения);

		Сообщение.Сообщить();
		
	#КонецЕсли
	
КонецПроцедуры

// Возвращает найденный элемент дерева.
//
Функция НайтиЭлементВДанныхФормыДерево(ЭлементыДанныхФормыДерево, ИмяКолонки, ИскомоеЗначение) Экспорт
	
	Для Ном = 0 По ЭлементыДанныхФормыДерево.Количество() - 1 Цикл
		
		ЭлементДерева = ЭлементыДанныхФормыДерево.Получить(Ном);
		
		Если ЭлементДерева[ИмяКолонки] = ИскомоеЗначение Тогда
			Возврат ЭлементДерева;
		КонецЕсли;
		
		Если ЭлементДерева.ПолучитьЭлементы().Количество() > 0 Тогда
			
			РезультатПоиска = НайтиЭлементВДанныхФормыДерево(ЭлементДерева.ПолучитьЭлементы(), ИмяКолонки, ИскомоеЗначение);
			
			Если НЕ РезультатПоиска = Неопределено Тогда
				Возврат РезультатПоиска;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

// Возвращает количество форм соответствующих выбранному периоду.
//
Функция КоличествоФормСоответствующихВыбранномуПериоду(Форма) Экспорт

	ИтоговоеКоличество = 0;

	Для Каждого ЭлФорма Из Форма.мТаблицаФормОтчета Цикл

		ДатаНачалаДействияФормы = ЭлФорма.ДатаНачалоДействия;
		ДатаКонцаДействияФормы  = КонецДня(?(ЭлФорма.ДатаКонецДействия = МедицинскаяОтчетностьКлиентСервер.ПустоеЗначениеТипа(Тип("Дата")), '20991231', ЭлФорма.ДатаКонецДействия));

		Если Форма.мДатаКонцаПериодаОтчета <= ДатаКонцаДействияФормы
		   И Форма.мДатаКонцаПериодаОтчета >= ДатаНачалаДействияФормы Тогда

			ИтоговоеКоличество = ИтоговоеКоличество + 1;

		КонецЕсли;

	КонецЦикла;

	Возврат ИтоговоеКоличество;

КонецФункции

// Выбирает форму Медицинского отчета по умолчанию.
//
Процедура ВыборФормыМедицинскогоОтчетаПоУмолчанию(Форма) Экспорт
	
	// Этот код необходим для обеспечения гарантированного открытия
	// стартовых форм Реготчетов в режимеОткрытияОкна "БлокироватьОкноВладельца",
	// даже если Отчет открывается через ВсеФункции - Отчеты.
	// Внесение кода в эту процедуру позволит избежать выставления режима открытия
	// персонально для каждой стартовой формы.
	#Если НаСервере Тогда
		 
	     Если СтрНайти(Форма.ИмяФормы,".ОсновнаяФорма") > 0 Тогда
		 
		 	 // устанавливаем РежимОткрытияОкна
			 Форма.РежимОткрытияОкна  = РежимОткрытияОкнаФормы.БлокироватьОкноВладельца;
				 
		 КонецЕсли;
	 
	#КонецЕсли 
	
	ТаблицаФормОтчета = МедицинскаяОтчетностьКлиентСервер.ПолучитьТаблицуОтчетовДействующихВВыбранныйПериод(Форма);
	Для Каждого Стр Из ТаблицаФормОтчета Цикл
		Если Стр.ДатаКонецДействия = МедицинскаяОтчетностьКлиентСервер.ПустоеЗначениеТипа(Тип("Дата")) Тогда
			Стр.ДатаКонецДействия = '20991231';
		КонецЕсли;
	КонецЦикла;
		
	Для Каждого Строка Из ТаблицаФормОтчета Цикл
		Если (Строка.ДатаНачалоДействия > КонецДня(Форма.мДатаКонцаПериодаОтчета))
		 ИЛИ ((Строка.ДатаКонецДействия > '00010101000000') И (Строка.ДатаКонецДействия < НачалоДня(Форма.мДатаКонцаПериодаОтчета))) Тогда
			Продолжить;
		КонецЕсли;

		Форма.мВыбраннаяФорма		= Строка.ФормаОтчета;
		Форма.ОписаниеНормативДок	= Строка.ОписаниеОтчета;
				   
		Форма.ПолеРедакцияФормы		= Строка.РедакцияФормы;
						
		Возврат;
	КонецЦикла;

	// Если не удалось найти форму, соответствующую выбранному периоду,
	// то по умолчанию выдаем текущую (действующую) форму.
	Если Форма.мВыбраннаяФорма = Неопределено Тогда
		Если ТаблицаФормОтчета.Количество() >= 1 Тогда
			
			Форма.мВыбраннаяФорма		= Форма.мТаблицаФормОтчета[0].ФормаОтчета;
			Форма.ОписаниеНормативДок	= Форма.мТаблицаФормОтчета[0].ОписаниеОтчета;
			
			Форма.ПолеРедакцияФормы		= Форма.мТаблицаФормОтчета[0].РедакцияФормы;
									 
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры

// Возвращает имя раздела текущей области.
//
Функция РазделТекущейОбласти(Форма, ТекущаяОбласть, ДлИмениОбласти = 13) Экспорт

	Если ТекущаяОбласть = Неопределено Тогда
		Возврат Неопределено; // отсутствует активная область табличного документа
	КонецЕсли;

	ИмяТекущейОбласти   = ТекущаяОбласть.Имя;
	ИмяАктивногоРаздела = Лев(ИмяТекущейОбласти, ДлИмениОбласти);
	
	Для Каждого ЭлементСтруктуры Из Форма.мСтруктураМногострочныхРазделов Цикл
		ИмяГруппы = ЭлементСтруктуры.Ключ;
		СтруктураГруппы = Форма[ЭлементСтруктуры.Значение];

		Если СтруктураГруппы[0].Свойство(ИмяАктивногоРаздела) Тогда
			Возврат ИмяГруппы;
		КонецЕсли;
	КонецЦикла;

	Возврат Неопределено;

КонецФункции

// Добавляет необходимое количество дополнительных строк.
//
Процедура ДобавитьНеобходимоеКоличествоДопСтрок(Форма, ТекТабличноеПоле, ТекТабличноеПолеИмя, ИсходноеКоличествоСтрокГруппы, ТекущееКоличествоСтрокГруппы, ИмяГруппы, СтруктураГруппы) Экспорт
	
	ИмяОбласти = Форма.СтруктураРеквизитовФормы.мСоответствияМнгЧ[ИмяГруппы];
	
	МногострочнаяЧастьВерх = ТекТабличноеПоле.Области[ИмяОбласти].Верх;
	МногострочнаяЧастьНиз = МногострочнаяЧастьВерх + ИсходноеКоличествоСтрокГруппы - 1;
	
	ОбластьДопСтроки = ТекТабличноеПоле.ПолучитьОбласть("R" + Формат(МногострочнаяЧастьНиз, "ЧГ="));
	
	ТекТабличноеПоле.ВставитьОбласть(ОбластьДопСтроки.Область(), ТекТабличноеПоле.Область(МногострочнаяЧастьВерх + ИсходноеКоличествоСтрокГруппы, , МногострочнаяЧастьВерх + ТекущееКоличествоСтрокГруппы - 1), ТипСмещенияТабличногоДокумента.ПоВертикали);
	
	Для НомСтроки = ИсходноеКоличествоСтрокГруппы По ТекущееКоличествоСтрокГруппы Цикл
		
		НомНовойСтроки = ТекущееКоличествоСтрокГруппы - НомСтроки + ИсходноеКоличествоСтрокГруппы;
		
		Для Каждого Область Из ОбластьДопСтроки.Области Цикл
			
			ОбластьТаблДок = ТекТабличноеПоле.Область(МногострочнаяЧастьВерх + НомНовойСтроки - 1, Область.Лево, МногострочнаяЧастьВерх + НомНовойСтроки - 1, Область.Право);
			
			Если ОбластьТаблДок.ТипОбласти = ТипОбластиЯчеекТабличногоДокумента.Прямоугольник Тогда
				
				Если ОбластьТаблДок.СодержитЗначение Тогда
					ОбластьТаблДок.Очистить();
				КонецЕсли;
				
				ОбластьТаблДок.Имя = Лев(Область.Имя, СтрНайти(Область.Имя, "_")) + Формат(НомНовойСтроки, "ЧГ=");
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	ТекТабличноеПоле.Область(ИмяОбласти).Имя = "";
	
	ТекТабличноеПоле.Область(МногострочнаяЧастьВерх, , МногострочнаяЧастьВерх).Имя = ИмяОбласти;
	
КонецПроцедуры

// Отрисовывает пиктограммы удаления строк отчета.
//
Процедура ОтрисоватьЗначкиУдаленияСтрок(Форма, ДлинаИмениОбластейСДопСтроками = 26) Экспорт 
	
	ТабДок = Форма.ТабличныйДокумент;
	
	МассивОбластейСДопСтроками = Новый Массив;
	
	Для Каждого ОбластьТД Из ТабДок.Области Цикл
		Если СтрЧислоВхождений(ОбластьТД.Имя, "УдалитьСтроку") > 0 Тогда
			Если СтрЧислоВхождений(ОбластьТД.Имя, "_2") > 0 Тогда
				МассивОбластейСДопСтроками.Добавить(Лев(ОбластьТД.Имя, ДлинаИмениОбластейСДопСтроками));
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ОбластьТД Из ТабДок.Области Цикл
		Если СтрЧислоВхождений(ОбластьТД.Имя, "УдалитьСтроку") > 0 Тогда
			Если МассивОбластейСДопСтроками.Найти(Лев(ОбластьТД.Имя, ДлинаИмениОбластейСДопСтроками)) = Неопределено Тогда
				ОбластьТД.Гиперссылка = Ложь;
				ОбластьТД.Текст = "";
			Иначе
				ОбластьТД.Гиперссылка = Истина;
				ОбластьТД.Текст = "х";
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Возвращает найденный уникальный идентификатор элемента дерева.
//
Функция НайтиИДВДереве(Дерево, UID, UID_Пустой) Экспорт 
	Для Каждого Элемент Из Дерево Цикл 
		Если Элемент.UID = UID Тогда
			Возврат Элемент.ПолучитьИдентификатор();
		КонецЕсли;
	
		НайденныйИД = НайтиИДВДереве(Элемент.ПолучитьЭлементы(), UID, UID_Пустой);
		Если НайденныйИД <> Неопределено Тогда
			Возврат НайденныйИД;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция УдалосьПроставитьНомерСтраницы(ТаблДок,Знач НомерЛиста)
	
	ОбластиСНомерамиЛистов = Новый СписокЗначений;
	Для Каждого Обл Из ТаблДок.Значение.Области Цикл
		Если (НЕ ТипЗнч(Обл) = Тип("РисунокТабличногоДокумента") И Обл.ТипОбласти <> ТипОбластиЯчеекТабличногоДокумента.Прямоугольник) ИЛИ Обл.СодержитЗначение <> Истина Тогда
			Продолжить;
		КонецЕсли;
		КрайнийПравыйСимвол = Прав(Обл.Имя, 1);
		Если Лев(ВРЕГ(Обл.Имя), 6) = "НОМСТР" И (КодСимвола(КрайнийПравыйСимвол) >= КодСимвола("0") И КодСимвола(КрайнийПравыйСимвол) <= КодСимвола("9"))Тогда
			ОбластиСНомерамиЛистов.Добавить(Обл, Обл.Имя);
		КонецЕсли;
		ОбластиСНомерамиЛистов.СортироватьПоПредставлению(НаправлениеСортировки.Убыв);
	КонецЦикла;
	
	Цифры = Новый Массив;
	Для Инд = 1 По 9 Цикл
		Цифра = Формат(НомерЛиста % 10, "ЧЦ=1; ЧН=0; ЧГ=");
		НомерЛиста = Цел(НомерЛиста / 10);
		Если ПустаяСтрока(Цифра) Тогда
			Прервать;
		Иначе
			Цифры.Добавить(Цифра);
		КонецЕсли;
	КонецЦикла;
	
	Для Инд = 0 По ОбластиСНомерамиЛистов.Количество() - 1 Цикл
		ОбластиСНомерамиЛистов.Получить(Инд).Значение.Значение = Формат(?(Цифры.Количество() > Инд, Цифры[Инд], 0), "ЧЦ=1; ЧН=0; ЧГ=");
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Процедура УдалитьСлужебныеСимоволыИзПечатнойФормы(СписокПечатаемыхЛистов)
	
	ПустаяЛиния = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.НетЛинии);
	Для Каждого Лист Из СписокПечатаемыхЛистов Цикл 
		ТабДок = ПолучитьИзВременногоХранилища(Лист.Значение[0]);
		Для Каждого Обл Из ТабДок.Области Цикл 
			Если СтрНайти(Обл.Имя, "УдалитьСтроку") = 1 И Не Обл.СодержитЗначение Тогда 
				Обл.Текст = "";
			КонецЕсли;
			Если СтрНайти(Обл.Имя, "ДобавитьСтроку") = 1 И Не Обл.СодержитЗначение Тогда 
				Обл.Текст = "";
				УстановитьГраницуОбласти(Обл, ПустаяЛиния);
				Попытка
					Если Обл.Верх = Обл.Низ И Обл.Лево = Обл.Право Тогда 
						УстановитьГраницуОбласти(ТабДок.Область(Обл.Верх, Обл.Лево+1,Обл.Верх, Обл.Лево+1), ПустаяЛиния);
					КонецЕсли;
				Исключение
				КонецПопытки;
		КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

Процедура УстановитьГраницуОбласти(Обл, Граница)
	
	Обл.ГраницаСлева = Граница;
	Обл.ГраницаСправа = Граница;
	Обл.ГраницаСверху = Граница;
	Обл.ГраницаСнизу = Граница;
	
КонецПроцедуры

Процедура ОпределитьПредставлениеДопСтраниц(Форма, ИмяСтраницы = Неопределено, ТолькоУАктивнойСтраницы = Неопределено)
	Перем ТаблицаСтраницРаздела;
	Перем ТекущееПредставлениеСтраницы;

	ТолькоАктивная = ?(ТолькоУАктивнойСтраницы = Неопределено, Ложь, ТолькоУАктивнойСтраницы);
	
	Для Каждого Страница Из Форма.мСтруктураМногостраничныхРазделов Цикл
		ИмяТекСтраницы        = Страница.Ключ;
		ТаблицаСтраницРаздела = Форма[Страница.Значение];

		Если ИмяСтраницы <> Неопределено Тогда
			Если ИмяТекСтраницы <> ИмяСтраницы Тогда
				Продолжить; // Пропускаем не нужные страницы
			КонецЕсли;
		КонецЕсли;

		// Если есть хоть одна страница - определим ее представление
		Если ТаблицаСтраницРаздела.Количество() > 0 Тогда

			НомерСтраницы = 0;

			Для Каждого СтрокаТаблицы Из ТаблицаСтраницРаздела Цикл

				НомерСтраницы = НомерСтраницы + 1;

				СохрПредставлениеСтраницы = СтрокаТаблицы.Представление;

				// Если колонки нет, тогда автоматическое представление включено по умолчанию.
				Если ТаблицаСтраницРаздела[0].Свойство("АвтоматическоеПредставление") Тогда
					АвтоматическоеПредставление = СтрокаТаблицы.АвтоматическоеПредставление;
				Иначе
					АвтоматическоеПредставление = Истина;
				КонецЕсли;

				Если НЕ АвтоматическоеПредставление Тогда
					Продолжить;
				КонецЕсли;

				// Определяем представление дополнительной страницы
				СтруктураДанныхСтраницы = СтрокаТаблицы.Данные[0].Значение;

				ИмяПредставления = ПолучитьСвойствоРаздела(Форма, ИмяТекСтраницы, "ИмяПредставления");

				Если НЕ ЗначениеЗаполнено(ИмяПредставления) Тогда
					ТекущееПредставлениеСтраницы = Неопределено;
				Иначе
					СтруктураДанныхСтраницы.Свойство(ИмяПредставления, ТекущееПредставлениеСтраницы);
				КонецЕсли;

				Если (НЕ ТолькоАктивная) Или ((ТолькоАктивная) И (СтрокаТаблицы.АктивнаяСтраница))Тогда

					ТекущееПредставлениеСтраницы = ?(НЕ ЗначениеЗаполнено(ТекущееПредставлениеСтраницы), "Лист N " + Строка(НомерСтраницы), ТекущееПредставлениеСтраницы + ". Лист N " + Строка(НомерСтраницы));
					Если Не ПустаяСтрока(ТекущееПредставлениеСтраницы) Тогда
						СтрокаТаблицы.Представление = ТекущееПредставлениеСтраницы;
					Иначе
						СтрокаТаблицы.Представление = "Новая страница";
					КонецЕсли;

				КонецЕсли;

			КонецЦикла;

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры

#КонецОбласти
