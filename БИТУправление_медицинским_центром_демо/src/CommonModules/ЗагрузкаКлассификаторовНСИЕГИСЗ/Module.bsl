// OID - Идентификатор справочника (находится в менеджере справочника)
// Токен - UserKey в запросе. Константа, получаемая на сайте при авторизации через госуслуги
// xmlnssoap - Схема soap запроса
// УИДМинздрава - число, трактующее UID в классификаторе
// УИДРодителя - число, ссылающееся на UID родителя в классификаторе (Parent_UID, P_UID, HIGH и пр.)

Функция АдресСервераWSDL() Экспорт
	
	Возврат "https://nsi.rosminzdrav.ru/wsdl/SOAP-server.v2.php?wsdl";
	
КонецФункции

Функция ТестовыйАдресСервераWSDL() Экспорт
	
	Возврат "https://fnsi.test.egisz.rosminzdrav.ru/wsdl/SOAP-server.v2.php?wsdl";
	
КонецФункции

Функция АдресСервераREST()
	
	Возврат "https://nsi.rosminzdrav.ru:443";
	
КонецФункции

Функция ТестовыйАдресСервераREST()
	
	Возврат "https://fnsi.test.egisz.rosminzdrav.ru:443";
	
КонецФункции

Функция ПолучитьТокенНСИ(ТестовыйКонтур)
	
	Если ТестовыйКонтур Тогда
		Возврат ПолучитьТестовыйТокенПользователя();
	Иначе
		Возврат ПолучитьТокенПользователя();
	КонецЕсли;
	
КонецФункции

// Переопределяется расширениями конфигурации при необходимости индивидуального токена.
Функция ПолучитьТокенПользователя()
	
	Возврат "20e07b44-19cb-4fd2-b67f-46fd296334cc";
	
КонецФункции

// Переопределяется расширениями конфигурации при необходимости индивидуального токена.
Функция ПолучитьТестовыйТокенПользователя()
	
	Возврат "977708f2-bfc4-4c8a-b5e4-6e1d2c214c13";
	
КонецФункции

Функция URIПространстваИменSOAP()
	Возврат "http://schemas.xmlsoap.org/soap/envelope/";
КонецФункции

Функция ПолучитьВсеВерсииКлассификатора(OID, ТестовыйКонтур = Ложь) Экспорт
	
	ВерсииКлассификатора = Неопределено;
	
	ПараметрыЗапроса = Новый Структура("OID, ID", OID, ПолучитьТокенНСИ(ТестовыйКонтур));
	
	ИмяОперации = "getVersionList";
	ТекстОперации = ПолучитьТекстSOAP(ИмяОперации, ПараметрыЗапроса);
	
	Результат = ВыполнитьОбменДанными(ТекстОперации, ИмяОперации, ТестовыйКонтур);
	Если ТипЗнч(Результат) = Тип("ОбъектXDTO") Тогда
		ВерсииКлассификатора = ПрочитатьВерсииКлассификатора(Результат);
		ВерсииКлассификатора.Сортировать("ДатаОбновления, Версия");
	КонецЕсли;
	
	Возврат ВерсииКлассификатора;
	
КонецФункции

Функция ПолучитьПоследнююВерсиюКлассификатора(OID, ТестовыйКонтур = Ложь) Экспорт
	
	АктуальнаяВерсия = Неопределено;
	Версии = ПолучитьВсеВерсииКлассификатора(OID, ТестовыйКонтур);
	Если ТипЗнч(Версии) = Тип("ТаблицаЗначений") И Версии.Количество() > 0 Тогда
		Версии.Сортировать("ДатаОбновления Убыв");
		АктуальнаяВерсия = Версии[0].Версия;	
	КонецЕсли;
	Возврат АктуальнаяВерсия;
	
КонецФункции

Функция ЗапроситьКлассификатор(OID, Версия, МенеджерСправочника, ВидКлассификатора = Неопределено, ТестовыйКонтур = Ложь) Экспорт
	
	ТаблицаДанных = Неопределено;
	Попытка
		КоличествоЧастей = ЗапроситьКоличествоЧастейКлассификатора(OID, Версия, ТестовыйКонтур);
		Если КоличествоЧастей = 0 Тогда
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю("ru='Не удалось загрузить количество частей справочника'");
		ИначеЕсли КоличествоЧастей = 1 Тогда
			ТаблицаДанных = ЗапроситьКлассификаторЦеликом(OID, Версия, МенеджерСправочника, ВидКлассификатора, ТестовыйКонтур);
		Иначе
			ТаблицаДанных = ЗапроситьКлассификаторПоЧастям(OID, Версия, КоличествоЧастей, МенеджерСправочника, ВидКлассификатора, ТестовыйКонтур);
		КонецЕсли;
		Если Не ТестовыйКонтур Тогда // TODO: Сомнение
			УстановитьПривилегированныйРежим(Истина);
			СохранитьНаименованиеКлассификатора(OID, Версия);
			УстановитьПривилегированныйРежим(Ложь);
		КонецЕсли;
	Исключение
		ОбщиеМеханизмы.ОбработатьОшибку(ИнформацияОбОшибке());
	КонецПопытки;
	Возврат ТаблицаДанных;
	
КонецФункции

Функция ДопустимыеОперации(Операция)
	
	ДопустимыеОперации = Новый Структура("getRefbookUpdate, getVersionList, getRefbook, getRefbookParts, getRefbookPartial, getRefbookList");
	
	Если ДопустимыеОперации.Свойство(Операция) Тогда
		Возврат Операция;
	Иначе
		ВызватьИсключение ("Недопустимая операция: "+ Операция);
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

Функция ПолучитьТекстSOAP(ИмяОперации, ПараметрыЗапроса)
	
	Операция = ДопустимыеОперации(ИмяОперации);
	
	ID	= ?(ПараметрыЗапроса.Свойство("ID"), ПараметрыЗапроса.ID, "");
	OID	= ?(ПараметрыЗапроса.Свойство("OID"), ПараметрыЗапроса.OID, "");
	Версия	= ?(ПараметрыЗапроса.Свойство("ВерсияКлассификатора"), ПараметрыЗапроса.ВерсияКлассификатора, "");
	
	НомерЧастиСправочника = ?(ПараметрыЗапроса.Свойство("НомерЧастиСправочника"), ПараметрыЗапроса.НомерЧастиСправочника, "");
	
	Если Операция = "getVersionList" Тогда
		ТекстПараметров = "
			|	<userKey5 xsi:type=""xsd:string"">" + ID + "</userKey5>
			|	<refbookCode4 xsi:type=""xsd:string"">" + OID + "</refbookCode4>"
			
	ИначеЕсли Операция = "getRefbook" Тогда
		ТекстПараметров = "
			|	<userKey xsi:type=""xsd:string"">" + ID + "</userKey>
			|	<refbookCode xsi:type=""xsd:string"">" + OID + "</refbookCode>
			|	<version xsi:type=""xsd:string"">" + Версия + "</version>"
			
	ИначеЕсли Операция = "getRefbookParts" Тогда
		ТекстПараметров = "
			|	<userKey3 xsi:type=""xsd:string"">" + ID + "</userKey3>
			|	<refbookCode2 xsi:type=""xsd:string"">" + OID + "</refbookCode2>
			|	<version2 xsi:type=""xsd:string"">" + Версия + "</version2>"
			
	ИначеЕсли Операция = "getRefbookPartial" Тогда
		ТекстПараметров = "
			|	<userKey2 xsi:type=""xsd:string"">" + ID + "</userKey2>
			|	<refbookCode1 xsi:type=""xsd:string"">" + OID + "</refbookCode1>
			|	<version1 xsi:type=""xsd:string"">" + Версия + "</version1>
			|	<partNumber xsi:type=""xsd:integer"">" + НомерЧастиСправочника + "</partNumber>"
			
	ИначеЕсли Операция = "getRefbookList" Тогда
		ТекстПараметров = "
			|	<userKey1 xsi:type=""xsd:string"">" + ID + "</userKey1>";
		
	ИначеЕсли Операция = "getRefbookUpdate" Тогда
		ТекстПараметров = "
			|	<userKey4 xsi:type=""xsd:string"">" + ID + "</userKey4>
			|	<refbookCode3 xsi:type=""xsd:string"">" + OID + "</refbookCode3>
			|	<userVersion xsi:type=""xsd:string"">" + Версия + "</userVersion>
			|	<newVersion xsi:type=""xsd:string""></newVersion>"
	
	КонецЕсли;
	
	ТекстОперации = 
		"<soap:Envelope xmlns:soap=""http://schemas.xmlsoap.org/soap/envelope/"">
		|	<soap:Header/>
		|	<soap:Body>
		|<m:" + Операция + " xmlns:m=""urn:service""
		|		xmlns:soap=""http://schemas.xmlsoap.org/soap/envelope/""
		|		xmlns:soapenc=""http://schemas.xmlsoap.org/soap/encoding/""
		|		xmlns:xsd=""http://www.w3.org/2001/XMLSchema""
		|		xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
		|		soap:encodingStyle=""http://schemas.xmlsoap.org/soap/encoding/"">"
		+ ТекстПараметров + "
		|</m:" + Операция + ">
		|	</soap:Body>
		|</soap:Envelope>";
	
	Возврат ТекстОперации;
	
КонецФункции

Функция ВыполнитьОбменДанными(Запрос, ИмяОперации, ТестовыйКонтур = Ложь)
	
	Если ТестовыйКонтур Тогда
		АдресСервера = ТестовыйАдресСервераWSDL();
	Иначе
		АдресСервера = АдресСервераWSDL();
	КонецЕсли;
	
	РесурсНаСервере = "";
	ПозицияЗавершенияСхемы = СтрНайти(АдресСервера, "://");
	Если ПозицияЗавершенияСхемы > 0 Тогда
		СтрокаURI = Сред(АдресСервера, ПозицияЗавершенияСхемы + 3);
		ПозицияЗавершенияСоединения = СтрНайти(СтрокаURI, "/");
		ДлинаСоединения = ?(ПозицияЗавершенияСоединения > 0, ПозицияЗавершенияСоединения - 1, СтрДлина(СтрокаURI));
		РесурсНаСервере = Сред(АдресСервера, ПозицияЗавершенияСхемы + 3 + ДлинаСоединения);
		АдресСервера = Лев(АдресСервера, ПозицияЗавершенияСхемы + 2 + ДлинаСоединения);
		
		ПозицияПараметров = СтрНайти(РесурсНаСервере, "?");
		ДлинаРесурсаНаСервере = ?(ПозицияПараметров > 0, ПозицияПараметров - 1, СтрДлина(РесурсНаСервере));
		РесурсНаСервере = Лев(РесурсНаСервере, ДлинаРесурсаНаСервере);
	КонецЕсли;
	
	ОписаниеОшибкиУстановкиСоединения = "";
	СоединениеHTTP = ПолучитьСоединениеССервисом(
		АдресСервера, ОписаниеОшибкиУстановкиСоединения
	);
	Если СоединениеHTTP = Неопределено Тогда
		ТекстОшибки = НСтр("ru = 'Не удалось установить соединение с сервером: %1'");
		ТекстОшибки = СтрШаблон(ТекстОшибки, ОписаниеОшибкиУстановкиСоединения);
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки);
		Возврат Неопределено;
	КонецЕсли;
	
	ТелоЗапросаSOAP = Запрос;
	
	Попытка
		
		HTTPЗапрос = Новый HTTPЗапрос(РесурсНаСервере);
		HTTPЗапрос.УстановитьТелоИзСтроки(
			ТелоЗапросаSOAP,
			,
			ИспользованиеByteOrderMark.НеИспользовать
		);
		
		ЗаголовкиHTTP = HTTPЗапрос.Заголовки;
		ЗаголовкиHTTP.Вставить("Content-Type", "text/xml; charset=utf-8");
		ЗаголовкиHTTP.Вставить("Proxy-Connection", "Keep-Alive");
		
		HTTPОтвет = СоединениеHTTP.ОтправитьДляОбработки(HTTPЗапрос);
		
	Исключение
		
		ОбщиеМеханизмы.ОбработатьОшибку(ИнформацияОбОшибке());
		
		ТекстОшибки = НСтр("ru = 'Не удалось получить данные от сервера: %1'");
		ТекстОшибки = СтрШаблон(ТекстОшибки, АдресСервера);
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки);
		
		Возврат Неопределено;
		
	КонецПопытки;
	
	СтрокаОтвета = HTTPОтвет.ПолучитьТелоКакСтроку();
	
	Если Не ЗначениеЗаполнено(СтрокаОтвета) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = ОбработатьОтветСервиса(ИмяОперации, СтрокаОтвета);
	
	Возврат Результат;
	
КонецФункции

Функция ОбработатьОтветСервиса(ИмяОперации, СтрокаОтветаXML)
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаОтветаXML);
	
	ПостроительDOM = Новый ПостроительDOM;
	ДокументDOM = ПостроительDOM.Прочитать(ЧтениеXML);
	УзлыFault = ДокументDOM.ПолучитьЭлементыПоИмени(URIПространстваИменSOAP(), "Fault");
	Если УзлыFault.Количество() <> 0 Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(УзлыFault[0].ТекстовоеСодержимое);
		Возврат Неопределено;
	КонецЕсли;
	ЧтениеXML.Закрыть();
	
	ЭлементыBody = ДокументDOM.ПолучитьЭлементыПоИмени(URIПространстваИменSOAP(), "Body");
	Если ЭлементыBody.Количество() <> 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПервыйДочернийУBody = ЭлементыBody[0].ПервыйДочерний;
	Если ПервыйДочернийУBody = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПространствоИмен = ПервыйДочернийУBody.URIПространстваИмен;
	ЛокальноеИмя = ПервыйДочернийУBody.ЛокальноеИмя;
	Если ПространствоИмен <> "urn:service" Тогда
		ВызватьИсключение "Сервис ФР НСИ ЕГИСЗ вернул ответ, не соответствующий ожидаемому формату";
	КонецЕсли;

	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку("UTF-8");
	
	ЗаписьDOM = Новый ЗаписьDOM;
	ЗаписьDOM.Записать(ПервыйДочернийУBody, ЗаписьXML);
	
	ПервыйДочернийУBodyСтрокой = ЗаписьXML.Закрыть();
	
	ЧтениеXML = Новый ЧтениеXML; 
	ЧтениеXML.УстановитьСтроку(ПервыйДочернийУBodyСтрокой);
	ОбъектXDTO = ФабрикаXDTO.ПрочитатьXML(ЧтениеXML);
	
	Если ОбъектXDTO = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если (ИмяОперации + "Response") <> ЛокальноеИмя Тогда
		ВызватьИсключение("Некорректный ответ сервиса ФР НСИ ЕГИСЗ");
	КонецЕсли;
	
	Результат = Неопределено;
	Попытка
		Выполнить("Результат = ОбъектXDTO."+ ИмяОперации + "Return");
	Исключение
		ВызватьИсключение("Не удалось обработать ответ сервиса ФР НСИ ЕГИСЗ");
	КонецПопытки;
	
	Если ТипЗнч(Результат) <> Тип("ОбъектXDTO")Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если Результат.Свойства().Получить("item") <> Неопределено
		И ТипЗнч(Результат.item) = Тип("ОбъектXDTO")
	Тогда
		Если Результат.item.Свойства().Получить("key") <> Неопределено
			И Результат.item.key = "errors"
		Тогда
			ТекстОшибки = "";
			Ошибки = Результат.item.children.item;
			Если Тип("СписокXDTO") = ТипЗнч(Ошибки) Тогда
				Для Каждого Элемент Из Ошибки Цикл
					ТекстОшибки = ТекстОшибки + 
						?(ЗначениеЗаполнено(ТекстОшибки), Символы.ПС, "") + 
						"Код ошибки: " + Элемент.key + ". " + Элемент.value;
				КонецЦикла;
			Иначе
				ТекстОшибки = ТекстОшибки + 
				"Код ошибки: " + Ошибки.key + ". " + Ошибки.value;
			КонецЕсли; 
			Сообщение = Новый СообщениеПользователю;
			Сообщение.Текст = ТекстОшибки;
			Сообщение.Сообщить();
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

Функция ПолучитьСоединениеССервисом(АдресСервера, ОписаниеОшибки = "")
	
	СтруктураURI = ОбщегоНазначенияКлиентСервер.СтруктураURI(АдресСервера);
	
	Схема = ?(ЗначениеЗаполнено(СтруктураURI.Схема), СтруктураURI.Схема, "http");
	Прокси = ПолучениеФайловИзИнтернетаКлиентСервер.ПолучитьПрокси(Схема);
	
	Попытка
		Соединение = Новый HTTPСоединение(
			СтруктураURI.Хост,
			СтруктураURI.Порт,
			СтруктураURI.Логин,
			СтруктураURI.Пароль,
			Прокси,
			60,
			?(НРег(Схема) = "http", Неопределено, Новый ЗащищенноеСоединениеOpenSSL));
	Исключение
		ОбщиеМеханизмы.ОбработатьОшибку(ИнформацияОбОшибке());
		Возврат Неопределено;
	КонецПопытки;
	
	Возврат Соединение;
	
КонецФункции

Функция ПрочитатьВерсииКлассификатора(ОбъектXDTO)
	
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("Версия", Новый ОписаниеТипов("Строка"));
	Таблица.Колонки.Добавить("ДатаОбновления", Новый ОписаниеТипов("Дата", , , Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя)));
	
	Если Не ТипЗнч(ОбъектXDTO) = Тип("ОбъектXDTO") Тогда
		Возврат Таблица;
	КонецЕсли;
	
	СписокЗаписей = Новый Массив;
	Если ТипЗнч(ОбъектXDTO.item) = Тип("ОбъектXDTO") Тогда
		СписокЗаписей.Добавить(ОбъектXDTO.item);
	ИначеЕсли ТипЗнч(ОбъектXDTO.item) = Тип("СписокXDTO") Тогда
		СписокЗаписей = ОбъектXDTO.item;
	КонецЕсли; 

	Для Каждого ЭлементВерхнегоУровня Из СписокЗаписей Цикл
		СписокПолей = ЭлементВерхнегоУровня.children.item;
		Если Не ТипЗнч(СписокПолей) = Тип("СписокXDTO") Тогда
			Возврат Таблица;
		КонецЕсли;
		НоваяСтрока = Таблица.Добавить();
		Для Каждого Элемент Из СписокПолей Цикл
			Если ВРег(Элемент.key) = "S_VERSION" Тогда
				НоваяСтрока.Версия = Элемент.value;
			ИначеЕсли ВРег(Элемент.key) = "V_DATE" Тогда
				НоваяСтрока.ДатаОбновления = ОбщегоНазначенияКлиентСервер.ПолучитьДатуИзСтроки(Элемент.value);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	Возврат Таблица;
	
КонецФункции

Функция ПрочитатьКоличествоЧастейКлассификатораИзXDTO(ОбъектXDTO)
	
	Количество = 0;
	
	Если Не ТипЗнч(ОбъектXDTO) = Тип("ОбъектXDTO") Тогда
		Возврат Количество;
	КонецЕсли;
	
	СписокЗаписей = Новый Массив;
	Если ТипЗнч(ОбъектXDTO.item) = Тип("ОбъектXDTO") Тогда
		СписокЗаписей.Добавить(ОбъектXDTO.item);
	Иначе
		Возврат Количество
	КонецЕсли;
	
	Если Не ТипЗнч(ОбъектXDTO.item) = Тип("ОбъектXDTO") Тогда
		Возврат Количество;
	КонецЕсли;
	
	Если "partsAmount" = ОбъектXDTO.item.key Тогда
		КоличествоСтрокой = ОбъектXDTO.item.value
	КонецЕсли;
	
	Попытка
		Количество = Число(КоличествоСтрокой);
	Исключение
		ОбщиеМеханизмы.ОбработатьОшибку(ИнформацияОбОшибке());
	КонецПопытки;
	
	Возврат Количество;
	
КонецФункции

// Количество частей классификатора (запросов к сервису за порцией данных), которое будет в случае загрузки из ФР НСИ.
//
// Параметры:
//  OID		 - Строка - идентификатор классификатора в ФР НСИ.
//  Версия	 - Строка - номер версии согласно ФР НСИ.
// 
// Возвращаемое значение:
//  Число - количество блоков (порций) классификатора при загрузке.
//
Функция ЗапроситьКоличествоЧастейКлассификатора(OID, Версия, ТестовыйКонтур) Экспорт
	КоличествоЧастей = 0;
	
	ПараметрыЗапроса = Новый Структура;
	ПараметрыЗапроса.Вставить("OID", OID);
	ПараметрыЗапроса.Вставить("ID", ПолучитьТокенНСИ(ТестовыйКонтур));
	ПараметрыЗапроса.Вставить("ВерсияКлассификатора", Версия);
	
	ИмяОперации = "getRefbookParts";
	ТекстОперации = ПолучитьТекстSOAP(ИмяОперации, ПараметрыЗапроса);
	
	Результат = ВыполнитьОбменДанными(ТекстОперации, ИмяОперации, ТестовыйКонтур);
	Если ТипЗнч(Результат) = Тип("ОбъектXDTO") Тогда
		КоличествоЧастей = ПрочитатьКоличествоЧастейКлассификатораИзXDTO(Результат);
	КонецЕсли;
	
	Возврат КоличествоЧастей;
КонецФункции

Функция ЗапроситьКлассификаторЦеликом(OID, Версия, МенеджерСправочника, ВидКлассификатора, ТестовыйКонтур)
	ТаблицаДанных = Неопределено;
	
	ПараметрыЗапроса = Новый Структура;
	ПараметрыЗапроса.Вставить("OID", OID);
	ПараметрыЗапроса.Вставить("ID", ПолучитьТокенНСИ(ТестовыйКонтур));
	ПараметрыЗапроса.Вставить("ВерсияКлассификатора", Версия);
	
	ИмяОперации = "getRefbook";
	ТекстОперации = ПолучитьТекстSOAP(ИмяОперации, ПараметрыЗапроса);
	
	Результат = ВыполнитьОбменДанными(ТекстОперации, ИмяОперации, ТестовыйКонтур);
	Если ТипЗнч(Результат) = Тип("ОбъектXDTO") Тогда
		ТаблицаДанных = ПрочитатьДанныеКлассификатораИзXDTO(МенеджерСправочника, Результат, ВидКлассификатора);
	КонецЕсли;
	
	Возврат ТаблицаДанных
КонецФункции

Функция ЗапроситьКлассификаторПоЧастям(OID, Версия, КоличествоЧастей, МенеджерСправочника, ВидКлассификатора, ТестовыйКонтур)
	ТаблицаДанных = Неопределено;
	
	Для НомерЧасти = 1 По КоличествоЧастей Цикл
		ТаблицаДанныхЧасти = ЗапроситьЧастьКлассификатора(OID, Версия, НомерЧасти, МенеджерСправочника, ВидКлассификатора, ТестовыйКонтур);
		Если ТипЗнч(ТаблицаДанныхЧасти) = Тип("ТаблицаЗначений") Тогда
			Если ТаблицаДанных = Неопределено Тогда
				ТаблицаДанных = ТаблицаДанныхЧасти;
			Иначе
				ОбщегоНазначенияКлиентСервер.ДополнитьТаблицу(ТаблицаДанныхЧасти, ТаблицаДанных);
			КонецЕсли;
		Иначе
			ТаблицаДанных = Неопределено;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ТаблицаДанных;
КонецФункции

Функция ЗапроситьЧастьКлассификатора(OID, Версия, НомерЧасти, МенеджерСправочника, ВидКлассификатора, ТестовыйКонтур)
	ТаблицаДанных = Неопределено;
	
	ПараметрыЗапроса = Новый Структура;
	ПараметрыЗапроса.Вставить("OID", OID);
	ПараметрыЗапроса.Вставить("ID", ПолучитьТокенНСИ(ТестовыйКонтур));
	ПараметрыЗапроса.Вставить("ВерсияКлассификатора", Версия);
	ПараметрыЗапроса.Вставить("НомерЧастиСправочника", НомерЧасти);
	
	ИмяОперации = "getRefbookPartial";
	ТекстОперации = ПолучитьТекстSOAP(ИмяОперации, ПараметрыЗапроса);
	
	Результат = ВыполнитьОбменДанными(ТекстОперации, ИмяОперации, ТестовыйКонтур);
	Если ТипЗнч(Результат) = Тип("ОбъектXDTO") Тогда
		ТаблицаДанных = ПрочитатьДанныеКлассификатораИзXDTO(МенеджерСправочника, Результат, ВидКлассификатора);
	КонецЕсли;
	
	Возврат ТаблицаДанных;
КонецФункции

Функция ПрочитатьДанныеКлассификатораИзXDTO(МенеджерСправочника, Результат, ВидКлассификатора)
	
	МетаданныеСправочника = МенеджерСправочника.ПустаяСсылка().Метаданные();
	СтандартныеРеквизитыСправочника = МетаданныеСправочника.СтандартныеРеквизиты;
	
	ТЗРеквизитов = Новый ТаблицаЗначений;
	Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(СтандартныеРеквизитыСправочника, "Код") Тогда
		ТЗРеквизитов.Колонки.Добавить("Код",СтандартныеРеквизитыСправочника["Код"].Тип);
	КонецЕсли;
	Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(СтандартныеРеквизитыСправочника, "Наименование") Тогда
		ТЗРеквизитов.Колонки.Добавить("Наименование",Новый ОписаниеТипов("Строка"));
	КонецЕсли;
	
	Попытка
		ЕстьИерархия = СтандартныеРеквизитыСправочника["Родитель"];
	Исключение
		ЕстьИерархия = Ложь;
	КонецПопытки; 
	
	Для Каждого Реквизит из МетаданныеСправочника.Реквизиты Цикл
		ТЗРеквизитов.Колонки.Добавить(Реквизит.Имя,Реквизит.Тип);
	КонецЦикла;
	// Колонка для запроса обновления
	ТЗРеквизитов.Колонки.Добавить("OPER",Новый ОписаниеТипов("Строка"));
	
	// Из общих реквизитов найдём те, которые есть в справочнике
	Для Каждого МетаданныеОбщийРеквизит Из Метаданные.ОбщиеРеквизиты Цикл
		Если МетаданныеОбщийРеквизит.Состав.Содержит(МетаданныеСправочника) Тогда
			ТЗРеквизитов.Колонки.Добавить(МетаданныеОбщийРеквизит.Имя,МетаданныеОбщийРеквизит.Тип);
		КонецЕсли;
	КонецЦикла;
	
	Попытка
		МенеджерСправочника.ДополнитьКолонкиТаблицыДанных(ТЗРеквизитов);
	Исключение КонецПопытки;
	
	Если ЗначениеЗаполнено(ВидКлассификатора) Тогда
		СоответствияПолей = МенеджерСправочника.ПолучитьСопоставленийРеквизитовИXMLСправочникаЕГИСЗ(ВидКлассификатора);
	Иначе
		СоответствияПолей = МенеджерСправочника.ПолучитьСопоставленийРеквизитовИXMLСправочникаЕГИСЗ();
	КонецЕсли;
	
	Попытка
		Если ЗначениеЗаполнено(ВидКлассификатора) Тогда
			ДопАтрибуты = МенеджерСправочника.ПолучитьДополнительныеАтрибуты(ВидКлассификатора);
		Иначе
			ДопАтрибуты = МенеджерСправочника.ПолучитьДополнительныеАтрибуты();
		КонецЕсли;
		Для Каждого Атрибут Из ДопАтрибуты Цикл
			Значения = СоответствияПолей.Получить(Атрибут.Ключ);
			Если Значения = Неопределено Тогда
				СоответствияПолей.Вставить(Атрибут.Ключ,Атрибут.Значение);
			Иначе
				мЗначения = СтрРазделить(Значения, ",", Ложь);
				мЗначения.Добавить(Атрибут.Значение);
				СоответствияПолей.Вставить(Атрибут.Ключ,СтрСоединить(мЗначения, ","));
			КонецЕсли;
		КонецЦикла;
	Исключение
	КонецПопытки;
		
	Если ТипЗнч(ДопАтрибуты) = Тип("Структура") Тогда
		ВызватьИсключение "Менеджер справочника вернул объект ""ДополнительныеАтрибуты"", имеющий тип ""Структура"" вместо ""Соответствие"". Переопределите процедуру ""ПолучитьДополнительныеАтрибуты"" и повторите загрузку";
	КонецЕсли;
	
	Если ДопАтрибуты <> Неопределено Тогда
		ТЗРеквизитов.Колонки.Добавить("Атрибуты",Новый ОписаниеТипов("ТаблицаЗначений"));
	КонецЕсли;
	
	Если Не ТипЗнч(Результат) = Тип("ОбъектXDTO") Тогда
		Возврат ТЗРеквизитов;
	КонецЕсли;
	
	Если Результат.Свойства().Получить("item") = Неопределено Тогда
		Возврат ТЗРеквизитов;
	КонецЕсли;
	
	СписокЗаписей = Результат.item;
	Если ТипЗнч(СписокЗаписей) <> Тип("СписокXDTO") Тогда
		Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(СписокЗаписей, "children") Тогда
			НовыйСписок = Новый Массив();
			НовыйСписок.Добавить(СписокЗаписей);
			СписокЗаписей = НовыйСписок;
		Иначе
			Возврат ТЗРеквизитов;
		КонецЕсли;
	КонецЕсли;
	
	Для Каждого ЭлементВерхнегоУровня Из СписокЗаписей Цикл
		
		СписокПолей = ЭлементВерхнегоУровня.children.item;
		
		Если ТипЗнч(СписокПолей) <> Тип("СписокXDTO") Тогда
			Продолжить;
		КонецЕсли;
		
		НоваяСтрока = ТЗРеквизитов.Добавить();
		
		Если ДопАтрибуты <> Неопределено Тогда
			НоваяСтрока["Атрибуты"].Колонки.Добавить("Ключ",Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(50)));
			НоваяСтрока["Атрибуты"].Колонки.Добавить("Значение",Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(0)));
		КонецЕсли;
		
		Для Каждого Элемент Из СписокПолей Цикл
			Если ТипЗнч(Элемент.value) <> Тип("ОбъектXDTO") Тогда 	// Исключаем пустые значения
				// Заполнение колонки для обновления
				Если Элемент.key = "OPER" Тогда
					НоваяСтрока.OPER = Элемент.value;
					Продолжить;
				КонецЕсли;
				
				//Колонка = СоответствияПолей.Получить(ВРег(Элемент.key));
				//
				//Если Колонка = Неопределено Тогда
				//	Колонка = СоответствияПолей.Получить((Элемент.key));
				//КонецЕсли;
				
				Колонки = СоответствияПолей.Получить(ВРег(Элемент.key));
				
				Если Колонки = Неопределено Тогда
					Колонки = СоответствияПолей.Получить((Элемент.key));
				КонецЕсли;
				
				Если Колонки = Неопределено Тогда
					
					// Если это загружаемый атрибут, то фиксируем его в таблице артибутов.
					Если ДопАтрибуты <> Неопределено
						И ДопАтрибуты.Получить(Элемент.key) <> Неопределено
					Тогда
						// Помещение значения в атрибут
						НовыйАтрибут = НоваяСтрока["Атрибуты"].Добавить();
						НовыйАтрибут.Ключ		= Элемент.key;
						НовыйАтрибут.Значение	= СокрЛП(Элемент.value);
					КонецЕсли;
				Иначе
					ИменаКолонокСоответствия = СтрРазделить(СтрЗаменить(Колонки, " ", ""), ",", Ложь);
					Для Каждого Колонка Из ИменаКолонокСоответствия Цикл
						//Если ДопАтрибуты <> Неопределено И ДопАтрибуты.Свойство(Колонка) Тогда
						Если ДопАтрибуты <> Неопределено И ДопАтрибуты.Получить(Колонка) <> Неопределено Тогда
							
							НовыйАтрибут = НоваяСтрока["Атрибуты"].Добавить();
							НовыйАтрибут.Ключ = Колонка;
							НовыйАтрибут.Значение = СокрЛП(Элемент.value);
							
						Иначе
							Попытка // На случай, если сопоставления колонки нет в базе (соответствие = (поле из соап / "")
								ТипЗначения = ТипЗнч(НоваяСтрока[Колонка]);
								ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипЗначения);
								Если ОбъектМетаданных <> Неопределено Тогда
									НоваяСтрока[Колонка] = ИнтеграцияЕГИСЗСервер.ЭлементКлассификатораПоID(Число(Элемент.value), ОбъектМетаданных.Имя);
								Иначе
									НоваяСтрока[Колонка] = СокрЛП(Элемент.value);
								КонецЕсли;
							Исключение
							КонецПопытки;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
	КонецЦикла;
		
	Возврат ТЗРеквизитов;
	
КонецФункции

// Ищет элемент справочника по УидЕГИСЗ и возвращает ссылку на него.
//
// Параметры:
//   ИмяСправочника - Строка - имя справочника искомого элемента.
//   УидЕГИСЗ - Строка - универсальный идентификатор элементов в справочниках ЕГИСЗ. 
//
// Возвращаемое значение:
//   СправочникСсылка - Ссылка на элемент справочника.
Функция ПолучитьЭлементСправочникаПоУидЕГИСЗ(Знач ИмяСправочника, Знач УидЕГИСЗ) Экспорт
	Справочник = Справочники[ИмяСправочника];
	Элемент = Справочник.НайтиПоРеквизиту("УИДЕГИСЗ",УидЕГИСЗ);
	Возврат Элемент;
КонецФункции

Функция ПолучитьПаспортСправочника(OID, Версия="") Экспорт
	
	Если ЗначениеЗаполнено(Версия) Тогда 
		РесурсНаСервере = СтрШаблон("port/rest/passport?userKey=%1&identifier=%2&version=%3",
								ПолучитьТокенПользователя(),
								OID,
								Версия);
	Иначе
		РесурсНаСервере = СтрШаблон("port/rest/passport?userKey=%1&identifier=%2",
								ПолучитьТокенПользователя(),
								OID);
	КонецЕсли;
	
	СтрокаОтвета = ОтправитьRESTЗапрос(РесурсНаСервере);
	
	Если Не ЗначениеЗаполнено(СтрокаОтвета) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = ПрочитатьJSONОтвет(СтрокаОтвета);
	
	Возврат Результат;
	
КонецФункции

Функция ПолучитьКлассификаторПоОтбору(OID, МенеджерСправочника, ПараметрыОтбора = Неопределено,
	Версия = Неопределено, ВидКлассификатора = Неопределено, ТестовыйКонтур = Ложь) Экспорт
	
	Если Версия = Неопределено Тогда
		Версия = ПолучитьПоследнююВерсиюКлассификатора(OID, ТестовыйКонтур);
	КонецЕсли;
	
	РесурсНаСервере = СтрШаблон("port/rest/data?userKey=%1&identifier=%2&version=%3",
								ПолучитьТокенНСИ(ТестовыйКонтур),
								OID,
								Версия);
	
	Если ПараметрыОтбора <> Неопределено Тогда
		Для Каждого ПараметрОтбора Из ПараметрыОтбора Цикл
			Если ТипЗнч(ПараметрОтбора.Значение) = Тип("Массив") Тогда
				Для Каждого ЗначениеОтбора Из ПараметрОтбора.Значение Цикл
					СтрокаПараметра = СтрШаблон("&%1=%2", ПараметрОтбора.Ключ, ЗначениеОтбора);
					РесурсНаСервере = РесурсНаСервере + СтрокаПараметра;
				КонецЦикла;
			Иначе
				СтрокаПараметра = СтрШаблон("&%1=%2", ПараметрОтбора.Ключ, ПараметрОтбора.Значение);
				РесурсНаСервере = РесурсНаСервере + СтрокаПараметра;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	СтрокаОтвета = ОтправитьRESTЗапрос(РесурсНаСервере, ТестовыйКонтур);
	
	Если Не ЗначениеЗаполнено(СтрокаОтвета) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	XMLРезультат = JSON2XML(СтрокаОтвета);
	XDTOРезультат = ОбработатьОтветСервиса("data", XMLРезультат);
	Результат = ПрочитатьДанныеКлассификатораИзXDTO(МенеджерСправочника, XDTOРезультат, ВидКлассификатора);
	
	Возврат Результат;
	
КонецФункции

Функция ПолучитьКлассификаторПоОтборуXDTO(OID, ПараметрыОтбора = Неопределено, Версия = Неопределено) Экспорт
	
	Если Версия = Неопределено Тогда
		Версия = ПолучитьПоследнююВерсиюКлассификатора(OID);
	КонецЕсли;
	
	РесурсНаСервере = СтрШаблон("port/rest/data?userKey=%1&identifier=%2&version=%3",
								ПолучитьТокенПользователя(),
								OID,
								Версия);
	
	Если ПараметрыОтбора <> Неопределено Тогда
		Для Каждого ПараметрОтбора Из ПараметрыОтбора Цикл
			Если ТипЗнч(ПараметрОтбора.Значение) = Тип("Массив") Тогда
				Для Каждого ЗначениеОтбора Из ПараметрОтбора.Значение Цикл
					СтрокаПараметра = СтрШаблон("&%1=%2",ПараметрОтбора.Ключ,ЗначениеОтбора);
					РесурсНаСервере = РесурсНаСервере + СтрокаПараметра;
				КонецЦикла;
			Иначе
				СтрокаПараметра = СтрШаблон("&%1=%2",ПараметрОтбора.Ключ,ПараметрОтбора.Значение);
				РесурсНаСервере = РесурсНаСервере + СтрокаПараметра;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	СтрокаОтвета = ОтправитьRESTЗапрос(РесурсНаСервере);
	
	Если Не ЗначениеЗаполнено(СтрокаОтвета) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	XMLРезультат = JSON2XML(СтрокаОтвета);
	XDTOРезультат = ОбработатьОтветСервиса("data",XMLРезультат);
	Возврат XDTOРезультат;
	
КонецФункции

Функция ОтправитьRESTЗапрос(РесурсНаСервере, ТестовыйКонтур = Ложь)
	
	Если ТестовыйКонтур Тогда
		АдресСервера = ТестовыйАдресСервераREST();
	Иначе
		АдресСервера = АдресСервераREST();
	КонецЕсли;
	
	ОписаниеОшибкиУстановкиСоединения = "";
	СоединениеHTTP = ПолучитьСоединениеССервисом(
		АдресСервера, ОписаниеОшибкиУстановкиСоединения
	);
	Если СоединениеHTTP = Неопределено Тогда
		ТекстОшибки = НСтр("ru = 'Не удалось установить соединение с сервером:
						   |%1'");
		ТекстОшибки = СтрШаблон(ТекстОшибки, ОписаниеОшибкиУстановкиСоединения);
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки);
		Возврат Неопределено;
	КонецЕсли;
	
	Попытка
		
		HTTPЗапрос = Новый HTTPЗапрос(РесурсНаСервере);
		HTTPОтвет = СоединениеHTTP.Получить(HTTPЗапрос);
		
	Исключение
		
		ОбщиеМеханизмы.ОбработатьОшибку(ИнформацияОбОшибке());
		Возврат Неопределено;
		
	КонецПопытки;
	
	Возврат HTTPОтвет.ПолучитьТелоКакСтроку();
	
КонецФункции

Функция ПрочитатьJSONОтвет(ТекстJSON)
	ЧтениеJSON = Новый ЧтениеJSON();
	ЧтениеJSON.УстановитьСтроку(ТекстJSON);
	Результат = ОбойтиJSON(ЧтениеJSON);
	Возврат Результат;
КонецФункции

Функция ОбойтиJSON(ЧтениеJSON, МассивРодитель = Неопределено)
	
	Пока ЧтениеJSON.Прочитать() Цикл
		Если ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.НачалоОбъекта Тогда
			ТекущийОбъект = Новый Структура();
		ИначеЕсли ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.КонецОбъекта Тогда 
			Если МассивРодитель = Неопределено Тогда
				Прервать;
			Иначе
				МассивРодитель.Добавить(ТекущийОбъект);
			КонецЕсли;
		ИначеЕсли ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.ИмяСвойства Тогда
			ТекущееСвойство = ЧтениеJSON.ТекущееЗначение;
		ИначеЕсли ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.НачалоМассива Тогда
			МассивОбъектов = Новый Массив;
			ОбойтиJSON(ЧтениеJSON, МассивОбъектов);
			Если МассивРодитель = Неопределено Тогда
				ТекущийОбъект.Вставить(ТекущееСвойство, МассивОбъектов);
			Иначе
				МассивРодитель.Добавить(МассивОбъектов);
			КонецЕсли;
		ИначеЕсли ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.КонецМассива Тогда
			Прервать;
		ИначеЕсли ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.Булево
			Или ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.Строка
			Или ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.Число
			Или ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.Null
		Тогда
			ТекущийОбъект.Вставить(ТекущееСвойство, ЧтениеJSON.ТекущееЗначение);
		КонецЕсли;
	КонецЦикла;
	
	Возврат ТекущийОбъект;
	
КонецФункции

Функция JSON2XML(ТекстJSON)
	СтруктураОтвета = ПрочитатьJSONОтвет(ТекстJSON);
	
	Если Не СтруктураОтвета.Свойство("list") Или СтруктураОтвета.list.Количество() = 0 Тогда
		МассивСтрок = Новый Массив();
	Иначе
		МассивСтрок = СтруктураОтвета.list;
	КонецЕсли;
	
	ЗаписьXML = Новый ЗаписьXML();
	ЗаписьXML.УстановитьСтроку();
	
	ЗаписьXML.ЗаписатьНачалоЭлемента("soap:Envelope");
	ЗаписьXML.ЗаписатьАтрибут("xmlns:soap","http://schemas.xmlsoap.org/soap/envelope/");
	
	ЗаписьXML.ЗаписатьНачалоЭлемента("soap:Body");
	ЗаписьXML.ЗаписатьНачалоЭлемента("ns1:dataResponse");
	ЗаписьXML.ЗаписатьАтрибут("xmlns:ns1","urn:service");
	ЗаписьXML.ЗаписатьНачалоЭлемента("dataReturn");
	Сч = 0;
	Для Каждого Строка Из МассивСтрок Цикл
		ЗаписьXML.ЗаписатьНачалоЭлемента("item");
		ЗаписьXML.ЗаписатьНачалоЭлемента("children");
		ПервоеСвойство = Истина;
		Для Каждого ПараметрСтроки Из Строка Цикл
			ЗаписьXML.ЗаписатьНачалоЭлемента("item");
			ЗаписьXML.ЗаписатьНачалоЭлемента("children");
			Если ПервоеСвойство Тогда
				ЗаписьXML.ЗаписатьАтрибут("id","ref1");
				ПервоеСвойство = Ложь;
			Иначе
				ЗаписьXML.ЗаписатьАтрибут("href","#ref1");
			КонецЕсли;
			ЗаписьXML.ЗаписатьКонецЭлемента();
			ЗаписьXML.ЗаписатьНачалоЭлемента("key");
			ЗаписьXML.ЗаписатьТекст(ПараметрСтроки.column);
			ЗаписьXML.ЗаписатьКонецЭлемента();
			ЗаписьXML.ЗаписатьНачалоЭлемента("value");
			ЗаписьXML.ЗаписатьТекст(Строка(ПараметрСтроки.value));
			ЗаписьXML.ЗаписатьКонецЭлемента();
			ЗаписьXML.ЗаписатьКонецЭлемента();
		КонецЦикла;
		ЗаписьXML.ЗаписатьНачалоЭлемента("key");
		ЗаписьXML.ЗаписатьТекст(Строка(Сч));
		Сч = Сч + 1;
		ЗаписьXML.ЗаписатьКонецЭлемента();
		ЗаписьXML.ЗаписатьКонецЭлемента();
		ЗаписьXML.ЗаписатьКонецЭлемента();
	КонецЦикла;
	ЗаписьXML.ЗаписатьКонецЭлемента();
	ЗаписьXML.ЗаписатьКонецЭлемента();
	ЗаписьXML.ЗаписатьКонецЭлемента();
	ЗаписьXML.ЗаписатьКонецЭлемента();
	
	Возврат ЗаписьXML.Закрыть();
	
КонецФункции

Функция ЗапроситьОбновлениеКлассификатора(OID, Версия, МенеджерСправочника, ВидКлассификатора) Экспорт
	
	ТаблицаДанных = Неопределено;
	
	ПараметрыЗапроса = Новый Структура;
	ПараметрыЗапроса.Вставить("OID", OID);
	ПараметрыЗапроса.Вставить("ID", ПолучитьТокенПользователя());
	ПараметрыЗапроса.Вставить("ВерсияКлассификатора", Версия);
	
	ИмяОперации = "getRefbookUpdate";
	ТекстОперации = ПолучитьТекстSOAP(ИмяОперации, ПараметрыЗапроса);
	
	Результат = ВыполнитьОбменДанными(ТекстОперации, ИмяОперации);
	Если ТипЗнч(Результат) = Тип("ОбъектXDTO") Тогда
		ТаблицаДанных = ПрочитатьДанныеКлассификатораИзXDTO(МенеджерСправочника, Результат, ВидКлассификатора);
	КонецЕсли;
	
	Возврат ТаблицаДанных;
	
КонецФункции

Функция ДополнитьТаблицуИПолучитьНеактуальные(ПараметрыСправочника, ТаблицаКлассификатор, ОпределятьАрхивные = Истина) Экспорт
	
	НаименованиеСправочника = ПараметрыСправочника.НаименованиеСправочника;
	OIDСправочника = ПараметрыСправочника.OID;
	Если ПараметрыСправочника.Свойство("ВидКлассификатора") Тогда
		ВидКлассификатора = ПараметрыСправочника.ВидКлассификатора;
	Иначе
		ВидКлассификатора = Неопределено;
	КонецЕсли;
	МенеджерСправочника = Справочники[НаименованиеСправочника];
	МетаданныеСправочника = МенеджерСправочника.ПустаяСсылка().Метаданные();
	
	ТаблицаКлассификатор.Колонки.Добавить("НомерПоПорядку",	 Новый ОписаниеТипов("Число"));
	ТаблицаКлассификатор.Колонки.Добавить("Загружен",		 Новый ОписаниеТипов("Булево"));
	ТаблицаКлассификатор.Колонки.Добавить("Ссылка",			 Справочники.ТипВсеСсылки());
	ТаблицаКлассификатор.Колонки.Добавить("СледуетОбновить", Новый ОписаниеТипов("Булево"));
	ТаблицаКлассификатор.Колонки.Добавить("Уровень",		 Новый ОписаниеТипов("Число"));
	ТаблицаКлассификатор.Колонки.Добавить("ЭтоГруппа",		 Новый ОписаниеТипов("Булево"));
	
	ТаблицаКлассификатор.ЗаполнитьЗначения(Истина,	"СледуетОбновить");
	ТаблицаКлассификатор.ЗаполнитьЗначения(Ложь,	"Архив");
	
	// Заполняем поле ЭтоГруппа, если классификатор иерархический
	Если ТаблицаКлассификатор.Количество() > 2 Тогда
		ЕстьИерархияКлассификатора = Ложь;
		Для Каждого СтрокаКлассификатора Из ТаблицаКлассификатор Цикл
			Если ЗначениеЗаполнено(СтрокаКлассификатора.УИДЕГИСЗРодителя) Тогда
				ЕстьИерархияКлассификатора = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если ЕстьИерархияКлассификатора Тогда
			Для Каждого СтрокаКлассификатора Из ТаблицаКлассификатор Цикл
				СтрокаКлассификатора.ЭтоГруппа = (ТаблицаКлассификатор.Найти(СтрокаКлассификатора.УИДЕГИСЗ,"УИДЕГИСЗРодителя") <> Неопределено);
			КонецЦикла; 
		КонецЕсли;
	КонецЕсли;
	ПоискВБазеСУчетомГрупп = МетаданныеСправочника.Иерархический И МетаданныеСправочника.ВидИерархии = Метаданные.Справочники.Диагнозы.ВидИерархии;
	
	СтандартныеПоля = Новый Массив;
	СтандартныеПоля.Добавить("УИДЕГИСЗРодителя");
	СтандартныеПоля.Добавить("УИДЕГИСЗ");
	СтандартныеПоля.Добавить("OIDСправочникаИсточника");
	СтандартныеПоля.Добавить("Архив");
	СтандартныеПоля.Добавить("ПометкаУдаления");
	СтандартныеПоля.Добавить("ЭтоГруппа"); // В запрос добавляется через ТекстДополнительныеПоля.
	
	Запрос = Новый Запрос;
	Если ЗначениеЗаполнено(ВидКлассификатора) Тогда
		Запрос.УстановитьПараметр("OIDОсновной", МенеджерСправочника.ПолучитьOIDСправочника(ВидКлассификатора));
	Иначе
		Запрос.УстановитьПараметр("OIDОсновной", МенеджерСправочника.ПолучитьOIDСправочника());
	КонецЕсли;
	
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	Ссылка,
		|	ВерсияКлассификатораМинздрава,
		|	УИДЕГИСЗРодителя,
		|	УИДЕГИСЗ,
		|	Архив,
		|	ПометкаУдаления,
		|	ВЫБОР КОГДА OIDСправочникаИсточника = """" ТОГДА &OIDОсновной ИНАЧЕ OIDСправочникаИсточника КОНЕЦ КАК OIDСправочникаИсточника
		|	%ДополнительныеПоля%
		|ИЗ
		|	&Источник КАК Источник
		|ГДЕ
		|	&УсловиеПроверкиВидаКлассификатора
		|	И &УсловиеОтбора
		|УПОРЯДОЧИТЬ ПО
		|	Архив";
		
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&Источник","Справочник." + НаименованиеСправочника);
	
	Если ЗначениеЗаполнено(ВидКлассификатора) Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст,"&УсловиеПроверкиВидаКлассификатора", "Источник.ВидКлассификатора = &ВидКлассификатора");
		Запрос.УстановитьПараметр("ВидКлассификатора", ВидКлассификатора);
	Иначе
		Запрос.УстановитьПараметр("УсловиеПроверкиВидаКлассификатора", Истина);
	КонецЕсли;
	
	Попытка
		МенеджерСправочника.УстановитьУсловиеОтбораДанныхСправочника(Запрос);
	Исключение
		Запрос.УстановитьПараметр("УсловиеОтбора", Истина);
	КонецПопытки;
	
	// Получаем перечень дополнительных полей поиска и загружаемых для запроса.
	Если ЗначениеЗаполнено(ВидКлассификатора) Тогда
		ЗагружаемыеПоля = МенеджерСправочника.ПолучитьЗагружаемыеПоляЕГИСЗ(ВидКлассификатора);
	Иначе
		ЗагружаемыеПоля = МенеджерСправочника.ПолучитьЗагружаемыеПоляЕГИСЗ();
	КонецЕсли;
	
	Если Не (ЗагружаемыеПоля.Свойство("ПолноеНаименование")
			Или ЗагружаемыеПоля.Свойство("НаименованиеПолное"))
	Тогда
		Если МетаданныеСправочника.Реквизиты.Найти("НаименованиеПолное") <> Неопределено Тогда
			ЗагружаемыеПоля.Вставить("НаименованиеПолное", "Наименование");
		ИначеЕсли МетаданныеСправочника.Реквизиты.Найти("ПолноеНаименование") <> Неопределено Тогда
			ЗагружаемыеПоля.Вставить("ПолноеНаименование", "Наименование");
		КонецЕсли;
	КонецЕсли;
	
	ПорядокПоиска = ПорядокПоиска(МенеджерСправочника, OIDСправочника, ВидКлассификатора);
	
	ВсеПоляЗапроса = Новый Структура;
	Для Каждого ПоляПоиска Из ПорядокПоиска Цикл
		Для Каждого ПолеПоиска Из ПоляПоиска Цикл
			Если Не ВсеПоляЗапроса.Свойство(ПолеПоиска.Ключ) Тогда
				ВсеПоляЗапроса.Вставить(ПолеПоиска.Ключ, ПолеПоиска.Ключ);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	Для Каждого ПолеПоиска Из ЗагружаемыеПоля Цикл
		Если Не ВсеПоляЗапроса.Свойство(ПолеПоиска.Ключ)
			И СтандартныеПоля.Найти(ПолеПоиска.Значение) = Неопределено
		Тогда
			ВсеПоляЗапроса.Вставить(ПолеПоиска.Ключ, ПолеПоиска.Ключ);
		КонецЕсли;
	КонецЦикла;
	
	ТекстДополнительныеПоля = "";
	
	// Если справочник с иерархией групп, то получаем из БД поле ЭтоГруппа.
	Если ПоискВБазеСУчетомГрупп Тогда
		ТекстДополнительныеПоля = ТекстДополнительныеПоля + "," + Символы.ПС + "ЭтоГруппа КАК ЭтоГруппа";
	КонецЕсли;
	
	КолонкиАтрибутов = Новый Массив;
	
	Для Каждого ПолеПоиска Из ВсеПоляЗапроса Цикл
		Если СтрНачинаетсяС(ПолеПоиска.Ключ, "ТЧ_Атрибуты_") Тогда
			КолонкиАтрибутов.Добавить(Новый Структура("ИмяКолонки, ИмяАтрибута", ПолеПоиска.Ключ, СтрЗаменить(ПолеПоиска.Ключ, "ТЧ_Атрибуты_", "")));
			Продолжить;
		КонецЕсли;
		СинонимПоля = ПолеПоиска.Значение;
		Если СтандартныеПоля.Найти(СинонимПоля) = Неопределено Тогда
			ТекстДополнительныеПоля = ТекстДополнительныеПоля + "," + Символы.ПС + ПолеПоиска.Ключ + " КАК " + СинонимПоля;
		КонецЕсли;
	КонецЦикла;
	
	ЕстьДопАтрибуты = ТаблицаКлассификатор.Колонки.Найти("Атрибуты") <> Неопределено;
	Если ЕстьДопАтрибуты Тогда
		ТекстДополнительныеПоля = ТекстДополнительныеПоля + "," + Символы.ПС + "Источник.Атрибуты.(Ключ КАК Ключ,Значение КАК Значение)" + " КАК " + "Атрибуты";
	КонецЕсли;
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "%ДополнительныеПоля%", ТекстДополнительныеПоля);
	
	// Получение и индексирование текущих данных справочника.
	ДанныеСправочника = Запрос.Выполнить().Выгрузить();
	ДанныеСправочника.Индексы.Добавить("УИДЕГИСЗ");
	
	Попытка
		ДлинаНаименования = МетаданныеСправочника.СтандартныеРеквизиты.Наименование.Тип.КвалификаторыСтроки.Длина;
	Исключение
		ДлинаНаименования = 1000;
	КонецПопытки;
	
	Для Каждого КолонкаАтрибута Из КолонкиАтрибутов Цикл
		
		ДанныеСправочника.Колонки.Добавить(КолонкаАтрибута.ИмяКолонки, Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(100)));
		Для Каждого СтрокаДанныхСправочника Из ДанныеСправочника Цикл
			СтрокаАтрибута = СтрокаДанныхСправочника.Атрибуты.Найти(КолонкаАтрибута.ИмяАтрибута, "Ключ");
			Если СтрокаАтрибута <> Неопределено Тогда
				СтрокаДанныхСправочника[КолонкаАтрибута.ИмяКолонки] = СтрокаАтрибута.Значение;
			КонецЕсли;
		КонецЦикла;
		
		ТаблицаКлассификатор.Колонки.Добавить(КолонкаАтрибута.ИмяКолонки, Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(100)));
		Для Каждого СтрокаТаблицы Из ТаблицаКлассификатор Цикл
			СтрокаАтрибута = СтрокаТаблицы.Атрибуты.Найти(КолонкаАтрибута.ИмяАтрибута, "Ключ");
			Если СтрокаАтрибута <> Неопределено Тогда
				СтрокаТаблицы[КолонкаАтрибута.ИмяКолонки] = СтрокаАтрибута.Значение;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	Попытка
		Если ЗначениеЗаполнено(ВидКлассификатора) Тогда
			МенеджерСправочника.ПередОбработкойТаблицыКлассификатора(ТаблицаКлассификатор, ВидКлассификатора);
		Иначе
			МенеджерСправочника.ПередОбработкойТаблицыКлассификатора(ТаблицаКлассификатор);
		КонецЕсли;
	Исключение КонецПопытки;
	
	// Поиск ссылок в БД.
	Сч = 0;

	Для Каждого СтрокаКлассификатора Из ТаблицаКлассификатор Цикл
		
		Попытка
			МенеджерСправочника.ПередПоискомЭлементаКлассификатораВБазе(СтрокаКлассификатора);
		Исключение
			ОписаниеОшибки = ОписаниеОшибки();
		КонецПопытки;
		
		СтрокаКлассификатора.НомерПоПорядку = Сч;
		Сч = Сч + 1;
		
		Отбор = Новый Структура;
		НайденныеЭлементы = Новый Массив;
		Для Каждого ПоляПоиска Из ПорядокПоиска Цикл
			Отбор.Очистить();
			Для Каждого ПолеПоиска Из ПоляПоиска Цикл
				ЗначениеОтбора = СтрокаКлассификатора[ПолеПоиска.Значение];
				Если ТипЗнч(ЗначениеОтбора) = Тип("Строка") Тогда
					ЗначениеОтбора = СокрЛП(ЗначениеОтбора);
				КонецЕсли;
				Отбор.Вставить(ПолеПоиска.Значение, ЗначениеОтбора);
			КонецЦикла;
			
			// Если есть пустые поля отбора, такой поиск не применяем
			ПропуститьСпособПоиска = Ложь;
			Для Каждого ПолеОтбора Из Отбор Цикл
				Если Не ЗначениеЗаполнено(ПолеОтбора.Значение) Тогда
					ПропуститьСпособПоиска = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если ПропуститьСпособПоиска Тогда
				Продолжить;
			КонецЕсли;
			
			// Для иерархических справочников - ищем всегда еще и по ЭтоГруппа
			Если ПоискВБазеСУчетомГрупп Тогда
				Отбор.Вставить("ЭтоГруппа", СтрокаКлассификатора.ЭтоГруппа);
			КонецЕсли;
			
			НайденныеЭлементы = ДанныеСправочника.НайтиСтроки(Отбор);
			Если НайденныеЭлементы.Количество() <> 0 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если НайденныеЭлементы.Количество() <> 0 Тогда
			ДанныеЭлементаБД = НайденныеЭлементы[0];
			
			СтрокаПолей = "Ссылка";
			Для Каждого ПолеПоиска Из Отбор Цикл
				ОбщегоНазначенияКлиентСервер.КонкатенацияСтрок(СтрокаПолей, ПолеПоиска.Ключ);
			КонецЦикла;
			
			ЗаполнитьЗначенияСвойств(СтрокаКлассификатора, ДанныеЭлементаБД, СтрокаПолей);
			СтрокаКлассификатора.Загружен = Истина;
			
			СтрокаКлассификатора.СледуетОбновить = Ложь;
			
			Если ДанныеЭлементаБД.ВерсияКлассификатораМинздрава <> ПараметрыСправочника.Версия
				Или ДанныеЭлементаБД.УИДЕГИСЗРодителя <> СтрокаКлассификатора.УИДЕГИСЗРодителя
				Или ДанныеЭлементаБД.ПометкаУдаления
			Тогда
				СтрокаКлассификатора.СледуетОбновить = Истина;
				Продолжить;
			КонецЕсли;
			
			Для Каждого Поле Из ЗагружаемыеПоля Цикл
				
				ЗначениеБД = ДанныеЭлементаБД[Поле.Ключ];
				Если ТипЗнч(ЗначениеБД) = Тип("Строка") Тогда
					ЗначениеБД = СокрП(ЗначениеБД);
				КонецЕсли;
				
				Если ЗначениеБД <> СтрокаКлассификатора[Поле.Значение]
					И ДанныеЭлементаБД.OIDСправочникаИсточника = СтрокаКлассификатора.OIDСправочникаИсточника
					И Не (Поле.Ключ = "Наименование" И СокрЛП(Лев(ЗначениеБД, ДлинаНаименования)) = СокрЛП(Лев(СтрокаКлассификатора[Поле.Значение], ДлинаНаименования)))
				Тогда
					СтрокаКлассификатора.СледуетОбновить = ЗначениеБД <> Null;
				КонецЕсли;
			КонецЦикла;
			Если ЕстьДопАтрибуты Тогда
				Для Каждого Атрибут Из СтрокаКлассификатора["Атрибуты"] Цикл
					Если ТипЗнч(Атрибут.Значение) = Тип("Строка") Тогда
						Атрибут.Значение = СокрП(Атрибут.Значение);
					КонецЕсли;
					
					СтарыйАтрибут = ДанныеЭлементаБД["Атрибуты"].Найти(Атрибут.Ключ,"Ключ");
					ОдинИсточник = (ДанныеЭлементаБД.OIDСправочникаИсточника = СтрокаКлассификатора.OIDСправочникаИсточника);
					Если СтарыйАтрибут <> Неопределено И СтарыйАтрибут.Значение <> Атрибут.Значение И ОдинИсточник Тогда
						СтрокаКлассификатора.СледуетОбновить = Истина;
						Прервать;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Попытка
		Если ЗначениеЗаполнено(ВидКлассификатора) Тогда
			МенеджерСправочника.ПослеОбработкиТаблицыКлассификатора(ТаблицаКлассификатор, ВидКлассификатора);
		Иначе
			МенеджерСправочника.ПослеОбработкиТаблицыКлассификатора(ТаблицаКлассификатор);
		КонецЕсли;
	Исключение КонецПопытки;
	
	// Получим устаревшие
	Если ОпределятьАрхивные Тогда
		Запрос.Текст = 
			"ВЫБРАТЬ РАЗЛИЧНЫЕ
			|	ДанныеКлассификатора.Ссылка КАК Ссылка
			|ПОМЕСТИТЬ ДанныеКлассификатора
			|ИЗ
			|	&ДанныеКлассификатора КАК ДанныеКлассификатора
			|ГДЕ
			|	НЕ ДанныеКлассификатора.Архив
			|;
			|
			|////////////////////////////////////////////////////////////////////////////////
			|ВЫБРАТЬ
			|	ДанныеСправочника.Ссылка КАК Ссылка,
			|	ДанныеСправочника.Архив КАК Архив,
			|	ДанныеСправочника.ПометкаУдаления КАК ПометкаУдаления,
			|	ДанныеСправочника.OIDСправочникаИсточника КАК OIDСправочникаИсточника
			|ПОМЕСТИТЬ ДанныеСправочника
			|ИЗ
			|	&ДанныеСправочника КАК ДанныеСправочника
			|;
			|
			|////////////////////////////////////////////////////////////////////////////////
			|ВЫБРАТЬ
			|	ДанныеСправочника.Ссылка КАК Ссылка,
			|	ДанныеСправочника.Архив КАК Архив
			|ИЗ
			|	ДанныеСправочника КАК ДанныеСправочника
			|ГДЕ
			|	НЕ ДанныеСправочника.ПометкаУдаления
			|	И НЕ ДанныеСправочника.Архив
			|	И ДанныеСправочника.OIDСправочникаИсточника = &OIDСправочникаИсточника
			|	И НЕ ДанныеСправочника.Ссылка В
			|				(ВЫБРАТЬ
			|					ДанныеКлассификатора.Ссылка
			|				ИЗ
			|					ДанныеКлассификатора)";
		
		Запрос.УстановитьПараметр("ДанныеКлассификатора", ТаблицаКлассификатор);
		Запрос.УстановитьПараметр("ДанныеСправочника", ДанныеСправочника);
		Запрос.УстановитьПараметр("OIDСправочникаИсточника", OIDСправочника);
		Возврат Запрос.Выполнить().Выгрузить();
	Иначе
		ТаблицаАрхивные = Новый ТаблицаЗначений;
		ТаблицаАрхивные.Колонки.Добавить("Ссылка");
		ТаблицаАрхивные.Колонки.Добавить("Архив");
		Возврат ТаблицаАрхивные;
	КонецЕсли;
	
КонецФункции

Функция ПорядокПоиска(МенеджерСправочника, OIDСправочника, ВидКлассификатора)
	
	Если ЗначениеЗаполнено(ВидКлассификатора) Тогда
		ПорядокПоиска = МенеджерСправочника.ПолучитьПорядокПоискаСуществующихОбъектов(ВидКлассификатора);
	Иначе
		Попытка
			ПорядокПоиска = МенеджерСправочника.ПолучитьПорядокПоискаСуществующихОбъектов();
		Исключение
			ПорядокПоиска = МенеджерСправочника.ПолучитьПорядокПоискаСуществующихОбъектов(OIDСправочника);
		КонецПопытки;
	КонецЕсли;
	
	Возврат ПорядокПоиска;
	
КонецФункции

Функция ПолучитьДеревоКлассификации(ПараметрыЗагрузки, ПараметрыФормы, ВызовИзДлительнойОперации = Ложь, ТестовыйКонтур = Ложь) Экспорт
	OIDСправочника = ПараметрыЗагрузки.OID;
	НаименованиеСправочника = ПараметрыЗагрузки.НаименованиеСправочника;
	Версия = ПараметрыЗагрузки.Версия;
	МенеджерСправочника = Справочники[НаименованиеСправочника];
	Если ПараметрыЗагрузки.Свойство("ВидКлассификатора") Тогда
		ВидКлассификатора = ПараметрыЗагрузки.ВидКлассификатора;
	Иначе
		ВидКлассификатора = Неопределено;
	КонецЕсли;
	
	ЕстьОтборЗагрузки = ПараметрыЗагрузки.Свойство("Отбор");
	Если ЕстьОтборЗагрузки Тогда
		ТаблицаКлассификатор = ПолучитьКлассификаторПоОтбору(OIDСправочника, МенеджерСправочника, ПараметрыЗагрузки.Отбор, Версия, , ТестовыйКонтур);
	ИначеЕсли ЗначениеЗаполнено(ВидКлассификатора) Тогда
		ТаблицаКлассификатор = ЗапроситьКлассификатор(OIDСправочника, Версия, МенеджерСправочника, ВидКлассификатора, ТестовыйКонтур);
	Иначе
		ТаблицаКлассификатор = ЗапроситьКлассификатор(OIDСправочника, Версия, МенеджерСправочника, , ТестовыйКонтур);
	КонецЕсли;
	
	Если ТипЗнч(ТаблицаКлассификатор) = Тип("ТаблицаЗначений") Тогда
		
		Если ТаблицаКлассификатор.Колонки.Найти("УИДЕГИСЗ") <> Неопределено Тогда
			ТаблицаКлассификатор.Сортировать("УИДЕГИСЗ");
		КонецЕсли;
			
		Для Каждого СтрокаКлассификатора Из ТаблицаКлассификатор Цикл
			СтрокаКлассификатора.OIDСправочникаИсточника = OIDСправочника;
		КонецЦикла;
		
		ТЗНеактуальные = ДополнитьТаблицуИПолучитьНеактуальные(ПараметрыЗагрузки, ТаблицаКлассификатор, Не ЕстьОтборЗагрузки);
		
		ОформитьДерево(ПараметрыФормы["Актуальное"], ТаблицаКлассификатор);
		
		// Из фонового задания длительной оперции нам приходит дерево, а без нее данные формы
		Если ВызовИзДлительнойОперации Тогда
			Архивное = ПараметрыФормы["Архивное"].Строки;
		Иначе
			Архивное = ПараметрыФормы["Архивное"].ПолучитьЭлементы();
		КонецЕсли;
		
		Для Каждого Строка Из ТЗНеактуальные Цикл
			ЭлементСписка = Архивное.Добавить();
			ЗаполнитьЗначенияСвойств(ЭлементСписка, Строка);
			ЭлементСписка.Пометка = Не ЭлементСписка.Архив;
		КонецЦикла;
		
		// Для фонового задания длительной операции сохраняем так же деревья
		Если Не ВызовИзДлительнойОперации Тогда
			АдресХранилища = ПоместитьВоВременноеХранилище(ТаблицаКлассификатор, ПараметрыФормы["УИД"]);
		Иначе
			Структура = Новый Структура();
			Структура.Вставить("Архивное", ПараметрыФормы["Архивное"]);
			Структура.Вставить("Актуальное", ПараметрыФормы["Актуальное"]);
			ОбщегоНазначения.ЗаписатьДанныеВБезопасноеХранилище(OIDСправочника, ТаблицаКлассификатор, "ТаблицаКлассификатор");
			Возврат Структура;
		КонецЕсли;
		
		Возврат АдресХранилища;
		
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

Процедура ПолучитьДеревоКлассификацииДлительнаяОперация(Параметры, АдресРезультата) Экспорт
	
	РезультатСтруктура = ПолучитьДеревоКлассификации(Параметры.ПараметрыЗагрузки,Параметры.ПараметрыФормы, Истина);
	ПоместитьВоВременноеХранилище(РезультатСтруктура, АдресРезультата);
	
КонецПроцедуры

// Записывает строки таблицы ТаблицаКлассификатор как элементы справочника
//
// Параметры:
//  Параметры				 - Структура - поля:
//								* OID - Строка - oid справочника
//								* Версия - Строка - Версия справочника
//								* МенеджерСправочника - СправочникМенеджер.<Имя справочника>  - менеджер справочника
//								* ВидКлассификатора - Перечисления.ВидыКлассификаторовМинЗдрава  - Необязательное поле
//  ТаблицаКлассификатор	 - ТаблицаЗначений - Результат запроса к сайту НСИ
//  ДеревоКлассификатора	 - ДеревоЗначений - 
//  ДополнительныеСвойства	 - Структура - Дополнительные параметры при загрузке
//
Процедура ЗаписатьНовыеЭлементыСправочника(Параметры, ТаблицаКлассификатор, ДеревоКлассификатора = Неопределено, 
	Знач ДополнительныеСвойства = Неопределено, РежимОбновления = Неопределено, ТестовыйКонтур = Ложь) Экспорт
	
	Если ТаблицаКлассификатор = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	OID = Параметры.OID;
	Версия = Параметры.Версия;
	МенеджерСправочника = Параметры.МенеджерСправочника;
	
	Если ДополнительныеСвойства = Неопределено Тогда
		ДополнительныеСвойства = Новый Структура;
	КонецЕсли;
	
	ДополнительныеСвойства.Вставить("ТестовыйКонтур", ТестовыйКонтур);
	
	Попытка
		МенеджерСправочника.ЗагрузкаСправочникаПередНачаломЗагрузки(ТаблицаКлассификатор, OID, ДополнительныеСвойства);
	Исключение
	КонецПопытки;
	
	Для Каждого СтрокаКлассификатора Из ТаблицаКлассификатор Цикл
		СтрокаКлассификатора.OIDСправочникаИсточника = OID;
	КонецЦикла;
	
	Если ДеревоКлассификатора = Неопределено Тогда
		ДеревоКлассификатора = ПолучитьДеревоКлассификатора();
		ТЗНеактуальное = ДополнитьТаблицуИПолучитьНеактуальные(Параметры, ТаблицаКлассификатор);
		ПоместитьНеактуальноеВАрхив(ТЗНеактуальное);
		ОформитьДерево(ДеревоКлассификатора, ТаблицаКлассификатор);
	КонецЕсли;
	
	Если ТипЗнч(ДеревоКлассификатора) = Тип("ДеревоЗначений") Тогда
		ВетвиДерева = ДеревоКлассификатора.Строки;
	Иначе
		ВетвиДерева = ДеревоКлассификатора.ПолучитьЭлементы();
	КонецЕсли;
	
	Если Параметры.Свойство("ОбновитьВерсию") Тогда
		СохранитьВерсию = Параметры.ОбновитьВерсию;
	Иначе
		СохранитьВерсию = Параметры.Свойство("ДатаВерсии") И ВыбраныВсеЭлементы(ВетвиДерева);
	КонецЕсли;
	
	Для Каждого СтрокаДереваКлассификатора Из ВетвиДерева Цикл
		ОбходДереваЗначений(СтрокаДереваКлассификатора, ТаблицаКлассификатор,Параметры,ДополнительныеСвойства,,РежимОбновления);
	КонецЦикла;
	
	Если СохранитьВерсию Тогда
		МенеджерЗаписи = РегистрыСведений.НастройкиОбновленияСправочниковЕГИСЗ.СоздатьМенеджерЗаписи();
		МенеджерЗаписи.Классификатор = OID;
		МенеджерЗаписи.Прочитать();
		Если МенеджерЗаписи.Выбран() Тогда
			МенеджерЗаписи.ДатаПоследнегоОбновления = ТекущаяДата();
			МенеджерЗаписи.Версия					= Версия;
			МенеджерЗаписи.ДатаВерсии				= Параметры.ДатаВерсии;
			МенеджерЗаписи.Записать();
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Функция ВыбраныВсеЭлементы(ВетвиДерева)
	
	Для Каждого СтрокаДерева Из ВетвиДерева Цикл
		
		Если ТипЗнч(ВетвиДерева) = Тип("КоллекцияСтрокДереваЗначений") Тогда
			ДочерниеЭлементы = СтрокаДерева.Строки;
		Иначе
			ДочерниеЭлементы = СтрокаДерева.ПолучитьЭлементы();
		КонецЕсли;
		
		Если СтрокаДерева.Пометка <> 1
			Или Не ВыбраныВсеЭлементы(ДочерниеЭлементы)
		Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Процедура ПоместитьНеактуальноеВАрхив(ТЗНеактуальное)
	Для Каждого СтрокаЭлемента Из ТЗНеактуальное Цикл
		Если Не СтрокаЭлемента.Архив Тогда
			ОбъектЭлемента = СтрокаЭлемента.Ссылка.ПолучитьОбъект();
			ОбъектЭлемента.Архив = Истина;
			ОбъектЭлемента.Записать();
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Функция ПолучитьДеревоКлассификатора()
	
	ДеревоКлассификатора = Новый ДеревоЗначений;
	ДеревоКлассификатора.Колонки.Добавить("OIDСправочникаИсточника",Новый ОписаниеТипов("Строка"));
	ДеревоКлассификатора.Колонки.Добавить("Архив",Новый ОписаниеТипов("Булево"));
	ДеревоКлассификатора.Колонки.Добавить("Загружен",Новый ОписаниеТипов("Булево"));
	ДеревоКлассификатора.Колонки.Добавить("Код",Новый ОписаниеТипов("Строка"));
	ДеревоКлассификатора.Колонки.Добавить("Наименование",Новый ОписаниеТипов("Строка"));
	ДеревоКлассификатора.Колонки.Добавить("НомерПоПорядку",Новый ОписаниеТипов("Число"));
	ДеревоКлассификатора.Колонки.Добавить("Пометка",Новый ОписаниеТипов("Булево"));
	ДеревоКлассификатора.Колонки.Добавить("СледуетОбновить",Новый ОписаниеТипов("Булево"));
	ДеревоКлассификатора.Колонки.Добавить("Ссылка");
	ДеревоКлассификатора.Колонки.Добавить("УИДЕГИСЗ",Новый ОписаниеТипов("Число"));
	ДеревоКлассификатора.Колонки.Добавить("УИДЕГИСЗРодителя",Новый ОписаниеТипов("Число"));
	ДеревоКлассификатора.Колонки.Добавить("Уровень",Новый ОписаниеТипов("Число"));
	
	Возврат ДеревоКлассификатора;
	
КонецФункции

Процедура ОформитьДерево(КорневойЭлемент,ТаблицаКлассификатор,УИДЕГИСЗРодителя = 0, Уровень = 0) Экспорт
	
	Если ТипЗнч(КорневойЭлемент) = Тип("ДеревоЗначений")
		Или ТипЗнч(КорневойЭлемент) = Тип("СтрокаДереваЗначений")
	Тогда
		ВетвьДерева = КорневойЭлемент.Строки;
	Иначе
		ВетвьДерева = КорневойЭлемент.ПолучитьЭлементы();
	КонецЕсли;
	СтруктураОтборРодитель = Новый Структура("УИДЕГИСЗРодителя", УИДЕГИСЗРодителя);
	СтрокиПоиска = ТаблицаКлассификатор.НайтиСтроки(СтруктураОтборРодитель);
	Для Каждого Строка Из СтрокиПоиска Цикл
		СтрокаДерева = ВетвьДерева.Добавить();
		Строка.Уровень = Уровень;
		ЗаполнитьЗначенияСвойств(СтрокаДерева, Строка);
		СтрокаДерева.Пометка = СтрокаДерева.СледуетОбновить;
		
		Если СтрокаДерева.Пометка Тогда
			Родитель = ПолучитьРодителя(СтрокаДерева);
			Пока Родитель <> Неопределено Цикл
				Родитель.Пометка = Истина;
				Родитель = ПолучитьРодителя(Родитель);
			КонецЦикла;
		КонецЕсли;
		
		Если Строка.УИДЕГИСЗ <> УИДЕГИСЗРодителя Тогда
			ОформитьДерево(СтрокаДерева, ТаблицаКлассификатор,Строка.УИДЕГИСЗ,Уровень + 1);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция ПолучитьРодителя(СтрокаДерева)
	
	Если ТипЗнч(СтрокаДерева) = Тип("ДеревоЗначений")
		Или ТипЗнч(СтрокаДерева) = Тип("СтрокаДереваЗначений")
	Тогда
		Возврат СтрокаДерева.Родитель;
	Иначе
		Возврат СтрокаДерева.ПолучитьРодителя();
	КонецЕсли;
	
КонецФункции

Процедура ОбходДереваЗначений(СтрокаДереваКлассификатора, ТаблицаКлассификатор, Параметры, ДополнительныеСвойства, Родитель, РежимОбновления)
	
	Перем СсылкаНаОбъект;
	
	СообщениеОтказа = "";
	Попытка
		СтрокаКлассификатора = ТаблицаКлассификатор.НайтиСтроки(Новый Структура("НомерПоПорядку", СтрокаДереваКлассификатора.НомерПоПорядку))[0];
	Исключение
		Возврат;
	КонецПопытки;
	
	МенеджерСправочника = Параметры.МенеджерСправочника;
	OID = Параметры.OID;
	Версия = Параметры.Версия;
	Если Параметры.Свойство("ВидКлассификатора") Тогда
		ВидКлассификатора = Параметры.ВидКлассификатора;
	Иначе
		ВидКлассификатора = Неопределено;
	КонецЕсли;
	
	Если СтрокаДереваКлассификатора.Пометка > 0 И Не СтрокаДереваКлассификатора.Архив Тогда
		Попытка
			Если ТипЗнч(СтрокаДереваКлассификатора) = Тип("СтрокаДереваЗначений") Тогда
				КоллекцияСтрокиДереваКлассификатора = СтрокаДереваКлассификатора.Строки;
			Иначе
				КоллекцияСтрокиДереваКлассификатора = СтрокаДереваКлассификатора.ПолучитьЭлементы();
			КонецЕсли;
			
			Отказ = Ложь;
			СообщениеИсключения = Неопределено;
			Попытка
				Если ЗначениеЗаполнено(ВидКлассификатора) Тогда
					СообщениеИсключения = МенеджерСправочника.ЗагрузкаСправочникаПередЗагрузкойЭлемента(СтрокаДереваКлассификатора, Родитель, ДополнительныеСвойства, OID, Отказ, ВидКлассификатора, СтрокаКлассификатора);
				Иначе
					СообщениеИсключения = МенеджерСправочника.ЗагрузкаСправочникаПередЗагрузкойЭлемента(СтрокаДереваКлассификатора, Родитель, ДополнительныеСвойства, OID, Отказ);
				КонецЕсли;
			Исключение
			КонецПопытки;
			// Прерываем загрузку, если этого потребовал обработчик.
			Если ЗначениеЗаполнено(СообщениеИсключения) Тогда
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(СообщениеИсключения);
				ВызватьИсключение СообщениеИсключения;
			КонецЕсли;
			
			Если Родитель <> Неопределено И Родитель = СтрокаДереваКлассификатора.Ссылка Тогда
				Отказ = Истина;
			КонецЕсли; 
			
			СсылкаНаОбъект = СтрокаДереваКлассификатора.Ссылка;
			Если Не Отказ Тогда
				
				Если ЗначениеЗаполнено(СтрокаДереваКлассификатора.Ссылка) Тогда
					
					ОбъектСправочника = СтрокаДереваКлассификатора.Ссылка.ПолучитьОбъект();
					
					Если ОбъектСправочника.Метаданные().ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов
						И Не ОбъектСправочника.ЭтоГруппа
						И КоллекцияСтрокиДереваКлассификатора.Количество() > 0
					Тогда
						// Элемент есть, но в реестре он теперь является группой
						ОбъектСправочника.Архив = Истина;
						ОбъектСправочника.Записать();
						ОбъектСправочника = МенеджерСправочника.СоздатьГруппу();
						ОбъектСправочника.Родитель = СтрокаДереваКлассификатора.Ссылка.Родитель;
					КонецЕсли;
				Иначе
					Если РежимОбновления = Перечисления.РежимыАвтоОбновленияСправочниковЕГИСЗ.ТолькоЗагруженных Тогда
						Возврат;
					КонецЕсли;
					// Получаем подчиненные элементы
					Если КоллекцияСтрокиДереваКлассификатора.Количество() > 0
						И Не МенеджерСправочника.ПустаяСсылка().Метаданные().ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияЭлементов
					Тогда
						// Создаем группу, так как у нее есть подчиненные элементы
						ОбъектСправочника = МенеджерСправочника.СоздатьГруппу();
					Иначе
						ОбъектСправочника = МенеджерСправочника.СоздатьЭлемент();
					КонецЕсли;
				КонецЕсли;
				
				// Получаем загружаемые поля справочника
				Если ЗначениеЗаполнено(ВидКлассификатора) Тогда
					ЗагружаемыеПоля = МенеджерСправочника.ПолучитьЗагружаемыеПоляЕГИСЗ(ВидКлассификатора);
				Иначе
					ЗагружаемыеПоля = МенеджерСправочника.ПолучитьЗагружаемыеПоляЕГИСЗ();
				КонецЕсли;
				
				Если Не ЗагружаемыеПоля.Свойство("ПолноеНаименование")
					И Не ЗагружаемыеПоля.Свойство("НаименованиеПолное")
					И ЗагружаемыеПоля.Свойство("Наименование")
				Тогда
					ЗагружаемыеПоля.Вставить("НаименованиеПолное", "Наименование");
				КонецЕсли;
				
				Для Каждого Поле Из ЗагружаемыеПоля Цикл
					Попытка
						Если ТипЗнч(СтрокаКлассификатора[Поле.Значение]) = Тип("Строка") Тогда
							СтрокаКлассификатора[Поле.Значение] = СокрЛП(СтрокаКлассификатора[Поле.Значение]);
						КонецЕсли; 
						ОбъектСправочника[Поле.Ключ] = СтрокаКлассификатора[Поле.Значение];
					Исключение
					КонецПопытки;
				КонецЦикла;
				
				Если ТаблицаКлассификатор.Колонки.Найти("Атрибуты") <> Неопределено И Не ОбъектСправочника.ЭтоГруппа Тогда
					ОбъектСправочника.Атрибуты.Очистить();
					Для Каждого Атрибут Из СтрокаКлассификатора.Атрибуты Цикл
						НоваяСтрока = ОбъектСправочника.Атрибуты.Добавить();
						НоваяСтрока.Ключ = Атрибут.Ключ;
						НоваяСтрока.Значение = Атрибут.Значение;
					КонецЦикла;
				КонецЕсли;
				
				Если (Не ЗначениеЗаполнено(ОбъектСправочника.Родитель)
						И ЗначениеЗаполнено(Родитель))
					Или (ЗначениеЗаполнено(ОбъектСправочника.Родитель)
						И ОбъектСправочника.Родитель <> Родитель)
				Тогда
					ОбъектСправочника.Родитель = Родитель;
				ИначеЕсли ЗначениеЗаполнено(ОбъектСправочника.Родитель)
					И ОбъектСправочника.Родитель.Архив
				Тогда
					// Родитель в Архиве, т.е. элемент перемещен в корень справочника.
					ОбъектСправочника.Родитель = Неопределено;
				КонецЕсли;
				
				ОбъектСправочника.ПометкаУдаления = Ложь;
				ОбъектСправочника.Архив = СтрокаДереваКлассификатора.Архив;
				
				Если ЗначениеЗаполнено(ВидКлассификатора) Тогда
					ОбъектСправочника.ВидКлассификатора = ВидКлассификатора;
				КонецЕсли;
				//СтрокаКлассификатора
				Попытка
					МенеджерСправочника.ЗагрузкаСправочникаИзЕГИСЗПередЗаписью(ОбъектСправочника, ДополнительныеСвойства, СтрокаКлассификатора, СообщениеОтказа);
				Исключение КонецПопытки;
				Если Не ПустаяСтрока(СообщениеОтказа) Тогда
					ВызватьИсключение "";
				КонецЕсли;
				
				ОбъектСправочника.OIDСправочникаИсточника = СтрокаДереваКлассификатора.OIDСправочникаИсточника;
				ОбъектСправочника.ВерсияКлассификатораМинздрава = Версия;
				
				ОбъектСправочника.Записать();
				СсылкаНаОбъект = ОбъектСправочника.Ссылка;
				СтрокаДереваКлассификатора.Ссылка = СсылкаНаОбъект;
				
			КонецЕсли;
			СтрокаДереваКлассификатора.Пометка = Ложь;
			
			// Рекурсивный вызов процедуры для каждого элемента подгруппы
			Если КоллекцияСтрокиДереваКлассификатора.Количество() > 0 Тогда
				Для Каждого ПодстрокаДереваКлассификатора Из КоллекцияСтрокиДереваКлассификатора Цикл
					ОбходДереваЗначений(ПодстрокаДереваКлассификатора, ТаблицаКлассификатор,
						Параметры,ДополнительныеСвойства,СсылкаНаОбъект, РежимОбновления);
				КонецЦикла;
			КонецЕсли;
			
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Не удалось загрузить " + СтрокаДереваКлассификатора.Наименование);
		КонецПопытки;
	КонецЕсли;
	
	Если Не ПустаяСтрока(СообщениеОтказа) Тогда
		ТекстОшибки = "Загрузка элемента %1 прервана по причине: %2";
		ТекстОшибки = СтрШаблон(ТекстОшибки, СтрокаДереваКлассификатора.Наименование, СообщениеОтказа);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
КонецПроцедуры

Процедура СохранитьНаименованиеКлассификатора(OIDЗагружаемого, Версия = Неопределено) Экспорт
	
	ПаспортВерсииКлассификатора = ПолучитьПаспортСправочника(OIDЗагружаемого, Версия);
	Если ПаспортВерсииКлассификатора = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если Версия = Неопределено Тогда
		Версия = ПаспортВерсииКлассификатора.version;
	КонецЕсли;
	
	OIDыКлассификатора = Новый Массив;
	Для Каждого СтруктураOID Из ПаспортВерсииКлассификатора.codes Цикл
		OIDыКлассификатора.Добавить(СтруктураOID.value);
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	НаименованияВерсийКлассификаторовЕГИСЗ.OIDКлассификатора КАК OIDКлассификатора,
		|	НаименованияВерсийКлассификаторовЕГИСЗ.Наименование КАК Наименование,
		|	НаименованияВерсийКлассификаторовЕГИСЗ.ВерсияКлассификатора КАК ВерсияКлассификатора,
		|	0 КАК чВерсияКлассификатора
		|ИЗ
		|	РегистрСведений.НаименованияВерсийКлассификаторовЕГИСЗ КАК НаименованияВерсийКлассификаторовЕГИСЗ
		|ГДЕ
		|	НаименованияВерсийКлассификаторовЕГИСЗ.OIDКлассификатора В(&OIDыКлассификатора)";
	
	Запрос.УстановитьПараметр("OIDыКлассификатора", OIDыКлассификатора);
	Результат = Запрос.Выполнить().Выгрузить();
	
	Для Каждого СтрокаНаименованияВерсии Из Результат Цикл
		СтрокаНаименованияВерсии.чВерсияКлассификатора = ЧислоВерсииКлассификатора(СтрокаНаименованияВерсии.ВерсияКлассификатора);
	КонецЦикла;
	Результат.Сортировать("чВерсияКлассификатора Убыв");
	
	чЗагружаемаяВерсия = ЧислоВерсииКлассификатора(Версия);
	
	Для Каждого OID Из OIDыКлассификатора Цикл
		НаименованиеБлижайшейСнизуВерсии = "";
		Для Каждого СтрокаНаименованияВерсии Из Результат Цикл
			Если СтрокаНаименованияВерсии.OIDКлассификатора <> OID
				Или СтрокаНаименованияВерсии.чВерсияКлассификатора > чЗагружаемаяВерсия
			Тогда
				Продолжить;
			КонецЕсли;
			НаименованиеБлижайшейСнизуВерсии = СтрокаНаименованияВерсии.Наименование;
			Прервать;
		КонецЦикла;
		Если НРег(СокрЛП(НаименованиеБлижайшейСнизуВерсии)) <> НРег(Сокрлп(ПаспортВерсииКлассификатора.fullName)) Тогда
			МЗ = РегистрыСведений.НаименованияВерсийКлассификаторовЕГИСЗ.СоздатьМенеджерЗаписи();
			МЗ.Наименование = ПаспортВерсииКлассификатора.fullName;
			МЗ.ВерсияКлассификатора = Версия;
			МЗ.OIDКлассификатора = OID;
			МЗ.Записать();
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция ЧислоВерсииКлассификатора(Версия) Экспорт
	
	чВерсия = 0;
	Попытка
		Для Каждого Элемент Из СтрРазделить(СокрЛП(Версия), ".") Цикл
			чВерсия = чВерсия * 1000 + Число(Элемент);
		КонецЦикла;
	Исключение КонецПопытки;
	
	Возврат чВерсия;
	
КонецФункции

#Область ЗагрузкаДополнительныхМатериалов

Процедура ОбновитьСхематроныИСхемыВизуализации(ЗагружатьТолькоСхематроны = Ложь, ЗагружатьТолькоСхемуВизуализации = Ложь) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	РезультатПроверкиКлассификатораРЭМД = ИнтеграцияЕГИСЗВызовСервера.ПроверитьНеобходимостьАвтоОбновления("РегистрируемыеЭлектронныеМедДокументы");
	Если РезультатПроверкиКлассификатораРЭМД.ВерсияУстарела Тогда
		ШаблонТекстаСообщения = НСтр("ru='Доступна новая версия справочника ""Регистрируемые электронные мед документы"": %1. Перед загрузкой необходимо обновить справочник до последней версии!'");
		Если ЗначениеЗаполнено(РезультатПроверкиКлассификатораРЭМД.ТекущаяВерсия) Тогда
			ТекстСообщения = СтрШаблон(ШаблонТекстаСообщения, СтрШаблон(НСтр("ru='%1. Текущая версия: %2'"), РезультатПроверкиКлассификатораРЭМД.ПоследняяВерсия, РезультатПроверкиКлассификатораРЭМД.ТекущаяВерсия));
		Иначе
			ТекстСообщения = СтрШаблон(ШаблонТекстаСообщения, РезультатПроверкиКлассификатораРЭМД.ПоследняяВерсия);
		КонецЕсли;
		ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
	КонецЕсли;
	
	РезультатПроверкиКлассификатораРуководств = ИнтеграцияЕГИСЗВызовСервера.ПроверитьНеобходимостьАвтоОбновления(, "1.2.643.5.1.13.13.99.2.638");
	Если РезультатПроверкиКлассификатораРуководств.ВерсияУстарела Тогда
		ШаблонТекстаСообщения = НСтр("ru='Доступна новая версия справочника ""Реестр руководств по реализации структурированных электронных медицинских документов"": %1. Перед загрузкой необходимо обновить справочник до последней версии!'");
		Если ЗначениеЗаполнено(РезультатПроверкиКлассификатораРуководств.ТекущаяВерсия) Тогда
			ТекстСообщения = СтрШаблон(ШаблонТекстаСообщения, СтрШаблон(НСтр("ru='%1. Текущая версия: %2'"), РезультатПроверкиКлассификатораРуководств.ПоследняяВерсия, РезультатПроверкиКлассификатораРуководств.ТекущаяВерсия));
		Иначе
			ТекстСообщения = СтрШаблон(ШаблонТекстаСообщения, РезультатПроверкиКлассификатораРуководств.ПоследняяВерсия);
		КонецЕсли;
		ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
	КонецЕсли;
	
	Если РезультатПроверкиКлассификатораРЭМД.ВерсияУстарела
		Или РезультатПроверкиКлассификатораРуководств.ВерсияУстарела
	Тогда
		Возврат;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	РегистрируемыеЭлектронныеМедДокументы.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.РегистрируемыеЭлектронныеМедДокументы КАК РегистрируемыеЭлектронныеМедДокументы
		|ГДЕ
		|	НЕ РегистрируемыеЭлектронныеМедДокументы.Архив
		|	И НЕ РегистрируемыеЭлектронныеМедДокументы.ПометкаУдаления";
	
	ЗагруженныеРЭМД = Запрос.Выполнить().Выбрать();
	
	Пока ЗагруженныеРЭМД.Следующий() Цикл
		
		ТекстСхематрона = "";
		ТекстСхемыВизуализации = "";
		ВсеФайлыНайдены = Ложь;
		
		ОбъектСправочника = ЗагруженныеРЭМД.Ссылка.ПолучитьОбъект();
		
		СсылкаНаРуководствоГит = ЗагруженныеРЭМД.Ссылка.Атрибуты.Найти("GIT_LINK", "Ключ");
		Если СсылкаНаРуководствоГит <> Неопределено
			И ЗначениеЗаполнено(СсылкаНаРуководствоГит.Значение)
		Тогда
			Попытка
				Результат = ПолучитьТекстСхематронаИСхемуВизуализацииИзРепозиторияИсходногоКода(СсылкаНаРуководствоГит.Значение, ЗагружатьТолькоСхематроны, ЗагружатьТолькоСхемуВизуализации);
				Если ЗначениеЗаполнено(Результат.ФайлСхематрона)
					И ЗначениеЗаполнено(Результат.ФайлСхемыВизуализации)
				Тогда
					ВсеФайлыНайдены = Истина;
				КонецЕсли;
				
				Если ЗначениеЗаполнено(Результат.ФайлСхематрона) Тогда
					ТекстСхематрона = Результат.ФайлСхематрона;
					ОбъектСправочника.Схематрон = ТекстСхематрона;
					Если ЗагружатьТолькоСхематроны Тогда
						ВсеФайлыНайдены = Истина;
					КонецЕсли;
				КонецЕсли;
				Если ЗначениеЗаполнено(Результат.ФайлСхемыВизуализации) Тогда
					ТекстСхемыВизуализации = Результат.ФайлСхемыВизуализации;
					ОбъектСправочника.СхемаВизуализации = ТекстСхемыВизуализации;
					Если ЗагружатьТолькоСхемуВизуализации Тогда
						ВсеФайлыНайдены = Истина;
					КонецЕсли;
				КонецЕсли;
				Исключение КонецПопытки;
		КонецЕсли;
		
		Если Не ВсеФайлыНайдены Тогда
			
			// Если отбор не установлен, то проверяем что уже загружено, чтобы повторно не загружать
			СохранитьТолькоСхематроны = ЗагружатьТолькоСхематроны;
			СохранитьТолькоСхемуВизуализации = ЗагружатьТолькоСхемуВизуализации;
			Если Не ЗагружатьТолькоСхематроны
				И Не ЗагружатьТолькоСхемуВизуализации
			Тогда 
				Если Не ЗначениеЗаполнено(ТекстСхематрона)
					И ЗначениеЗаполнено(ТекстСхемыВизуализации)
				Тогда
					СохранитьТолькоСхематроны = Истина;
				КонецЕсли;
				
				Если Не ЗначениеЗаполнено(ТекстСхемыВизуализации)
					И ЗначениеЗаполнено(ТекстСхематрона)
				Тогда
					СохранитьТолькоСхемуВизуализации = Истина;
				КонецЕсли;
			КонецЕсли;
			
			СтрокаСсылкиНаРуководство = ОбъектСправочника.Атрибуты.Найти("IMPLEMENTATION_GUIDE", "Ключ");
			
			Если СтрокаСсылкиНаРуководство <> Неопределено
				И ЗначениеЗаполнено(СтрокаСсылкиНаРуководство.Значение)
			Тогда
				Попытка
					// Заполнение текста схематрона происходит внутри процедуры без дальнейшей записи
					// Загружаем только схематрон
					СохранитьСхематронИСхемуВизуализации(ОбъектСправочника, СтрокаСсылкиНаРуководство.Значение, СохранитьТолькоСхематроны, СохранитьТолькоСхемуВизуализации);
				Исключение КонецПопытки;
			КонецЕсли;
		КонецЕсли;
		
		Если ОбъектСправочника.Модифицированность() Тогда
			ОбъектСправочника.Записать();
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция ПолучитьТекстСхематронаИСхемуВизуализацииИзРепозиторияИсходногоКода(СсылкаНаПроект, ЗагружатьТолькоСхематроны = Ложь, ЗагружатьТолькоСхемуВизуализации = Ложь) Экспорт
	
	АдресСервиса = АдресРепозиторияИсходногоКода();
	Токен = "&private_token=" + ПолучитьТокенРепозиторияИсходногоКода();
	НомерСтраницы = 1;
	
	// Находим элемент классификатора "Реестр руководств по реализации СЭМД и протоколов информационного взаимодействия" по OID
	Руководство = ПолучитьРуководствоПоСсылкеНаПроект(СсылкаНаПроект);
	
	Если ЗначениеЗаполнено(Руководство) Тогда
		СсылкаНаРепозиторий = Руководство.Атрибуты.Найти("GIT_LINK", "Ключ");
		Если Не ЗначениеЗаполнено(СсылкаНаРепозиторий) Тогда
			Возврат Неопределено;
		КонецЕсли;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	ГраницаВеткиРепозитория = СтрНайти(СсылкаНаРепозиторий.Значение, "/", НаправлениеПоиска.СКонца);
	ВеткаРепозитория = "?ref=" + Прав(СсылкаНаРепозиторий.Значение, СтрДлина(СсылкаНаРепозиторий.Значение) - ГраницаВеткиРепозитория);
	
	// Отсекаем номер версии от ссылки на проект
	ГраницаПутиКРепозиторию = СтрНайти(СсылкаНаПроект, ".", НаправлениеПоиска.СКонца);
	ПутьКРепозиторию = Лев(СсылкаНаПроект, ГраницаПутиКРепозиторию - 1);
	Адрес = "/api/v4/projects/semd%2F" + ПутьКРепозиторию + "/repository/tree" + ВеткаРепозитория + Токен + "&recursive=true&per_page=100&page=" + НомерСтраницы;
	Результат = ПолучитьСтруктуруРезультатаЗапросаИзРепозитория(АдресСервиса, Адрес);
	
	Если ТипЗнч(Результат) <> Тип("Массив") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПутиКФайлам = Новый Структура("ПутьКФайлуСхематрона, ПутьКФайлуСхемыВизуализации");
	ВсеФайлыНайдены = Ложь;
	// Среди всех файлов из репозитория ищем файл схематрона в том числе и в подпапках
	ПоискСхематронаИСхемыВизуализацииИзФайловРепозитория(ПутиКФайлам, ВсеФайлыНайдены, Результат, АдресСервиса, ПутьКРепозиторию, ВеткаРепозитория, Токен, ЗагружатьТолькоСхематроны, ЗагружатьТолькоСхемуВизуализации, НомерСтраницы);
	
	СодержимоеФайлов = Новый Структура("ФайлСхематрона, ФайлСхемыВизуализации");
	Если ЗначениеЗаполнено(ПутиКФайлам.ПутьКФайлуСхематрона) Тогда
		СодержимоеФайлов.ФайлСхематрона = ЗагрузитьФайлИзРепозитория(ПутиКФайлам.ПутьКФайлуСхематрона, ПутьКРепозиторию, ВеткаРепозитория, Токен, АдресСервиса);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПутиКФайлам.ПутьКФайлуСхемыВизуализации) Тогда
		СодержимоеФайлов.ФайлСхемыВизуализации = ЗагрузитьФайлИзРепозитория(ПутиКФайлам.ПутьКФайлуСхемыВизуализации, ПутьКРепозиторию, ВеткаРепозитория, Токен, АдресСервиса);
	КонецЕсли;
	
	Возврат СодержимоеФайлов;
	
КонецФункции

// Переопределяется расширениями конфигурации при необходимости индивидуального токена.
Функция ПолучитьТокенРепозиторияИсходногоКода()
	
	Возврат "glpat-siGcW9abPjxxDESwgrig";
	
КонецФункции

Функция ПолучитьРуководствоПоСсылкеНаПроект(ЗначениеДляПоиска)
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	КлассификаторыМинЗдрава.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.КлассификаторыМинЗдрава КАК КлассификаторыМинЗдрава
		|ГДЕ
		|	КлассификаторыМинЗдрава.ВидКлассификатора = &ВидКлассификатора
		|	И КлассификаторыМинЗдрава.OIDКлассификатораМинздрава = &OIDКлассификатораМинздрава
		|	И НЕ КлассификаторыМинЗдрава.ПометкаУдаления
		|	И НЕ КлассификаторыМинЗдрава.Архив";
	
	Запрос.УстановитьПараметр("ВидКлассификатора", Перечисления.ВидыКлассификаторовМинЗдрава.РеестрРуководствПоРеализацииСтруктурированныхЭлектронныхМедицинскихДокументов);
	Запрос.УстановитьПараметр("OIDКлассификатораМинздрава", ЗначениеДляПоиска);
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		Возврат Выборка.Ссылка;
	КонецЕсли;
	
КонецФункции

Функция ПолучитьСтруктуруРезультатаЗапросаИзРепозитория(АдресСервиса, Адрес)
	
	Соединение = Новый HTTPСоединение(АдресСервиса, 443,,,,, Новый ЗащищенноеСоединениеOpenSSL(),);
	Результат = Соединение.Получить(Новый HTTPЗапрос(Адрес));
	
	Возврат ОбщегоНазначенияПереопределяемый.ПрочитатьСтрокуJSON(Результат.ПолучитьТелоКакСтроку());
	
КонецФункции

Функция АдресРепозиторияИсходногоКода() Экспорт
	
	Возврат "git.minzdrav.gov.ru";
	
КонецФункции

Функция РекурсивныйПоискСхематронаИзФайловРепозитория(Результат, АдресСервиса, ПутьКРепозиторию, ВеткаРепозитория, Токен)
	
	ПутьКФайлуСхематрона = Неопределено;
	
	Для Каждого ФайлПроекта Из Результат Цикл
		Если ФайлПроекта.type = "blob"
			И СтрНайти(ФайлПроекта.name, ".sch")
		Тогда
			ПутьКФайлуСхематрона = ФайлПроекта.path;
			Прервать;
		КонецЕсли;
		
		Если ФайлПроекта.type = "tree" Тогда
			АдресГруппы = "/api/v4/projects/semd%2F" + ПутьКРепозиторию + "/repository/tree" + ВеткаРепозитория + "&path=" + ФайлПроекта.path + Токен;
			РезультатГруппы = ПолучитьСтруктуруРезультатаЗапросаИзРепозитория(АдресСервиса, АдресГруппы);
			ПутьКФайлуСхематрона = РекурсивныйПоискСхематронаИзФайловРепозитория(РезультатГруппы, АдресСервиса, ПутьКРепозиторию, ВеткаРепозитория, Токен);
			Если ПутьКФайлуСхематрона <> Неопределено Тогда
				Возврат ПутьКФайлуСхематрона;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если ПутьКФайлуСхематрона = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ПутьКФайлуСхематрона;
	
КонецФункции

Процедура ПоискСхематронаИСхемыВизуализацииИзФайловРепозитория(ПутиКФайлам, ВсеФайлыНайдены, Результат, АдресСервиса, ПутьКРепозиторию, ВеткаРепозитория, Токен, ЗагружатьТолькоСхематроны, ЗагружатьТолькоСхемуВизуализации, НомерСтраницы)
	
	// На случай если в репозитории больше 100 файлов
	ПродолжитьПоиск = Истина;
	
	Пока ПродолжитьПоиск Цикл
		Для Каждого ФайлПроекта Из Результат Цикл
			Если ФайлПроекта.type = "blob" Тогда
				Если Не ЗагружатьТолькоСхемуВизуализации
					И СтрЗаканчиваетсяНа(ФайлПроекта.name, ".sch")
				Тогда
					ПутиКФайлам.ПутьКФайлуСхематрона = ФайлПроекта.path;
					
					// Прерываем поиск если нашли все файлы, которые хотели найти
					Если ЗагружатьТолькоСхематроны
						Или ЗначениеЗаполнено(ПутиКФайлам.ПутьКФайлуСхемыВизуализации)
					Тогда
						ВсеФайлыНайдены = Истина;
						Возврат;
					КонецЕсли;
				ИначеЕсли Не ЗагружатьТолькоСхематроны
					И СтрЗаканчиваетсяНа(ФайлПроекта.name, ".xsl")
				Тогда
					ПутиКФайлам.ПутьКФайлуСхемыВизуализации = ФайлПроекта.path;
					
					// Прерываем поиск если нашли все файлы, которые хотели найти
					Если ЗагружатьТолькоСхемуВизуализации
						Или ЗначениеЗаполнено(ПутиКФайлам.ПутьКФайлуСхематрона)
					Тогда
						ВсеФайлыНайдены = Истина;
						Возврат;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		// Продолжаем поиск если количество файлов в результате максимальное
		Если Результат.Количество() < 100 Тогда
			ПродолжитьПоиск = Ложь;
		Иначе
			НомерСтраницы = НомерСтраницы + 1;
			Адрес = "/api/v4/projects/semd%2F" + ПутьКРепозиторию + "/repository/tree" + ВеткаРепозитория + Токен + "&recursive=true&per_page=100&page=" + НомерСтраницы;
			Результат = ПолучитьСтруктуруРезультатаЗапросаИзРепозитория(АдресСервиса, Адрес);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция ЗагрузитьФайлИзРепозитория(ПутьКФайлу, ПутьКРепозиторию, ВеткаРепозитория, Токен, АдресСервиса)
	
	// Добавляем процентные кодировки в имя файла для корректного обращения к API
	// Пробел кодируется как %20, а слэш — как %2F
	ПутьКФайлу = СтрЗаменить(СтрЗаменить(ПутьКФайлу, " ", "%20"), "/", "%2F");
	
	// Зная путь к файлу схематрона получаем содержимое. Переводим из base64
	Адрес = "/api/v4/projects/semd%2F" + ПутьКРепозиторию + "/repository/files/" + ПутьКФайлу + ВеткаРепозитория + Токен;
	Результат = ПолучитьСтруктуруРезультатаЗапросаИзРепозитория(АдресСервиса, Адрес);
	
	Если Не Результат.Свойство("content") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ПолучитьСтрокуИзДвоичныхДанных(Base64Значение(Результат.content));
	
КонецФункции

Процедура СохранитьСхематронИСхемуВизуализации(ОбъектСправочника, СсылкаНаРуководство, СохранитьТолькоСхематрон = Ложь, СохранитьТолькоСхемуВизуализации = Ложь) Экспорт
	
	ТекстСхематрона = Неопределено;
	ТекстСхемыВизуализации = Неопределено;
	
	СтруктураURI = ОбщегоНазначенияКлиентСервер.СтруктураURI(СсылкаНаРуководство);
	
	ЗащищенноеСоединение = Неопределено;
	Если НРег(СтруктураURI.Схема) = "https" Тогда
		ЗащищенноеСоединение = Новый ЗащищенноеСоединениеOpenSSL();
		Протокол = "HTTPS"
	Иначе
		Протокол = "HTTP"
	КонецЕсли;
	
	ИнтернетПрокси = ПолучениеФайловИзИнтернетаКлиентСервер.ПолучитьПрокси(Протокол);
	
	Соединение = Новый HTTPСоединение(СтруктураURI.ИмяСервера,,,,ИнтернетПрокси,, ЗащищенноеСоединение);
	Запрос = Новый HTTPЗапрос(СтруктураURI.ПутьНаСервере);
	
	Результат = Соединение.Получить(Запрос);
	ДокументHTML = РаботаСDOMКлиентСервер.СоздатьДокументDOM(Результат.ПолучитьТелоКакСтроку());
	
	СсылкаНаСхематрон = Неопределено;
	ЭлементыБлокаФайлов = РаботаСHTMLКлиентСервер.ПолучитьЭлементыПоЗначениюАтрибута(ДокументHTML, "files", , "class");
	
	Если ЭлементыБлокаФайлов.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ЭлементыСсылок = РаботаСDOMКлиентСервер.ПолучитьЭлементыПоИмени(ЭлементыБлокаФайлов[0], "a", Истина);
	
	ПутиКФайлам = Новый Структура("ПутьКФайлуСхематрона, ПутьКФайлуСхемыВизуализации");
	ВсеФайлыНайдены = Ложь;
	
	Для Каждого ЭлементСсылки Из ЭлементыСсылок Цикл
		Ссылка = ЭлементСсылки.ПолучитьАтрибут("href");
		Если Ссылка <> Неопределено Тогда
			Если Не СохранитьТолькоСхемуВизуализации 
				И СтрЗаканчиваетсяНа(НРег(Ссылка), ".sch")
			Тогда
				
				// Прерываем поиск если нашли все файлы, которые хотели найти
				ПутиКФайлам.ПутьКФайлуСхематрона = Ссылка;
				Если СохранитьТолькоСхематрон 
					Или ЗначениеЗаполнено(ПутиКФайлам.ПутьКФайлуСхемыВизуализации)
				Тогда
					ВсеФайлыНайдены = Истина;
					Прервать;
				КонецЕсли;
				
			ИначеЕсли Не СохранитьТолькоСхематрон
				И СтрЗаканчиваетсяНа(НРег(Ссылка), ".xsl")
			Тогда
				
				// Прерываем поиск если нашли все файлы, которые хотели найти
				ПутиКФайлам.ПутьКФайлуСхемыВизуализации = Ссылка;
				Если СохранитьТолькоСхемуВизуализации 
					Или ЗначениеЗаполнено(ПутиКФайлам.ПутьКФайлуСхематрона)
				Тогда
					ВсеФайлыНайдены = Истина;
					Прервать;
				КонецЕсли;
				
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	СодержимоеФайлов = Новый Структура("ТекстСхематрона, ТекстСхемыВизуализации");
	Если ЗначениеЗаполнено(ПутиКФайлам.ПутьКФайлуСхематрона) Тогда
		Запрос = Новый HTTPЗапрос(ПутиКФайлам.ПутьКФайлуСхематрона);
		Результат = Соединение.Получить(Запрос);
		ТекстСхематрона = Результат.ПолучитьТелоКакСтроку();
		СодержимоеФайлов.ТекстСхематрона = ТекстСхематрона;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПутиКФайлам.ПутьКФайлуСхемыВизуализации) Тогда
		Запрос = Новый HTTPЗапрос(ПутиКФайлам.ПутьКФайлуСхемыВизуализации);
		Результат = Соединение.Получить(Запрос);
		ТекстСхемыВизуализации = Результат.ПолучитьТелоКакСтроку();
		СодержимоеФайлов.ТекстСхемыВизуализации = ТекстСхемыВизуализации;
	КонецЕсли; 
	
	// Продолжим поиск внутри архивов
	Если Не ВсеФайлыНайдены Тогда
		
		// Нет отбора и если схема визуализации или схематрон уже загружены, то не ищем повторно
		Если Не СохранитьТолькоСхематрон
			И Не СохранитьТолькоСхемуВизуализации
		Тогда
			Если Не ЗначениеЗаполнено(ТекстСхематрона)
				И ЗначениеЗаполнено(ТекстСхемыВизуализации)
			Тогда
				СохранитьТолькоСхематрон = Истина;
			КонецЕсли;
			
			Если Не ЗначениеЗаполнено(ТекстСхемыВизуализации)
				И ЗначениеЗаполнено(ТекстСхематрона)
			Тогда
				СохранитьТолькоСхемуВизуализации = Истина;
			КонецЕсли;
		КонецЕсли;
		
		ПолучитьТекстСхематронаИСхемуВизуализацииИзАрхива(Соединение, ЭлементыСсылок, СодержимоеФайлов, СохранитьТолькоСхематрон, СохранитьТолькоСхемуВизуализации);
	КонецЕсли;
	
	ОбъектСправочника.Схематрон = СодержимоеФайлов.ТекстСхематрона;
	ОбъектСправочника.СхемаВизуализации = СодержимоеФайлов.ТекстСхемыВизуализации;
	
КонецПроцедуры

Процедура ПолучитьТекстСхематронаИСхемуВизуализацииИзАрхива(Соединение, ЭлементыСсылок, СодержимоеФайлов, СохранитьТолькоСхематрон, СохранитьТолькоСхемуВизуализации)
	
	ВсеФайлыНайдены = Ложь;
	
	// Ищем схематроны и схемы визуализации в архивах zip
	Для Каждого ЭлементСсылки Из ЭлементыСсылок Цикл
		
		СсылкаНаАрхив = ЭлементСсылки.ПолучитьАтрибут("href");
		
		Если СсылкаНаАрхив = Неопределено
			Или Не СтрЗаканчиваетсяНа(НРег(СсылкаНаАрхив), ".zip")
		Тогда
			Продолжить;
		КонецЕсли;
		
		Запрос = Новый HTTPЗапрос(СсылкаНаАрхив);
		Результат = Соединение.Получить(Запрос); 
		ДвоичныеДанные = Результат.ПолучитьТелоКакДвоичныеДанные();
		ЧтениеZipФайла = Новый ЧтениеZipФайла(ДвоичныеДанные.ОткрытьПотокДляЧтения());
		Для Каждого Элемент Из ЧтениеZipФайла.Элементы Цикл
			Если Элемент.Расширение = "sch" И Не СохранитьТолькоСхемуВизуализации
				Или Элемент.Расширение = "xsl" И Не СохранитьТолькоСхематрон
			Тогда
			
				ИмяВременногоКаталога = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(
					ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(КаталогВременныхФайлов()) + Строка(Новый УникальныйИдентификатор()));
				
				СоздатьКаталог(ИмяВременногоКаталога);
				ЧтениеZipФайла.Извлечь(Элемент, ИмяВременногоКаталога, РежимВосстановленияПутейФайловZIP.НеВосстанавливать);
				ПолныйПутьКИзвлеченномуФайлу = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(ИмяВременногоКаталога) + Элемент.Имя;
				
				Текст = Новый ЧтениеТекста;
				
				Текст.Открыть(ПолныйПутьКИзвлеченномуФайлу, КодировкаТекста.UTF8);
				Если Элемент.Расширение = "sch" Тогда
					СодержимоеФайлов.ТекстСхематрона = Текст.Прочитать();
					Если СохранитьТолькоСхематрон
						Или ЗначениеЗаполнено(СодержимоеФайлов.ТекстСхемыВизуализации)
					Тогда
						ВсеФайлыНайдены = Истина;
					КонецЕсли;
				ИначеЕсли Элемент.Расширение = "xsl" Тогда
					СодержимоеФайлов.ТекстСхемыВизуализации = Текст.Прочитать();
					Если СохранитьТолькоСхемуВизуализации 
						Или ЗначениеЗаполнено(СодержимоеФайлов.ТекстСхематрона)
					Тогда
						ВсеФайлыНайдены = Истина;
					КонецЕсли;
				КонецЕсли;
					
				Текст.Закрыть();
				Попытка
					УдалитьФайлы(ПолныйПутьКИзвлеченномуФайлу);
				Исключение КонецПопытки;
				
				Если ВсеФайлыНайдены Тогда
					Возврат;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти