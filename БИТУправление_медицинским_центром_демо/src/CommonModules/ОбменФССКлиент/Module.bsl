#Область ПрограммныйИнтерфейс

#Область ОперацииОбмена

Процедура ОбновитьЭЛН(Параметры) Экспорт
	
	НомерЭЛН = Формат(Параметры.Номер,"ЧГ=");
	НомерЭЛН = СтрЗаменить(НомерЭЛН, " ",""); 
	НомерЭЛН = СтрЗаменить(НомерЭЛН, Символы.НПП,"");
	СНИЛС = СтрЗаменить(Параметры.СНИЛС,"-","");
	СНИЛС = СтрЗаменить(СНИЛС," ","");
	
	ПараметрыЗапроса = Новый Структура;
	ПараметрыЗапроса.Вставить("lnCode", НомерЭЛН);
	ПараметрыЗапроса.Вставить("ogrn", Параметры.ОГРН);
	ПараметрыЗапроса.Вставить("snils", СНИЛС);
	ПараметрыЗапроса.Вставить("Метод", "GetLNDataRequest");
	ПараметрыЗапроса.Вставить("Документ", Параметры.Документ);
	ПараметрыЗапроса.Вставить("БлокДляПодписи",СформироватьДанныеПодписи(Формат(Параметры.ОГРН, "ЧГ=")));
	
	Сертификат = Неопределено;
	Если Параметры.Свойство("Сертификат") Тогда
		Сертификат = Параметры.Сертификат;	
	КонецЕсли;
	
	ОтправитьЗапрос(ПараметрыЗапроса, Параметры.ОбработчикРезультата, Сертификат);
			
КонецПроцедуры

Процедура ОтправитьЭЛН(Параметры) Экспорт 
	
	ПараметрыЗапроса = Новый Структура;
	ПараметрыЗапроса.Вставить("ogrn", Параметры.огрн);
	ПараметрыЗапроса.Вставить("Документ", Параметры.Документ);
	ПараметрыЗапроса.Вставить("Метод", "PrParseFilelnlpuRequest");
	
	Сертификат = Неопределено;
	Если Параметры.Свойство("Сертификат") Тогда
		Сертификат = Параметры.Сертификат;	
	КонецЕсли; 
			
	ОтправитьЗапрос(ПараметрыЗапроса, Параметры.ОбработчикРезультата, Сертификат);
	
КонецПроцедуры

Процедура АннулироватьЭЛН(Параметры, ТекстОшибки = "") Экспорт
	СНИЛС = СтрЗаменить(Параметры.СНИЛС,"-","");
	СНИЛС = СтрЗаменить(СНИЛС," ","");
	Номер = Формат(Параметры.Номер,"ЧГ=");
	Номер = СтрЗаменить(Номер, " ","");
	Номер = СтрЗаменить(Номер, Символы.НПП,"");
	
	ПараметрыЗапроса = Новый Структура;
	ПараметрыЗапроса.Вставить("snils", СНИЛС);
	ПараметрыЗапроса.Вставить("lnCode", Номер);
	ПараметрыЗапроса.Вставить("ogrn", Параметры.огрн);
	ПараметрыЗапроса.Вставить("reasonCode", Параметры.Причина);
	ПараметрыЗапроса.Вставить("reason", Параметры.Комментарий);
	ПараметрыЗапроса.Вставить("Документ", Параметры.Документ);
	ПараметрыЗапроса.Вставить("Метод", "DisableLnRequest");
	ПараметрыЗапроса.Вставить("БлокДляПодписи",СформироватьДанныеПодписи(Формат(Параметры.ОГРН, "ЧГ=")));
	
	Сертификат = Неопределено;
	Если Параметры.Свойство("Сертификат") Тогда
		Сертификат = Параметры.Сертификат;	
	КонецЕсли;

	ОтправитьЗапрос(ПараметрыЗапроса, Параметры.ОбработчикРезультата, Сертификат);
	
КонецПроцедуры

Процедура ВыполнитьНесколькоЗапросов(МассивПараметров, ОбработчикРезультата, СертификатМО = Неопределено) Экспорт
	
	МассивПараметровЗапроса = Новый Массив;
	Для Каждого ЭлементПараметра Из МассивПараметров Цикл
		ПараметрыЗапроса = Новый Структура;
		ПараметрыЗапроса.Вставить("ogrn", ЭлементПараметра.огрн);
		ПараметрыЗапроса.Вставить("Документ", ЭлементПараметра.Документ);
		НомерЭЛН = Формат(ЭлементПараметра.Номер,"ЧГ=");
		НомерЭЛН = СтрЗаменить(НомерЭЛН, " ","");
		НомерЭЛН = СтрЗаменить(НомерЭЛН, Символы.НПП,"");
		СНИЛС = СтрЗаменить(ЭлементПараметра.СНИЛС,"-","");
		СНИЛС = СтрЗаменить(СНИЛС," ","");
		Если ЭлементПараметра.Операция = 1 Тогда
			ПараметрыЗапроса.Вставить("Метод", "PrParseFilelnlpuRequest");	
		ИначеЕсли ЭлементПараметра.Операция = 2 Тогда 
			ПараметрыЗапроса.Вставить("Метод", "GetLNDataRequest");	
			ПараметрыЗапроса.Вставить("БлокДляПодписи",СформироватьДанныеПодписи(Формат(ЭлементПараметра.ОГРН, "ЧГ=")));
			ПараметрыЗапроса.Вставить("lnCode", НомерЭЛН);
			ПараметрыЗапроса.Вставить("snils", СНИЛС);
		ИначеЕсли ЭлементПараметра.Операция = 3 Тогда 
			ПараметрыЗапроса.Вставить("Метод", "DisableLnRequest");
			ПараметрыЗапроса.Вставить("БлокДляПодписи",СформироватьДанныеПодписи(Формат(ЭлементПараметра.ОГРН, "ЧГ=")));
			ПараметрыЗапроса.Вставить("lnCode", НомерЭЛН);
			ПараметрыЗапроса.Вставить("snils", СНИЛС);
			ПараметрыЗапроса.Вставить("reasonCode", ЭлементПараметра.Причина);
			ПараметрыЗапроса.Вставить("reason", ЭлементПараметра.Комментарий);
		КонецЕсли; 	
		МассивПараметровЗапроса.Добавить(ПараметрыЗапроса);
	КонецЦикла; 
	
	Если МассивПараметровЗапроса.Количество() > 0 Тогда
		ОтправитьЗапрос(МассивПараметровЗапроса, ОбработчикРезультата, СертификатМО);
	КонецЕсли; 
	
КонецПроцедуры

Процедура ПолучитьСписокНомеров(Параметры) Экспорт
	
	ПараметрыЗапроса = Новый Структура;
	ПараметрыЗапроса.Вставить("cntLnNumbers", Параметры.Количество);
	ПараметрыЗапроса.Вставить("ogrn", Формат(Параметры.ОГРН, "ЧГ="));
	ПараметрыЗапроса.Вставить("Метод", "GetNewLNNumRangeRequest");
	ПараметрыЗапроса.Вставить("БлокДляПодписи",СформироватьДанныеПодписи(Формат(Параметры.ОГРН, "ЧГ=")));
		
	ОтправитьЗапрос(ПараметрыЗапроса, Параметры.ОбработчикРезультата);
			
КонецПроцедуры

Функция СписокЭЛН(Параметры) Экспорт
	
	СНИЛС = СтрЗаменить(Параметры.СНИЛС,"-","");
	СНИЛС = СтрЗаменить(СНИЛС," ","");
	
	ПараметрыЗапроса = Новый Структура;
	ПараметрыЗапроса.Вставить("ogrn", Параметры.огрн);
	ПараметрыЗапроса.Вставить("snils", СНИЛС);
	ПараметрыЗапроса.Вставить("Метод", "GetLNListBySnilsRequest");
	ПараметрыЗапроса.Вставить("БлокДляПодписи",СформироватьДанныеПодписи(Формат(Параметры.ОГРН, "ЧГ=")));
		
	ОтправитьЗапрос(ПараметрыЗапроса, Параметры.ОбработчикРезультата);
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

Процедура ОтправитьЗапрос(ПараметрыЗапроса, ОбработчикРезультата, СертификатМО = Неопределено) Экспорт
	
	ОписаниеДанных = Новый Структура;
	ОписаниеДанных.Вставить("ЗаголовокДанных", НСтр("ru = 'Данные'"));
	
	ТекстОшибки = "";
	Если ТипЗнч(ПараметрыЗапроса) = Тип("Массив") Тогда
		НаборДанных = Новый Массив;
		Для каждого ЭлементПараметрыЗапроса Из ПараметрыЗапроса Цикл
			Данные = ОбменФСС.СформироватьДанныеДляПодписания(ЭлементПараметрыЗапроса, ТекстОшибки);
			НаборДанных.Добавить(Новый Структура("Данные",Данные));	
		КонецЦикла; 	
		ОписаниеДанных.Вставить("НаборДанных",НаборДанных);
		ОписаниеДанных.Вставить("ПредставлениеНабора","Данные (" + Строка(НаборДанных.Количество()) + ")");	
	Иначе
		Данные = ОбменФСС.СформироватьДанныеДляПодписания(ПараметрыЗапроса, ТекстОшибки);
		ОписаниеДанных.Вставить("Данные",Данные);
	КонецЕсли; 
	
	Если Данные = Неопределено Тогда
		ПараметрыРезультата = Новый Структура;
		ПараметрыРезультата.Вставить("ТекстОшибки",ТекстОшибки);
		ПараметрыРезультата.Вставить("Успех",Ложь);
		ВыполнитьОбработкуОповещения(ОбработчикРезультата, ПараметрыРезультата);
		Возврат;
	КонецЕсли; 
	
	ОписаниеДанных.Вставить("ПоказатьКомментарий", Ложь);
	ОписаниеДанных.Вставить("Операция","Подписание");
	ОписаниеДанных.Вставить("БезПодтверждения", ЗначениеЗаполнено(СертификатМО));
	Если ЗначениеЗаполнено(СертификатМО) Тогда
		Массив = Новый Массив;
		Массив.Добавить(СертификатМО);
		ОписаниеДанных.Вставить("ОтборСертификатов", Массив);	
	Иначе
		Филиал = УправлениеНастройками.ПолучитьФилиалПоУмолчаниюПользователя();
		ОписаниеДанных.Вставить("ОтборСертификатов",ОбменФСС.ПолучитьСертификатыМО(Филиал));
	КонецЕсли; 
	ПараметрыОбработчика = Новый Структура;
	ПараметрыОбработчика.Вставить("ПараметрыЗапроса",ПараметрыЗапроса);
	ПараметрыОбработчика.Вставить("ОбработчикРезультата",ОбработчикРезультата);
	ОбработчикЗавершения = Новый ОписаниеОповещения("ПодписатьДокументЗавершение", ОбменФССКлиент, ПараметрыОбработчика);
	ЭлектроннаяПодписьКлиент.Подписать(ОписаниеДанных,,ОбработчикЗавершения);
	
КонецПроцедуры

Процедура ПодписатьДокументЗавершение(Результат, Параметры) Экспорт
		
	Если Результат.Успех Тогда
		
        ТекстОшибки = "";
		Параметры.Вставить("Результат", Результат);
		РабочийРежим = УправлениеНастройкамиМедицинскогоУчета.ПолучитьПараметрУчетнойПолитики("РабочийРежимОбменаСФСС");
		Если РабочийРежим Тогда
			СертификатХранилище = УправлениеНастройкамиМедицинскогоУчета.ПолучитьПараметрУчетнойПолитики("СертификатФССРабочий");
		Иначе
			СертификатХранилище = УправлениеНастройкамиМедицинскогоУчета.ПолучитьПараметрУчетнойПолитики("СертификатФССТестовый");		
		КонецЕсли;
		Сертификат = ОбменФСС.ПолучитьЗначениеХранилищаЗначений(СертификатХранилище);
		Параметры.Вставить("Сертификат", Сертификат);
		
		Если ТипЗнч(Параметры.ПараметрыЗапроса) = Тип("Массив") Тогда
			Параметры.Вставить("РезультатОбмена", Ложь);
			Параметры.Вставить("Счетчик", -1);
			Параметры.Вставить("ТекстОшибки", "");
		КонецЕсли;
			Оповещение = Новый ОписаниеОповещения("ПередШифрованиемXMLФСС", ОбменФССКлиент, Параметры);
			ВыполнитьОбработкуОповещения(Оповещение);		
	КонецЕсли;
	
КонецПроцедуры
 
#КонецОбласти

#Область ШифрованиеДанныхИОбмен

Процедура ПередШифрованиемXMLФСС(Результат, ДопПараметры) Экспорт
	
	Если ТипЗнч(ДопПараметры.ПараметрыЗапроса) = Тип("Массив") Тогда
		ДопПараметры.Счетчик = ДопПараметры.Счетчик + 1;
		Сч = ДопПараметры.Счетчик;
		Если Сч < ДопПараметры.ПараметрыЗапроса.Количество() Тогда
			
			Если ТипЗнч(ДопПараметры.Результат.НаборДанных[Сч].СвойстваПодписи) = Тип("Строка") Тогда
			Попытка
				ДопПараметры.Результат.НаборДанных[Сч].СвойстваПодписи = ПолучитьИзВременногоХранилища(ДопПараметры.Результат.НаборДанных[Сч].СвойстваПодписи);
			Исключение
				ОбработатьОшибку("Не удалось подписать!", ДопПараметры);
				Возврат;
			КонецПопытки;
			ИначеЕсли ТипЗнч(ДопПараметры.Результат.НаборДанных[Сч].СвойстваПодписи) <> Тип("Структура") Тогда
				ОбработатьОшибку("Не удалось подписать!", ДопПараметры);
				Возврат;
			КонецЕсли;
			
			Сообщение = ДопПараметры.Результат.НаборДанных[Сч].СвойстваПодписи.Подпись;
			СертификатОтправителяBase64 = ПолучитьBase64СтрокуИзДвоичныхДанных(ДопПараметры.Результат.НаборДанных[Сч].СвойстваПодписи.Сертификат);
		Иначе
			ДополнительныеПараметры = Новый Структура("Успех, ТекстОшибки", ДопПараметры.РезультатОбмена, ДопПараметры.ТекстОшибки);	
			ВыполнитьОбработкуОповещения(ДопПараметры.ОбработчикРезультата, ДополнительныеПараметры);
			Возврат;
		КонецЕсли;
	Иначе
		Если Не ДопПараметры.Результат.Свойство("СвойстваПодписи") Тогда
			Возврат;
		КонецЕсли;
		
		Если ТипЗнч(ДопПараметры.Результат.СвойстваПодписи) = Тип("Строка") Тогда
			Попытка
				 ДопПараметры.Результат.СвойстваПодписи = ПолучитьИзВременногоХранилища(ДопПараметры.Результат.СвойстваПодписи);
			Исключение
				ОбработатьОшибку("Не удалось подписать!", ДопПараметры);
				Возврат;
			КонецПопытки;
		ИначеЕсли ТипЗнч(ДопПараметры.Результат.СвойстваПодписи) <> Тип("Структура") Тогда
			ОбработатьОшибку("Не удалось подписать!", ДопПараметры);
			Возврат;
		КонецЕсли;
		Сообщение = ДопПараметры.Результат.СвойстваПодписи.Подпись;
		СертификатОтправителяBase64 = ПолучитьBase64СтрокуИзДвоичныхДанных(ДопПараметры.Результат.СвойстваПодписи.Сертификат);
	КонецЕсли;
	ДополнительныеПараметры = Новый Структура();
	ДополнительныеПараметры.Вставить("ПараметрыЗапроса", ДопПараметры);
	Сообщение = СтрЗаменить(Сообщение, "SignedTempInfo", "SignedInfo"); 
	//СертификатОтправителяBase64 = ПолучитьBase64СтрокуИзДвоичныхДанных(Результат.СвойстваПодписи.Сертификат);
	Сообщение = СтрЗаменить(Сообщение, ">%X509Certificate%", " xmlns=""http://www.w3.org/2000/09/xmldsig#"">" + СертификатОтправителяBase64); 
	ДополнительныеПараметры.Вставить("Сообщение", Сообщение);
	ШифрованиеXMLФСС(ДопПараметры.Сертификат, ДополнительныеПараметры);
	
КонецПроцедуры

Процедура ШифрованиеXMLФСС(Сертификат, ДопПараметры) Экспорт
	
	ДопПараметры.Сообщение = СтрЗаменить(ДопПараметры.Сообщение, "<Object>", "<d3p1:Object>");
	ДопПараметры.Сообщение = СтрЗаменить(ДопПараметры.Сообщение, "</Object>", "</d3p1:Object>");

	//ДанныеСертификата = ОбщегоНазначения.ПолучитьЗначенияРеквизитов(Сертификат, "ДанныеСертификата").ДанныеСертификата;
	Попытка
		ДанныеСертификата = Новый СертификатКриптографии(Сертификат); 
		СертификатПолучателя = Новый Структура;
		СертификатПолучателя.Вставить("СерийныйНомер", Строка(ДанныеСертификата.СерийныйНомер));
		СертификатПолучателя.Вставить("Отпечаток", СтрЗаменить(Строка(ДанныеСертификата.Отпечаток)," ", ""));
		ДанныеПоставщикаСертификата = ПолучитьДанныеПоставщикаСертификата(ДанныеСертификата.Издатель);
		СертификатПолучателя.Вставить("Поставщик", ДанныеПоставщикаСертификата);	
	Исключение
		ОбработатьОшибку("Неверный формат сертификата ФСС", ДопПараметры.ПараметрыЗапроса);
		Возврат;	
	КонецПопытки;
	
	СертификатПолучателяBase64 = ПолучитьBase64СтрокуИзДвоичныхДанных(Сертификат);
	
	ФайлДанных = ПолучитьИмяВременногоФайла(".bin");
	ДвоичныеДанныеСообщение = ПолучитьДвоичныеДанныеИзСтроки(ДопПараметры.Сообщение);
	ДвоичныеДанныеСообщение.Записать(ФайлДанных);
	
	ДополнительныеПараметры = Новый Структура;
	ДополнительныеПараметры.Вставить("СертификатПолучателяBase64", СертификатПолучателяBase64);
	ДополнительныеПараметры.Вставить("ПараметрыЗапроса", ДопПараметры.ПараметрыЗапроса);
	
	Оповещение = Новый ОписаниеОповещения("ОтправитьПослеШифрования", ОбменФССКлиент, ДополнительныеПараметры);
	
	Каталог = КаталогВременныхФайлов() + СтрЗаменить(Строка(Новый УникальныйИдентификатор) + ПолучитьРазделительПути(), "-", "");
	СоздатьКаталог(Каталог);
	
	ПараметрыКриптографии = Новый Структура("АлгоритмШифрования, АлгоритмКлюча, Режим", 0, 26142, 1);
	
	ШифрованиеФССКлиент.Зашифровать(
		Оповещение, "",
		ФайлДанных,
		СертификатПолучателя,
		ПараметрыКриптографии,
		Каталог);

КонецПроцедуры
                                                          
Процедура ОтправитьПослеШифрования(Результат, ДопПараметры) Экспорт

	Если Результат.Выполнено Тогда 
		ЗашифрованноеСообщение = ПолучитьBase64СтрокуИзДвоичныхДанных(Новый ДвоичныеДанные(Результат.КаталогРезультата + "_encrypt.bin"));
		СеансовыйКлюч = ПолучитьBase64СтрокуИзДвоичныхДанных(Новый ДвоичныеДанные(Результат.КаталогРезультата + "_skey.bin"));
		ПубличныйКлюч = ПолучитьBase64СтрокуИзДвоичныхДанных(Новый ДвоичныеДанные(Результат.КаталогРезультата + "_pubkey.bin"));
		ИнициализационныйВектор = ПолучитьBase64СтрокуИзДвоичныхДанных(Новый ДвоичныеДанные(Результат.КаталогРезультата + "_iv.bin"));
		ПубличныйКлюч = СтрЗаменить(ПубличныйКлюч, Символ(13) + Символ(10), "");
		СеансовыйКлюч = СтрЗаменить(СеансовыйКлюч, Символ(13) + Символ(10), "");
		ЗашифрованноеСообщение = СтрЗаменить(ЗашифрованноеСообщение, Символ(13) + Символ(10), "");
		
		ИнициализационныйВектор = СтрЗаменить(ИнициализационныйВектор, Символ(13) + Символ(10), "");
		ДанныеДляXML = ПолучитьДанныеДляЗашифрованногоXML(СеансовыйКлюч, ПубличныйКлюч, ИнициализационныйВектор, ЗашифрованноеСообщение, "GOST R 34.10-2012-256");  
		
		ШаблонШифрованный = ПолучитьШаблонШифрованный();
		ШаблонШифрованный = СтрЗаменить(ШаблонШифрованный, "%X509Cert%", СтрЗаменить(ДопПараметры.СертификатПолучателяBase64, Символы.ВК, ""));
		ШаблонШифрованный = СтрЗаменить(ШаблонШифрованный, "%KeyCipherValue%",СтрЗаменить(ДанныеДляXML.СимметричныйКлючДляXMLВBase64, Символы.ВК, ""));
		ШаблонШифрованный = СтрЗаменить(ШаблонШифрованный, "%DataCipherValue%", СтрЗаменить(ДанныеДляXML.ЗашифрованныеДанныеДляXMLВBase64, Символы.ВК, ""));
		
		РезультатОбмена = ОбменФСС.ОтправитьИОбработатьЗапрос(ШаблонШифрованный, "1");
		
		// При ошибке связи с сервисом ФСС рабочего контура - пробуем повторить на резервном адресе
		Если РезультатОбмена.Свойство("ТекстОшибки") 
			И Найти(РезультатОбмена.ТекстОшибки, "Couldn't resolve host name") > 0
			И УправлениеНастройкамиМедицинскогоУчета.ПолучитьПараметрУчетнойПолитики("РабочийРежимОбменаСФСС")
		Тогда
			РезультатОбмена = ОбменФСС.ОтправитьИОбработатьЗапрос(ШаблонШифрованный, "1", Истина);
		КонецЕсли;
		
		// Отработка ошибки обмена
		Если РезультатОбмена.Свойство("ТекстОшибки") Тогда
			ОбработатьОшибку(РезультатОбмена.ТекстОшибки, ДопПараметры.ПараметрыЗапроса);
			Возврат;	
		КонецЕсли;
		
		РазобранныеДанные = РазобратьДанныеИзЗашифрованногоXML(РезультатОбмена.СимметричныйКлючВBase64, РезультатОбмена.ЗашифрованныеДанныеBase64);
		
		ФайлДанных = ПолучитьИмяВременногоФайла(".bin");
		ДвоичныеДанныеСообщение = ПолучитьДвоичныеДанныеИзBase64Строки(РазобранныеДанные.ЗашифрованныеДанныеВBase64);
		ДвоичныеДанныеСообщение.Записать(ФайлДанных);
		
		ФайлПубличныйКлюч = ПолучитьИмяВременногоФайла(".bin");
		ДвоичныеДанныеСообщение = ПолучитьДвоичныеДанныеИзBase64Строки(РазобранныеДанные.ПубличныйКлючВBase64);
		ДвоичныеДанныеСообщение.Записать(ФайлПубличныйКлюч);
		
		ФайлСимметричныйКлюч = ПолучитьИмяВременногоФайла(".bin");
		ДвоичныеДанныеСообщение = ПолучитьДвоичныеДанныеИзBase64Строки(РазобранныеДанные.СимметричныйКлючВBase64);
		ДвоичныеДанныеСообщение.Записать(ФайлСимметричныйКлюч); 
		
		ФайлИнициализационныйВектор = ПолучитьИмяВременногоФайла(".bin");
		ДвоичныеДанныеСообщение = ПолучитьДвоичныеДанныеИзBase64Строки(РазобранныеДанные.ИнициализационныйВекторВBase64);
		ДвоичныеДанныеСообщение.Записать(ФайлИнициализационныйВектор);
		
		ФайлРезультата = ПолучитьИмяВременногоФайла(".xml");
		
		ДополнительныеПараметры = Новый Структура("ПараметрыЗапроса", ДопПараметры.ПараметрыЗапроса); 
		
		Оповещение = Новый ОписаниеОповещения("ПослеРасшифровки", ОбменФССКлиент, ДополнительныеПараметры);
		
		ДанныеСертификата = Новый СертификатКриптографии(ПолучитьДвоичныеДанныеИзBase64Строки(РезультатОбмена.СертификатШифрованияВBase64)); 
		СертификатПолучателя = Новый Структура;
		СертификатПолучателя.Вставить("СерийныйНомер", Строка(ДанныеСертификата.СерийныйНомер));
		СертификатПолучателя.Вставить("Отпечаток", СтрЗаменить(Строка(ДанныеСертификата.Отпечаток)," ", ""));
		ДанныеПоставщикаСертификата = ПолучитьДанныеПоставщикаСертификата(ДанныеСертификата.Издатель);
		СертификатПолучателя.Вставить("Поставщик", ДанныеПоставщикаСертификата);
		
		ШифрованиеФССКлиент.РасшифроватьФайл( Оповещение, 
		СертификатПолучателя, 
		ФайлДанных,
		ФайлПубличныйКлюч,
		ФайлСимметричныйКлюч,
		ФайлИнициализационныйВектор,
		ФайлРезультата,,,
		ПолучитьАлгоритмШифрования());
	Иначе 
		ОбработатьОшибку(Результат.ОписаниеОшибки, ДопПараметры.ПараметрыЗапроса);
	КонецЕсли;
								
КонецПроцедуры
    
Функция ПослеРасшифровки(Результат, Параметры) Экспорт
	
	Если Результат.Выполнено Тогда
		ТекстОшибки = "";
		ЧтениеТекста = Новый ЧтениеТекста;
		ЧтениеТекста.Открыть(Результат.РасшифрованныйФайл, КодировкаТекста.UTF8);
		ТекстЗапроса = ЧтениеТекста.Прочитать();

		ТекстЗапроса = Лев(ТекстЗапроса, СтрНайти(ТекстЗапроса, "</soap:Envelope>") + 15);
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, Символы.ПС, "");
		ПараметрыЗапроса = Параметры.ПараметрыЗапроса;
		Если ТипЗнч(ПараметрыЗапроса.ПараметрыЗапроса) = Тип("Массив") Тогда
			Счетчик = ПараметрыЗапроса.Счетчик;
			ПараметрыЗапроса.РезультатОбмена = ОбменФСС.ОбработатьРасшифрованныйXML(ТекстЗапроса, ПараметрыЗапроса.ПараметрыЗапроса[Счетчик] , ТекстОшибки);
			Оповещение = Новый ОписаниеОповещения("ПередШифрованиемXMLФСС", ОбменФССКлиент, ПараметрыЗапроса);
			ВыполнитьОбработкуОповещения(Оповещение);
		Иначе
			РезультатОбмена = ОбменФСС.ОбработатьРасшифрованныйXML(ТекстЗапроса, ПараметрыЗапроса.ПараметрыЗапроса , ТекстОшибки);
			ПараметрыРезультата = Новый Структура;
			ПараметрыРезультата.Вставить("Успех",РезультатОбмена);	
			ПараметрыРезультата.Вставить("ТекстОшибки",ТекстОшибки);
			ВыполнитьОбработкуОповещения(ПараметрыЗапроса.ОбработчикРезультата, ПараметрыРезультата);
		КонецЕсли;
	Иначе
		ОбработатьОшибку(Результат.ОписаниеОшибки, Параметры.ПараметрыЗапроса);
	КонецЕсли;

КонецФункции  

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция СформироватьДанныеПодписи(ОГРН)
	
	НовыйБлокПодписи = Новый Структура;
	НовыйБлокПодписи.Вставить("Блок", "Тело");
	НовыйБлокПодписи.Вставить("wsu_id","OGRN_" + ОГРН);
	НовыйБлокПодписи.Вставить("soap_actor","http://eln.fss.ru/actor/mo/" + ОГРН);
	
	Возврат НовыйБлокПодписи;
	
КонецФункции

Функция ПолучитьШаблонШифрованный()

	ШаблонШифрованный = "<soapenv:Envelope
	|		xmlns:soapenv=""http://schemas.xmlsoap.org/soap/envelope/""
	|		xmlns:wsse=""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd""
	|		xmlns:wsu=""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd""
	|		xmlns:ds=""http://www.w3.org/2000/09/xmldsig#"">
	|	<soapenv:Body>
	|		<xenc:EncryptedData xmlns:xenc=""http://www.w3.org/2001/04/xmlenc#""
	|			Type=""http://www.w3.org/2001/04/xmlenc#Content"" xmlns:ds=""http://www.w3.org/2000/09/xmldsig#""
	|			xmlns:sch=""http://gost34.ibs.ru/WrapperService/Schema""
	|			xmlns:wsse=""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd""
	|			xmlns:wsu=""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"">
	|			<xenc:EncryptionMethod
	|				Algorithm=""urn:ietf:params:xml:ns:cpxmlsec:algorithms:gost28147"" />
	|			<ds:KeyInfo>
	|				<xenc:EncryptedKey xmlns:xenc=""http://www.w3.org/2001/04/xmlenc#"">
	|					<xenc:EncryptionMethod
	|				Algorithm=""urn:ietf:params:xml:ns:cpxmlsec:algorithms:transport-gost2001"" />
	|					<ds:KeyInfo>
	|						<ds:X509Data>
	|							<ds:X509Certificate>%X509Cert%</ds:X509Certificate>
	|						</ds:X509Data>
	|					<xenc:CipherData>
	|						<xenc:CipherValue>%KeyCipherValue%</xenc:CipherValue>
	|					</xenc:CipherData>
	|					</ds:KeyInfo>
	|				</xenc:EncryptedKey>
	|			</ds:KeyInfo>
	|			<xenc:CipherData>
	|				<xenc:CipherValue>%DataCipherValue%</xenc:CipherValue>
	|			</xenc:CipherData>
	|		</xenc:EncryptedData>
	|	</soapenv:Body>
	|</soapenv:Envelope>";

	Возврат ШаблонШифрованный;
	
КонецФункции

Процедура ОбработатьОшибку(ТекстОшибки, ДопПараметры)
	Если ТипЗнч(ДопПараметры.ПараметрыЗапроса) = Тип("Массив") Тогда
		Оповещение = Новый ОписаниеОповещения("ПередШифрованиемXMLФСС", ОбменФССКлиент, ДопПараметры);
		ДопПараметры.ТекстОшибки = ТекстОшибки; 
		ВыполнитьОбработкуОповещения(Оповещение);
	Иначе
		ПараметрыРезультата = Новый Структура;
		ПараметрыРезультата.Вставить("Успех", Ложь);	
		ПараметрыРезультата.Вставить("ТекстОшибки", ТекстОшибки);
		ВыполнитьОбработкуОповещения(ДопПараметры.ОбработчикРезультата, ПараметрыРезультата);
	КонецЕсли;
		
КонецПроцедуры

Функция ПолучитьДанныеДляЗашифрованногоXML(
		Знач СимметричныйКлючВBase64,
		Знач ПубличныйКлючВBase64,
		Знач ИнициализационныйВекторВBase64 = Неопределено,
		Знач ЗашифрованныеДанныеВBase64,
		Знач Алгоритм = Неопределено)
	
	// формирование симметричного ключа для вставки в XML
	
	ВременныйФайлСимметричногоКлюча = ПолучитьИмяВременногоФайла();
	Если ЭтоАдресВременногоХранилища(СимметричныйКлючВBase64) Тогда
		ДвоичныеДанныеСимметричногоКлюча = ПолучитьИзВременногоХранилища(СимметричныйКлючВBase64);
	Иначе
		ДвоичныеДанныеСимметричногоКлюча = Base64Значение(СимметричныйКлючВBase64);
	КонецЕсли;
	ДвоичныеДанныеСимметричногоКлюча.Записать(ВременныйФайлСимметричногоКлюча);
	МассивСимметричногоКлюча = ПрочитатьФайлВМассив(ВременныйФайлСимметричногоКлюча);
	УдалитьВременныйФайл(ВременныйФайлСимметричногоКлюча);
	Если МассивСимметричногоКлюча.Количество() < 60 Тогда
		ОбщегоНазначения.СообщитьПользователю(НСтр("ru = 'Неверный формат данных при шифрации'"));
		Возврат Неопределено;
	КонецЕсли;
	
	ВременныйФайлПубличногоКлюча = ПолучитьИмяВременногоФайла();
	Если ЭтоАдресВременногоХранилища(ПубличныйКлючВBase64) Тогда
		ДвоичныеДанныеПубличногоКлюча = ПолучитьИзВременногоХранилища(ПубличныйКлючВBase64);
	Иначе
		ДвоичныеДанныеПубличногоКлюча = Base64Значение(ПубличныйКлючВBase64);
	КонецЕсли;
	ДвоичныеДанныеПубличногоКлюча.Записать(ВременныйФайлПубличногоКлюча);
	МассивПубличногоКлюча = ПрочитатьФайлВМассив(ВременныйФайлПубличногоКлюча);
	УдалитьВременныйФайл(ВременныйФайлПубличногоКлюча);
	Если МассивСимметричногоКлюча.Количество() < 64 Тогда
		ОбщегоНазначения.СообщитьПользователю(НСтр("ru = 'Неверный формат данных при шифрации'"));
		Возврат Неопределено;
	КонецЕсли;
	
	// заголовок симметричного ключа для XML
	Если Алгоритм = "GOST R 34.10-2012-256" Тогда
		МассивСимметричногоКлючаДляXML = ПолучитьМассивБайтовИзСтрокиВШестнадцатеричномПредставлении("30 81 A9 30 28 04 20");
	ИначеЕсли Алгоритм = "GOST R 34.10-2012-512" Тогда
		МассивСимметричногоКлючаДляXML = ПолучитьМассивБайтовИзСтрокиВШестнадцатеричномПредставлении("30 81 EF 30 28 04 20");
	Иначе
		МассивСимметричногоКлючаДляXML = ПолучитьМассивБайтовИзСтрокиВШестнадцатеричномПредставлении("30 81 A4 30 28 04 20");
	КонецЕсли;
	
	// добавление симметричного ключа
	Для ИндексМассива = 24 По 55 Цикл
		МассивСимметричногоКлючаДляXML.Добавить(МассивСимметричногоКлюча[ИндексМассива]);
	КонецЦикла;
	
	МассивСимметричногоКлючаДляXML.Добавить(4);
	МассивСимметричногоКлючаДляXML.Добавить(4);
	
	// добавление имитовставки
	Для ИндексМассива = 56 По 59 Цикл
		МассивСимметричногоКлючаДляXML.Добавить(МассивСимметричногоКлюча[ИндексМассива]);
	КонецЦикла;
	
	Если Алгоритм = "GOST R 34.10-2012-256" Тогда
		МассивИнформацииОбАлгоритмах = ПолучитьМассивБайтовИзСтрокиВШестнадцатеричномПредставлении(
			"A0 7D 06 09 2A 85 03 07 01 02 05 01 01 A0 66 30 1F 06 08 2A 85 03 07 01 01 01 01 30 13 06 07 2A 85 03 02 02 24 00 06 08 2A 85 03 07 01 01 02 02 03 43 00 04 40");
	ИначеЕсли Алгоритм = "GOST R 34.10-2012-512" Тогда
		МассивИнформацииОбАлгоритмах = ПолучитьМассивБайтовИзСтрокиВШестнадцатеричномПредставлении(
			"A0 81 C2 06 09 2A 85 03 07 01 02 05 01 01 A0 81 AA 30 21 06 08 2A 85 03 07 01 01 01 02 30 15 06 09 2A 85 03 07 01 02 01 02 01 06 08 2A 85 03 07 01 01 02 03 03 81 84 00 04");
	Иначе
		МассивИнформацииОбАлгоритмах = ПолучитьМассивБайтовИзСтрокиВШестнадцатеричномПредставлении(
			"A0 78 06 07 2A 85 03 02 02 1F 01 A0 63 30 1C 06 06 2A 85 03 02 02 13 30 12 06 07 2A 85 03 02 02 24 00 06 07 2A 85 03 02 02 1E 01 03 43 00 04 40");
	КонецЕсли;
	Для каждого ЭлементМассива Из МассивИнформацииОбАлгоритмах Цикл
		МассивСимметричногоКлючаДляXML.Добавить(ЭлементМассива);
	КонецЦикла;
	
	// добавление публичного эфемерного ключа отправителя
	ИндексНачалаДанныхПубличногоКлюча = МассивПубличногоКлюча.Количество() - ?(Алгоритм = "GOST R 34.10-2012-512", 128, 64);
	ИндексКонцаДанныхПубличногоКлюча = МассивПубличногоКлюча.Количество() - 1;
	Для ИндексМассива = ИндексНачалаДанныхПубличногоКлюча По ИндексКонцаДанныхПубличногоКлюча Цикл
		МассивСимметричногоКлючаДляXML.Добавить(МассивПубличногоКлюча[ИндексМассива]);
	КонецЦикла;
	
	МассивСимметричногоКлючаДляXML.Добавить(4);
	МассивСимметричногоКлючаДляXML.Добавить(8);
	
	// добавление инициализационного вектора симметричного ключа
	Для ИндексМассива = 16 По 23 Цикл
		МассивСимметричногоКлючаДляXML.Добавить(МассивСимметричногоКлюча[ИндексМассива]);
	КонецЦикла;
	
	ВременныйФайлСимметричногоКлючаДляXML = ПолучитьИмяВременногоФайла();
	ЗаписатьФайлИзМассива(ВременныйФайлСимметричногоКлючаДляXML, МассивСимметричногоКлючаДляXML);
	ДвоичныеДанныеСимметричногоКлючаДляXML = Новый ДвоичныеДанные(ВременныйФайлСимметричногоКлючаДляXML);
	СимметричныйКлючДляXMLВBase64 = Base64Строка(ДвоичныеДанныеСимметричногоКлючаДляXML);
	УдалитьВременныйФайл(ВременныйФайлСимметричногоКлючаДляXML);
	
	// формирование зашифрованных данных для вставки в XML 
	ВременныйФайлИнициализационногоВектора = ПолучитьИмяВременногоФайла();
	Если ЭтоАдресВременногоХранилища(ИнициализационныйВекторВBase64) Тогда
		ДвоичныеДанныеИнициализационногоВектора = ПолучитьИзВременногоХранилища(ИнициализационныйВекторВBase64);
	Иначе
		ДвоичныеДанныеИнициализационногоВектора = Base64Значение(ИнициализационныйВекторВBase64);
	КонецЕсли;
	ДвоичныеДанныеИнициализационногоВектора.Записать(ВременныйФайлИнициализационногоВектора);
	Если ДвоичныеДанныеИнициализационногоВектора.Размер() <> 8 Тогда
		ОбщегоНазначения.СообщитьПользователю(НСтр("ru = 'Неверный формат данных при шифрации'"));
		Возврат Неопределено;
	КонецЕсли;
	
	ВременныйФайлЗашифрованныхДанных = ПолучитьИмяВременногоФайла();
	Если ЭтоАдресВременногоХранилища(ЗашифрованныеДанныеВBase64) Тогда
		ДвоичныеДанныеЗашифрованныхДанных = ПолучитьИзВременногоХранилища(ЗашифрованныеДанныеВBase64);
	Иначе
		ДвоичныеДанныеЗашифрованныхДанных = Base64Значение(ЗашифрованныеДанныеВBase64);
	КонецЕсли;
	ДвоичныеДанныеЗашифрованныхДанных.Записать(ВременныйФайлЗашифрованныхДанных);
	
	МассивИмен = Новый Массив;
	МассивИмен.Добавить(ВременныйФайлИнициализационногоВектора);
	МассивИмен.Добавить(ВременныйФайлЗашифрованныхДанных);
	ВременныйФайлЗашифрованныхДанныхДляXML = ПолучитьИмяВременногоФайла();
	ОбъединитьФайлы(МассивИмен, ВременныйФайлЗашифрованныхДанныхДляXML);
	
	УдалитьВременныйФайл(ВременныйФайлИнициализационногоВектора);
	УдалитьВременныйФайл(ВременныйФайлЗашифрованныхДанных);
	
	ДвоичныеДанныеЗашифрованныхДанныхДляXML = Новый ДвоичныеДанные(ВременныйФайлЗашифрованныхДанныхДляXML);
	ЗашифрованныеДанныеДляXMLВBase64 = Base64Строка(ДвоичныеДанныеЗашифрованныхДанныхДляXML);
	УдалитьВременныйФайл(ВременныйФайлЗашифрованныхДанныхДляXML);
	
	Результат = Новый Структура;
	Результат.Вставить("СимметричныйКлючДляXMLВBase64", 	СимметричныйКлючДляXMLВBase64);
	Результат.Вставить("ЗашифрованныеДанныеДляXMLВBase64", 	ЗашифрованныеДанныеДляXMLВBase64);
	Возврат Результат;
	
КонецФункции

Функция РазобратьДанныеИзЗашифрованногоXML(
		Знач СимметричныйКлючИзXMLВBase64,
		Знач ЗашифрованныеДанныеИзXMLВBase64,
		Знач ВозвращатьТекстВBase64 = Истина,
		Знач СертификатПолучателя64 = Неопределено)
	
	ЭтоЭлектроннаяПодписьВМоделиСервиса = НЕ ВозвращатьТекстВBase64;
	
	Алгоритм = ПолучитьАлгоритмШифрования();
	
	ВременныйФайлСимметричногоКлючаИзXML = ПолучитьИмяВременногоФайла();
	ДвоичныеДанныеСимметричногоКлючаИзXML = Base64Значение(СимметричныйКлючИзXMLВBase64);
	ДвоичныеДанныеСимметричногоКлючаИзXML.Записать(ВременныйФайлСимметричногоКлючаИзXML);
	МассивСимметричногоКлючаИзXML = ПрочитатьФайлВМассив(ВременныйФайлСимметричногоКлючаИзXML);
	УдалитьВременныйФайл(ВременныйФайлСимметричногоКлючаИзXML);
	Если МассивСимметричногоКлючаИзXML.Количество() < 167 Тогда
		ОбщегоНазначения.СообщитьПользователю(НСтр("ru = 'Неверный формат данных при дешифрации'"));
		Возврат Неопределено;
	КонецЕсли;
	
	// Заголовок симметричного ключа
	МассивСимметричногоКлюча = ПолучитьМассивБайтовИзСтрокиВШестнадцатеричномПредставлении("01 20 00 00 1E 66 00 00 FD 51 4A 37 1E 66 00 00");
	
	// Добавление инициализационного вектора симметричного ключа
	ИндексНачала = ?(Алгоритм = "GOST R 34.10-2012-256", 164, ?(Алгоритм = "GOST R 34.10-2012-512", 232, 159));
	ИндексКонца = ?(Алгоритм = "GOST R 34.10-2012-256", 171, ?(Алгоритм = "GOST R 34.10-2012-512", 239, 166));
	Для ИндексМассива = ИндексНачала По ИндексКонца Цикл
		МассивСимметричногоКлюча.Добавить(МассивСимметричногоКлючаИзXML[ИндексМассива]);
	КонецЦикла;
	
	// Добавление симметричного ключа
	Для ИндексМассива = 7 По 38 Цикл
		МассивСимметричногоКлюча.Добавить(МассивСимметричногоКлючаИзXML[ИндексМассива]);
	КонецЦикла;
	
	// Добавление имитовставки
	Для ИндексМассива = 41 По 44 Цикл
		МассивСимметричногоКлюча.Добавить(МассивСимметричногоКлючаИзXML[ИндексМассива]);
	КонецЦикла;
	
	// Добавление завершения симметричного ключа
	Если Алгоритм = "GOST R 34.10-2012-256" ИЛИ Алгоритм = "GOST R 34.10-2012-512" Тогда
		МассивЗавершенияСимметричногоКлюча = ПолучитьМассивБайтовИзСтрокиВШестнадцатеричномПредставлении(
			"30 0B 06 09 2A 85 03 07 01 02 05 01 01");
	Иначе
		МассивЗавершенияСимметричногоКлюча = ПолучитьМассивБайтовИзСтрокиВШестнадцатеричномПредставлении(
			"30 09 06 07 2A 85 03 02 02 1F 01");
	КонецЕсли;
	Для ИндексМассива = 0 По МассивЗавершенияСимметричногоКлюча.ВГраница() Цикл
		МассивСимметричногоКлюча.Добавить(МассивЗавершенияСимметричногоКлюча[ИндексМассива]);
	КонецЦикла;
	
	ВременныйФайлСимметричногоКлюча = ПолучитьИмяВременногоФайла();
	ЗаписатьФайлИзМассива(ВременныйФайлСимметричногоКлюча, МассивСимметричногоКлюча);
	ДвоичныеДанныеСимметричногоКлюча = Новый ДвоичныеДанные(ВременныйФайлСимметричногоКлюча);
	Если ВозвращатьТекстВBase64 Тогда
		СимметричныйКлючВBase64 = Base64Строка(ДвоичныеДанныеСимметричногоКлюча);
	Иначе
		СимметричныйКлючВBase64 = ПоместитьВоВременноеХранилище(ДвоичныеДанныеСимметричногоКлюча, Новый УникальныйИдентификатор);
	КонецЕсли;
	УдалитьВременныйФайл(ВременныйФайлСимметричногоКлюча);
	
	// Извлечение публичного ключа из данных XML
	
	// Заголовок публичного ключа
	Если Алгоритм = "GOST R 34.10-2012-256" Тогда
		МассивПубличногоКлюча = ПолучитьМассивБайтовИзСтрокиВШестнадцатеричномПредставлении(
			"06 20 00 00 49 2E 00 00 4D 41 47 31 00 02 00 00 30 13 06 07 2A 85 03 02 02 24 00 06 08 2A 85 03 07 01 01 02 02");
	ИначеЕсли Алгоритм = "GOST R 34.10-2012-512" Тогда
		МассивПубличногоКлюча = ПолучитьМассивБайтовИзСтрокиВШестнадцатеричномПредставлении(
			"06 20 00 00 3D 2E 00 00 4D 41 47 31 00 04 00 00 30 15 06 09 2A 85 03 07 01 02 01 02 01 06 08 2A 85 03 07 01 01 02 03");
	Иначе
		МассивПубличногоКлюча = ПолучитьМассивБайтовИзСтрокиВШестнадцатеричномПредставлении(
			"06 20 00 00 23 2E 00 00 4D 41 47 31 00 02 00 00 30 12 06 07 2A 85 03 02 02 24 00 06 07 2A 85 03 02 02 1E 01");
	КонецЕсли;
	
	// Добавление публичного ключа
	ИндексНачала = ?(Алгоритм = "GOST R 34.10-2012-256", 98, ?(Алгоритм = "GOST R 34.10-2012-512", 102, 93));
	ИндексКонца = ?(Алгоритм = "GOST R 34.10-2012-256", 161, ?(Алгоритм = "GOST R 34.10-2012-512", 229, 156));
	Для ИндексМассива = ИндексНачала По ИндексКонца Цикл
		МассивПубличногоКлюча.Добавить(МассивСимметричногоКлючаИзXML[ИндексМассива]);
	КонецЦикла;
	
	ВременныйФайлПубличногоКлюча = ПолучитьИмяВременногоФайла();
	ЗаписатьФайлИзМассива(ВременныйФайлПубличногоКлюча, МассивПубличногоКлюча);
	ДвоичныеДанныеПубличногоКлюча = Новый ДвоичныеДанные(ВременныйФайлПубличногоКлюча);
	Если ВозвращатьТекстВBase64 Тогда
		ПубличныйКлючВBase64 = Base64Строка(ДвоичныеДанныеПубличногоКлюча);
	Иначе
		ПубличныйКлючВBase64 = ПоместитьВоВременноеХранилище(ДвоичныеДанныеПубличногоКлюча, Новый УникальныйИдентификатор);
	КонецЕсли;
	УдалитьВременныйФайл(ВременныйФайлПубличногоКлюча);
	
	// Извлечение инициализационного вектора из данных XML
	
	ВременныйФайлЗашифрованныхДанныхИзXML = ПолучитьИмяВременногоФайла();
	ДвоичныеДанныеЗашифрованныхДанныхИзXML = Base64Значение(ЗашифрованныеДанныеИзXMLВBase64);
	ДвоичныеДанныеЗашифрованныхДанныхИзXML.Записать(ВременныйФайлЗашифрованныхДанныхИзXML);
	МассивИнициализационногоВектора = ПрочитатьФайлВМассив(ВременныйФайлЗашифрованныхДанныхИзXML, 0, 8);
	Если МассивИнициализационногоВектора.Количество() < 8 Тогда
		ОбщегоНазначения.СообщитьПользователю(НСтр("ru = 'Неверный формат данных при дешифрации'"));
		УдалитьВременныйФайл(ВременныйФайлЗашифрованныхДанныхИзXML);
		Возврат Неопределено;
	КонецЕсли;
	
	ВременныйФайлИнициализационногоВектора = ПолучитьИмяВременногоФайла();
	ЗаписатьФайлИзМассива(ВременныйФайлИнициализационногоВектора, МассивИнициализационногоВектора);
	ДвоичныеДанныеИнициализационногоВектора = Новый ДвоичныеДанные(ВременныйФайлИнициализационногоВектора);
	Если ВозвращатьТекстВBase64 Тогда
		ИнициализационныйВекторВBase64 = Base64Строка(ДвоичныеДанныеИнициализационногоВектора);
	Иначе
		ИнициализационныйВекторВBase64 = ПоместитьВоВременноеХранилище(ДвоичныеДанныеИнициализационногоВектора, Новый УникальныйИдентификатор);
	КонецЕсли;
	УдалитьВременныйФайл(ВременныйФайлИнициализационногоВектора);
	
	ВременныйФайлЗашифрованныхДанных = ПолучитьИмяВременногоФайла();
	СкопироватьФрагментИзФайла(ВременныйФайлЗашифрованныхДанныхИзXML, ВременныйФайлЗашифрованныхДанных, 8);
	УдалитьВременныйФайл(ВременныйФайлЗашифрованныхДанныхИзXML);
	
	ДвоичныеДанныеЗашифрованныхДанных = Новый ДвоичныеДанные(ВременныйФайлЗашифрованныхДанных);
	Если ВозвращатьТекстВBase64 Тогда
		ЗашифрованныеДанныеВBase64 = Base64Строка(ДвоичныеДанныеЗашифрованныхДанных);
	Иначе
		ЗашифрованныеДанныеВBase64 = ПоместитьВоВременноеХранилище(ДвоичныеДанныеЗашифрованныхДанных, Новый УникальныйИдентификатор);
	КонецЕсли;
	УдалитьВременныйФайл(ВременныйФайлЗашифрованныхДанных);
	
	Результат = Новый Структура;
	Результат.Вставить("СимметричныйКлючВBase64", 			СимметричныйКлючВBase64);
	Результат.Вставить("ПубличныйКлючВBase64", 				ПубличныйКлючВBase64);
	Результат.Вставить("ИнициализационныйВекторВBase64", 	ИнициализационныйВекторВBase64);
	Результат.Вставить("ЗашифрованныеДанныеВBase64", 		ЗашифрованныеДанныеВBase64);
	Возврат Результат;
	
КонецФункции

Функция ПолучитьДанныеПоставщикаСертификата(СтруктураДанных)
	
	Результат = "";
	
	Для Каждого Элемента Из СтруктураДанных Цикл
		Если ЗначениеЗаполнено(Результат) Тогда
			Результат = Результат + ",";
		КонецЕсли;
		Результат = Результат + Элемента.Ключ + "=" + Элемента.Значение;	
	КонецЦикла; 
	
	Возврат Результат; 
	
КонецФункции

Функция СкопироватьФрагментИзФайла(ИмяФайла, ИмяФайлаРезультата, Позиция = 0, Количество = Неопределено)
	
	Скопировано = 0;
	
	ЧтениеТекста = Новый ЧтениеТекста(ИмяФайла, "ISO-8859-1", Символы.ПС, Символы.ПС);
	ЗаписьТекста = Новый ЗаписьТекста(ИмяФайлаРезультата, "ISO-8859-1", Символы.ПС, , Символы.ПС);
	
	Прочтено = 0;
	Пока Прочтено < Позиция Цикл
		ДлинаБлока = Позиция - Прочтено;
		ДлинаБлока = ?(ДлинаБлока <= 1000000, ДлинаБлока, 1000000);
		ТекстИзФайла = ЧтениеТекста.Прочитать(ДлинаБлока);
		Если ТекстИзФайла = Неопределено ИЛИ СтрДлина(ТекстИзФайла) < ДлинаБлока Тогда
			ЗаписьТекста.Закрыть();
			ЧтениеТекста.Закрыть();
			Возврат Скопировано;
		КонецЕсли;
		Прочтено = Прочтено + ДлинаБлока;
	КонецЦикла;
	
	Пока Количество = Неопределено ИЛИ Скопировано < Количество Цикл
		ДлинаБлока = ?(Количество <> Неопределено И Количество - Скопировано <= 1000000, Количество - Скопировано, 1000000);
		ТекстИзФайла = ЧтениеТекста.Прочитать(ДлинаБлока);
		Если ТекстИзФайла <> Неопределено Тогда
			ЗаписьТекста.Записать(ТекстИзФайла);
			Скопировано = Скопировано + СтрДлина(ТекстИзФайла);
		КонецЕсли;
		Если ТекстИзФайла = Неопределено ИЛИ СтрДлина(ТекстИзФайла) < ДлинаБлока Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	ЗаписьТекста.Закрыть();
	ЧтениеТекста.Закрыть();
	
	Возврат Скопировано;
	
КонецФункции

Функция ПолучитьМассивБайтовИзСтрокиВШестнадцатеричномПредставлении(Строка)
	
	Результат = Новый Массив;
	
	СтрокаСимволов = "0123456789ABCDEF";
	Число = 0;
	ЭтоМладшийПолубайт = Ложь;
	Для НомерСимвола = 1 По СтрДлина(Строка) Цикл
		ТекЦифра = СтрНайти(СтрокаСимволов, Сред(Строка, НомерСимвола, 1)) - 1;
		Если ТекЦифра >= 0 Тогда
			Если ЭтоМладшийПолубайт Тогда
				Число = Число + ТекЦифра;
				Результат.Добавить(Число);
			Иначе
				Число = 16 * ТекЦифра;
			КонецЕсли;
			ЭтоМладшийПолубайт = НЕ ЭтоМладшийПолубайт;
		КонецЕсли;
	КонецЦикла; 
	
	Возврат Результат;
	
КонецФункции

Функция ПрочитатьФайлВМассив(ИмяФайла, Позиция = 0, Количество = Неопределено)
	
	Результат = Новый Массив;
	
	ЧтениеТекста = Новый ЧтениеТекста(ИмяФайла, "ISO-8859-1", Символы.ПС, Символы.ПС);
	
	Прочтено = 0;
	Пока Позиция > Прочтено Цикл
		ДлинаБлока = Позиция - Прочтено;
		ДлинаБлока = ?(ДлинаБлока <= 1000000, ДлинаБлока, 1000000);
		ТекстИзФайла = ЧтениеТекста.Прочитать(ДлинаБлока);
		Если ТекстИзФайла = Неопределено ИЛИ СтрДлина(ТекстИзФайла) < ДлинаБлока Тогда
			ЧтениеТекста.Закрыть();
			Возврат Результат;
		КонецЕсли;
		Прочтено = Прочтено + ДлинаБлока;
	КонецЦикла;
	
	Осталось = Количество;
	Пока Осталось = Неопределено ИЛИ Осталось > 0 Цикл
		СимволТекста = ЧтениеТекста.Прочитать(1);
		Если СимволТекста = Неопределено Тогда
			Прервать;
		КонецЕсли;
		КодСимволаТекста = КодСимвола(СимволТекста);
		
		Результат.Добавить(КодСимволаТекста);
		
		Если Осталось <> Неопределено Тогда
			Осталось = Осталось - 1;
		КонецЕсли;
	КонецЦикла;
	ЧтениеТекста.Закрыть();
	
	Возврат Результат;
	
КонецФункции

Процедура ЗаписатьФайлИзМассива(ИмяФайла, Массив)
	
	ЗаписьТекста = Новый ЗаписьТекста(ИмяФайла, "ISO-8859-1", Символы.ПС, , Символы.ПС);
	
	Для ИндексВМассиве = 0 По Массив.ВГраница() Цикл
		СимволИзМассива = Символ(Массив[ИндексВМассиве]);
		ЗаписьТекста.Записать(СимволИзМассива);
	КонецЦикла;
	ЗаписьТекста.Закрыть();
	
КонецПроцедуры

Процедура УдалитьВременныйФайл(ИмяФайла)
	
	Если НЕ ЗначениеЗаполнено(ИмяФайла) Тогда
		Возврат;
	КонецЕсли;
	
	Попытка
		УдалитьФайлы(ИмяФайла);
	Исключение
	КонецПопытки;
	
КонецПроцедуры

Функция ПолучитьАлгоритмШифрования()
	
	//Если ЗначениеЗаполнено(СертификатПолучателя64) Тогда
	//	Алгоритм = КриптографияЭДКО.АлгоритмКриптосообщенияИлиСертификата(
	//		СертификатПолучателя64,
	//		Истина,
	//		Истина,
	//		ЭтоЭлектроннаяПодписьВМоделиСервиса);
	//Иначе
	//	//Алгоритм = КриптографияЭДКОКлиентСервер.АлгоритмПоУмолчанию();
	//КонецЕсли;
	
	Алгоритм = "GOST R 34.10-2012-256"; 
	
	// Извлечение симметричного ключа из данных XML
	
	Возврат Алгоритм;
	
КонецФункции

#КонецОбласти