#Область ОбработчикиСобытийФормы

&НаКлиенте
Процедура ПриОткрытии(Отказ)
	ТипСовпадения = "EXACT";
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиКомандФормы

&НаКлиенте
Процедура ЗагрузитьКлассификатор(Команда)
	ПараметрыОтбора = ПараметрыОтбора();
	ЗагрузитьКлассификаторНаСервере(ПараметрыОтбора);
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

&НаКлиенте
Функция ПараметрыОтбора()
	ПараметрыОтбора = Неопределено;
	Если ЗначениеЗаполнено(ОтборПоле) Тогда
		ПараметрыОтбора = Новый Структура();	
		СтрокаФильтра = "%1|%2|%3";
		МассивФильтров = Новый Массив();	
		МассивФильтров.Добавить(СтрШаблон(СтрокаФильтра,ОтборПоле,ОтборЗначение,ТипСовпадения));
		ПараметрыОтбора.Вставить("filters", МассивФильтров);
	КонецЕсли; 
		
	Возврат ПараметрыОтбора;
КонецФункции

&НаСервере
Процедура ЗагрузитьКлассификаторНаСервере(ПараметрыОтбора)
	Если ПараметрыОтбора = Неопределено Тогда
		ТаблицаДанных = ЗапроситьКлассификатор(OIDСправочника);
	Иначе
		ТаблицаДанных = ПолучитьКлассификаторПоОтбору(OIDСправочника, ПараметрыОтбора);	
	КонецЕсли; 
	
	Если ТаблицаДанных <> Неопределено Тогда
		ДанныеКлассификатора.Очистить();
		ВывестиТаблицуЗначенияВТаблицуНаФорме(ТаблицаДанных, "ДанныеКлассификатора");
	Иначе
		ОбщегоНазначения.СообщитьПользователю(НСтр("ru='Ошибка!'")); 
	КонецЕсли; 
КонецПроцедуры

&НаСервере
Процедура ВывестиТаблицуЗначенияВТаблицуНаФорме(ТаблицаЗначений, ТабРеквизит, ТабЭлементФормы = Неопределено)
	Если ТабЭлементФормы = Неопределено Тогда
		ТабЭлементФормы = ТабРеквизит;
	КонецЕсли; 
	
	// Собирается инофрмация по добавленным ранее элементам формы и реквизитам, на которые элементы формы ссылаются.
	УдаляемыеРеквизиты = Новый Массив;
	УдаляемыеЭлементы = Новый Массив;
	Для каждого Эл Из Элементы[ТабЭлементФормы].ПодчиненныеЭлементы Цикл
		УдаляемыеРеквизиты.Добавить(Эл.ПутьКДанным);
		УдаляемыеЭлементы.Добавить(Эл);
	КонецЦикла; 
	Для каждого Эл Из УдаляемыеЭлементы Цикл
		Элементы.Удалить(Эл);
	КонецЦикла; 
	
	// Добавляются колонки из ТаблицыЗначений в реквизит таблицы ТабРеквизит
	НовыеРеквизиты = Новый Массив;
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		НовыйРеквизит = Новый РеквизитФормы(Колонка.Имя, Колонка.ТипЗначения, ТабРеквизит, Колонка.Заголовок);
	   	НовыеРеквизиты.Добавить(НовыйРеквизит);
	КонецЦикла;

    //Удаляются старые и устанавливаются новые реквизиты
	ИзменитьРеквизиты(НовыеРеквизиты, УдаляемыеРеквизиты);
	
    // Добавляются колонки из ТаблицыЗначений в элементы ТабЭлементФормы со ссылкой на колонки в ТабРеквизит
    Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
        НовыйЭлемент = Элементы.Добавить( ТабРеквизит + "_" + Колонка.Имя, Тип("ПолеФормы"), Элементы[ТабЭлементФормы]);
        НовыйЭлемент.Вид = ВидПоляФормы.ПолеНадписи; //Или ПолеВвода, или что-то другое;
        НовыйЭлемент.ПутьКДанным = ТабРеквизит + "." + Колонка.Имя;
    КонецЦикла;
 
 	// В созданный реквизит загружается ТЗ
	ЭтаФорма[ТабРеквизит].Загрузить(ТаблицаЗначений);
КонецПроцедуры

#Область ЗагрузкаКлассификатора

&НаСервере
Функция ЗапроситьКлассификатор(OID) 
	
	Версия = ПолучитьПоследнююВерсиюКлассификатора(OID);
	Если Версия = Неопределено Тогда
		Возврат Неопределено;	
	КонецЕсли; 
	
	ТаблицаДанных = Неопределено;
	Попытка
		КоличествоЧастей = ЗапроситьКоличествоЧастейКлассификатора(OID, Версия);
		Если КоличествоЧастей = 0 Тогда
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю("ru='Не удалось загрузить количество частей справочника'");
		ИначеЕсли КоличествоЧастей = 1 Тогда
			ТаблицаДанных = ЗапроситьКлассификаторЦеликом(OID, Версия);
		Иначе
			ТаблицаДанных = ЗапроситьКлассификаторПоЧастям(OID, Версия, КоличествоЧастей);
		КонецЕсли; 
	Исключение
		ОбщиеМеханизмы.ОбработатьОшибку(ИнформацияОбОшибке());
	КонецПопытки;
	Возврат ТаблицаДанных;
	
КонецФункции

&НаСервере
Функция ПолучитьКлассификаторПоОтбору(OID, ПараметрыОтбора = Неопределено) Экспорт
	
	Версия = ПолучитьПоследнююВерсиюКлассификатора(OID);
	Если Версия = Неопределено Тогда
		Возврат Неопределено;	
	КонецЕсли;
	
	РесурсНаСервере = СтрШаблон("port/rest/data?userKey=%1&identifier=%2&version=%3",
								ПолучитьТокенПользователя(),
								OID,
								Версия);
	
	Если ПараметрыОтбора <> Неопределено Тогда
		Для каждого ПараметрОтбора Из ПараметрыОтбора Цикл
			Если ТипЗнч(ПараметрОтбора.Значение) = Тип("Массив") Тогда
				Для каждого ЗначениеОтбора Из ПараметрОтбора.Значение Цикл
					СтрокаПараметра = СтрШаблон("&%1=%2",ПараметрОтбора.Ключ,ЗначениеОтбора);
					РесурсНаСервере = РесурсНаСервере + СтрокаПараметра;	
				КонецЦикла;	
			Иначе
				СтрокаПараметра = СтрШаблон("&%1=%2",ПараметрОтбора.Ключ,ПараметрОтбора.Значение);
				РесурсНаСервере = РесурсНаСервере + СтрокаПараметра;
			КонецЕсли; 
		КонецЦикла;	
	КонецЕсли; 
	 			
	СтрокаОтвета = ОтправитьЗапрос(РесурсНаСервере);
	
	Если Не ЗначениеЗаполнено(СтрокаОтвета) Тогда
		Возврат Неопределено;
	КонецЕсли;	
	
	XMLРезультат = JSON2XML(СтрокаОтвета);
	XDTOРезультат = ОбработатьОтветСервиса("data",XMLРезультат); 
	Результат = ПрочитатьДанныеКлассификатораИзXDTO(XDTOРезультат);
	
	Возврат Результат;
	
КонецФункции

&НаСервере
Функция ОтправитьЗапрос(РесурсНаСервере)

	АдресСервера = "https://nsi.rosminzdrav.ru:443";
	
	ОписаниеОшибкиУстановкиСоединения = "";
	СоединениеHTTP = УстановитьСоединениеССерверомИнтернета(
		АдресСервера, ОписаниеОшибкиУстановкиСоединения
	);
	Если СоединениеHTTP = Неопределено Тогда
		ТекстОшибки = НСтр("ru = 'Не удалось установить соединение с сервером:
						   |%1'");
		ТекстОшибки = СтрШаблон(ТекстОшибки, ОписаниеОшибкиУстановкиСоединения);
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки);
		Возврат Неопределено;
	КонецЕсли;
	
	Попытка
		
		HTTPЗапрос = Новый HTTPЗапрос(РесурсНаСервере);		
		HTTPОтвет = СоединениеHTTP.Получить(HTTPЗапрос);
		
	Исключение
		
		ОбщиеМеханизмы.ОбработатьОшибку(ИнформацияОбОшибке());
		Возврат Неопределено;
		
	КонецПопытки;
	
	Возврат HTTPОтвет.ПолучитьТелоКакСтроку();
	
КонецФункции

&НаСервере
Функция ПрочитатьJSONОтвет(ТекстJSON)
	ЧтениеJSON = Новый ЧтениеJSON();
	ЧтениеJSON.УстановитьСтроку(ТекстJSON);
	Результат = ОбойтиJSON(ЧтениеJSON);	
	Возврат Результат;
КонецФункции

&НаСервере
Функция ОбойтиJSON(ЧтениеJSON, МассивРодитель = Неопределено)
	
	Пока ЧтениеJSON.Прочитать() Цикл
		Если ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.НачалоОбъекта Тогда
			ТекущийОбъект = Новый Структура();
		ИначеЕсли ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.КонецОбъекта Тогда 
			Если МассивРодитель = Неопределено Тогда
				Прервать;
			Иначе 
				МассивРодитель.Добавить(ТекущийОбъект);	
			КонецЕсли; 
		ИначеЕсли ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.ИмяСвойства Тогда 
			ТекущееСвойство = ЧтениеJSON.ТекущееЗначение;
		ИначеЕсли ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.НачалоМассива Тогда
			МассивОбъектов = Новый Массив;
			ОбойтиJSON(ЧтениеJSON, МассивОбъектов);
			Если МассивРодитель = Неопределено Тогда
				ТекущийОбъект.Вставить(ТекущееСвойство, МассивОбъектов);
			Иначе
				МассивРодитель.Добавить(МассивОбъектов);	
			КонецЕсли; 		
		ИначеЕсли ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.КонецМассива Тогда 
			Прервать;	
		ИначеЕсли ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.Булево
			Или ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.Строка
			Или ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.Число 
			Или ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.Null
		Тогда 
			ТекущийОбъект.Вставить(ТекущееСвойство, ЧтениеJSON.ТекущееЗначение);
		КонецЕсли;
	КонецЦикла; 
	
	Возврат ТекущийОбъект;
		
КонецФункции

&НаСервере
Функция JSON2XML(ТекстJSON)
	СтруктураОтвета = ПрочитатьJSONОтвет(ТекстJSON);
	
	Если Не СтруктураОтвета.Свойство("list") Или СтруктураОтвета.list.Количество() = 0 Тогда
		МассивСтрок = Новый Массив();
	Иначе
		МассивСтрок = СтруктураОтвета.list;
	КонецЕсли; 		
	
	
	ЗаписьXML = Новый ЗаписьXML();
	ЗаписьXML.УстановитьСтроку();
	
	ЗаписьXML.ЗаписатьНачалоЭлемента("soap:Envelope");
	ЗаписьXML.ЗаписатьАтрибут("xmlns:soap","http://schemas.xmlsoap.org/soap/envelope/");
		
	ЗаписьXML.ЗаписатьНачалоЭлемента("soap:Body");
	ЗаписьXML.ЗаписатьНачалоЭлемента("ns1:dataResponse");
	ЗаписьXML.ЗаписатьАтрибут("xmlns:ns1","urn:service"); 
	ЗаписьXML.ЗаписатьНачалоЭлемента("dataReturn");
	Сч = 0;
	Для каждого Строка Из МассивСтрок Цикл
		ЗаписьXML.ЗаписатьНачалоЭлемента("item");
		ЗаписьXML.ЗаписатьНачалоЭлемента("children");
		ПервоеСвойство = Истина;
		Для каждого ПараметрСтроки Из Строка Цикл
			ЗаписьXML.ЗаписатьНачалоЭлемента("item");
			ЗаписьXML.ЗаписатьНачалоЭлемента("children");
			Если ПервоеСвойство Тогда	
				ЗаписьXML.ЗаписатьАтрибут("id","ref1");	
				ПервоеСвойство = Ложь;
			Иначе
				ЗаписьXML.ЗаписатьАтрибут("href","#ref1");	
			КонецЕсли; 
			ЗаписьXML.ЗаписатьКонецЭлемента();
			ЗаписьXML.ЗаписатьНачалоЭлемента("key");
			ЗаписьXML.ЗаписатьТекст(ПараметрСтроки.column);
			ЗаписьXML.ЗаписатьКонецЭлемента();
			ЗаписьXML.ЗаписатьНачалоЭлемента("value");
			ЗаписьXML.ЗаписатьТекст(Строка(ПараметрСтроки.value));
			ЗаписьXML.ЗаписатьКонецЭлемента();
			ЗаписьXML.ЗаписатьКонецЭлемента();	
		КонецЦикла;
		ЗаписьXML.ЗаписатьНачалоЭлемента("key");
		ЗаписьXML.ЗаписатьТекст(Строка(Сч));
		Сч = Сч + 1;
		ЗаписьXML.ЗаписатьКонецЭлемента();
		ЗаписьXML.ЗаписатьКонецЭлемента();
		ЗаписьXML.ЗаписатьКонецЭлемента();
	КонецЦикла; 
	ЗаписьXML.ЗаписатьКонецЭлемента();
	ЗаписьXML.ЗаписатьКонецЭлемента();
	ЗаписьXML.ЗаписатьКонецЭлемента();
	ЗаписьXML.ЗаписатьКонецЭлемента();
	
	Возврат ЗаписьXML.Закрыть();
	
КонецФункции

&НаСервере
Функция ПолучитьПоследнююВерсиюКлассификатора(OID)
	
	АктуальнаяВерсия = Неопределено;
	Версии = ПолучитьВсеВерсииКлассификатора(OID);
	Если ТипЗнч(Версии) = Тип("ТаблицаЗначений") И Версии.Количество() > 0 Тогда
		Версии.Сортировать("ДатаОбновления Убыв");
		АктуальнаяВерсия = Версии[0].Версия;	
	КонецЕсли;
	Возврат АктуальнаяВерсия;
	
КонецФункции

&НаСервере
Функция ПолучитьВсеВерсииКлассификатора(OID) Экспорт
	ВерсииКлассификатора = Неопределено;
	
	ПараметрыЗапроса = Новый Структура("OID, ID", OID, ПолучитьТокенПользователя());
	
	ИмяОперации = "getVersionList";
	ТекстОперации = ПолучитьТекстSOAP(ИмяОперации, ПараметрыЗапроса);
	
	Результат = ВыполнитьОбменДанными(ТекстОперации, ИмяОперации);
	Если ТипЗнч(Результат) = Тип("ОбъектXDTO") Тогда
		ВерсииКлассификатора = ПрочитатьВерсииКлассификатора(Результат);
	КонецЕсли;
	
	Возврат ВерсииКлассификатора;
	
КонецФункции

&НаСервере
Функция ПрочитатьВерсииКлассификатора(ОбъектXDTO)
	
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("Версия", Новый ОписаниеТипов("Строка"));
	Таблица.Колонки.Добавить("ДатаОбновления", Новый ОписаниеТипов("Дата"));

	Если Не ТипЗнч(ОбъектXDTO) = Тип("ОбъектXDTO") Тогда
		Возврат Таблица;
	КонецЕсли; 
	
	СписокЗаписей = Новый Массив;
	Если ТипЗнч(ОбъектXDTO.item) = Тип("ОбъектXDTO") Тогда
		СписокЗаписей.Добавить(ОбъектXDTO.item);
	ИначеЕсли ТипЗнч(ОбъектXDTO.item) = Тип("СписокXDTO") Тогда
		СписокЗаписей = ОбъектXDTO.item;
	КонецЕсли; 

	Для каждого ЭлементВерхнегоУровня Из СписокЗаписей Цикл
		СписокПолей = ЭлементВерхнегоУровня.children.item;
		Если Не ТипЗнч(СписокПолей) = Тип("СписокXDTO") Тогда
			Возврат Таблица;
		КонецЕсли; 
		НоваяСтрока = Таблица.Добавить();
		Для Каждого Элемент Из СписокПолей Цикл
			Если ВРег(Элемент.key) = "S_VERSION" Тогда
				НоваяСтрока.Версия = Элемент.value;
			ИначеЕсли ВРег(Элемент.key) = "V_DATE" Тогда
				НоваяСтрока.ДатаОбновления = ОбщегоНазначенияКлиентСервер.ПреобразоватьСтрокуВДату(Элемент.value);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	Возврат Таблица;
	
КонецФункции

&НаСервере
Функция ПолучитьТокенПользователя() 

	Возврат "20e07b44-19cb-4fd2-b67f-46fd296334cc";

КонецФункции

&НаСервере
Функция ЗапроситьКоличествоЧастейКлассификатора(OID, Версия) 
	КоличествоЧастей = 0;
	
	ПараметрыЗапроса = Новый Структура;
	ПараметрыЗапроса.Вставить("OID", OID);
	ПараметрыЗапроса.Вставить("ID", ПолучитьТокенПользователя());
	ПараметрыЗапроса.Вставить("ВерсияКлассификатора", Версия);
	
	ИмяОперации = "getRefbookParts";
	ТекстОперации = ПолучитьТекстSOAP(ИмяОперации, ПараметрыЗапроса);
	
	Результат = ВыполнитьОбменДанными(ТекстОперации, ИмяОперации);
	Если ТипЗнч(Результат) = Тип("ОбъектXDTO") Тогда
		КоличествоЧастей = ПрочитатьКоличествоЧастейКлассификатораИзXDTO(Результат);
	КонецЕсли; 
	
	Возврат КоличествоЧастей
КонецФункции

&НаСервере
Функция ПрочитатьКоличествоЧастейКлассификатораИзXDTO(ОбъектXDTO)
	
	Количество = 0;
	
	Если Не ТипЗнч(ОбъектXDTO) = Тип("ОбъектXDTO") Тогда
		Возврат Количество;
	КонецЕсли; 
	
	СписокЗаписей = Новый Массив;
	Если ТипЗнч(ОбъектXDTO.item) = Тип("ОбъектXDTO") Тогда
		СписокЗаписей.Добавить(ОбъектXDTO.item);
	Иначе
		Возврат Количество
	КонецЕсли; 

	Если Не ТипЗнч(ОбъектXDTO.item) = Тип("ОбъектXDTO") Тогда
		Возврат Количество;
	КонецЕсли;
	
	Если "partsAmount" = ОбъектXDTO.item.key Тогда
		КоличествоСтрокой = ОбъектXDTO.item.value
	КонецЕсли; 

	Попытка
		Количество = Число(КоличествоСтрокой);
	Исключение
		ОбщиеМеханизмы.ОбработатьОшибку(ИнформацияОбОшибке());
	КонецПопытки;
	
	Возврат Количество;
	
КонецФункции

&НаСервере
Функция ЗапроситьКлассификаторПоЧастям(OID, Версия, КоличествоЧастей)
	ТаблицаДанных = Неопределено;
	
	Для НомерЧасти = 1 По КоличествоЧастей Цикл
		ТаблицаДанныхЧасти = ЗапроситьЧастьКлассификатора(
			OID, Версия, НомерЧасти);
		Если ТипЗнч(ТаблицаДанныхЧасти) = Тип("ТаблицаЗначений") Тогда
			Если ТаблицаДанных = Неопределено Тогда
				ТаблицаДанных = ТаблицаДанныхЧасти;
			Иначе
				ОбщегоНазначенияКлиентСервер.ДополнитьТаблицу(ТаблицаДанныхЧасти, ТаблицаДанных);
			КонецЕсли;
		Иначе
			ТаблицаДанных = Неопределено;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ТаблицаДанных;
КонецФункции

&НаСервере
Функция ЗапроситьЧастьКлассификатора(OID, Версия, НомерЧасти)
	ТаблицаДанных = Неопределено;
	
	ПараметрыЗапроса = Новый Структура;
	ПараметрыЗапроса.Вставить("OID", OID);
	ПараметрыЗапроса.Вставить("ID", ПолучитьТокенПользователя());
	ПараметрыЗапроса.Вставить("ВерсияКлассификатора", Версия);
	ПараметрыЗапроса.Вставить("НомерЧастиСправочника", НомерЧасти);
	
	ИмяОперации = "getRefbookPartial";
	ТекстОперации = ПолучитьТекстSOAP(ИмяОперации, ПараметрыЗапроса);
	
	Результат = ВыполнитьОбменДанными(ТекстОперации, ИмяОперации);
	Если ТипЗнч(Результат) = Тип("ОбъектXDTO") Тогда
		ТаблицаДанных = ПрочитатьДанныеКлассификатораИзXDTO(Результат);
	КонецЕсли; 
	
	Возврат ТаблицаДанных;
КонецФункции

&НаСервере
Функция ЗапроситьКлассификаторЦеликом(OID, Версия)
	ТаблицаДанных = Неопределено;
	
	ПараметрыЗапроса = Новый Структура;
	ПараметрыЗапроса.Вставить("OID", OID);
	ПараметрыЗапроса.Вставить("ID", ПолучитьТокенПользователя());
	ПараметрыЗапроса.Вставить("ВерсияКлассификатора", Версия);
	
	ИмяОперации = "getRefbook";
	ТекстОперации = ПолучитьТекстSOAP(ИмяОперации, ПараметрыЗапроса);
	
	Результат = ВыполнитьОбменДанными(ТекстОперации, ИмяОперации);
	Если ТипЗнч(Результат) = Тип("ОбъектXDTO") Тогда
		ТаблицаДанных = ПрочитатьДанныеКлассификатораИзXDTO(Результат);
	КонецЕсли; 
	
	Возврат ТаблицаДанных
КонецФункции

&НаСервере
Функция ПолучитьТекстSOAP(ИмяОперации, ПараметрыЗапроса)
	
	Операция = ДопустимыеОперации(ИмяОперации);
	
	ID  = ?(ПараметрыЗапроса.Свойство("ID"), ПараметрыЗапроса.ID, "");
	OID	= ?(ПараметрыЗапроса.Свойство("OID"), ПараметрыЗапроса.OID, "");	
	Версия	= ?(ПараметрыЗапроса.Свойство("ВерсияКлассификатора"), ПараметрыЗапроса.ВерсияКлассификатора, "");
	
	НомерЧастиСправочника	= ?(ПараметрыЗапроса.Свойство("НомерЧастиСправочника"), ПараметрыЗапроса.НомерЧастиСправочника, "");
	
	Если Операция = "getVersionList" Тогда
		ТекстПараметров = "
			|	<userKey5 xsi:type=""xsd:string"">" + ID + "</userKey5>
			|	<refbookCode4 xsi:type=""xsd:string"">" + OID + "</refbookCode4>"
			
	ИначеЕсли Операция = "getRefbook" Тогда	
		ТекстПараметров = "
			|	<userKey xsi:type=""xsd:string"">" + ID + "</userKey>
			|	<refbookCode xsi:type=""xsd:string"">" + OID + "</refbookCode>
			|	<version xsi:type=""xsd:string"">" + Версия + "</version>"
			
	ИначеЕсли Операция = "getRefbookParts" Тогда		
		ТекстПараметров = "
			|	<userKey3 xsi:type=""xsd:string"">" + ID + "</userKey3>
			|	<refbookCode2 xsi:type=""xsd:string"">" + OID + "</refbookCode2>
			|	<version2 xsi:type=""xsd:string"">" + Версия + "</version2>"
			
	ИначеЕсли Операция = "getRefbookPartial" Тогда			
		ТекстПараметров = "
			|	<userKey2 xsi:type=""xsd:string"">" + ID + "</userKey2>
			|	<refbookCode1 xsi:type=""xsd:string"">" + OID + "</refbookCode1>
			|	<version1 xsi:type=""xsd:string"">" + Версия + "</version1>
			|	<partNumber xsi:type=""xsd:integer"">" + НомерЧастиСправочника + "</partNumber>"
			
	ИначеЕсли Операция = "getRefbookList" Тогда
		ТекстПараметров = "
			|	<userKey1 xsi:type=""xsd:string"">" + ID + "</userKey1>";
		
	ИначеЕсли Операция = "getRefbookUpdate" Тогда		
		ТекстПараметров = "
			|	<userKey4 xsi:type=""xsd:string"">" + ID + "</userKey4>
			|	<refbookCode3 xsi:type=""xsd:string"">" + OID + "</refbookCode3>
			|	<userVersion xsi:type=""xsd:string"">" + Версия + "</userVersion>
			|	<newVersion xsi:type=""xsd:string""></newVersion>"

	КонецЕсли; 
		
	ТекстОперации = 
		"<soap:Envelope xmlns:soap=""http://schemas.xmlsoap.org/soap/envelope/"">
		|	<soap:Header/>
		|	<soap:Body>
		|<m:" + Операция + " xmlns:m=""urn:service""
		|		xmlns:soap=""http://schemas.xmlsoap.org/soap/envelope/""
		|		xmlns:soapenc=""http://schemas.xmlsoap.org/soap/encoding/""
		|		xmlns:xsd=""http://www.w3.org/2001/XMLSchema""
		|		xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
		|		soap:encodingStyle=""http://schemas.xmlsoap.org/soap/encoding/"">"
		+ ТекстПараметров + "
		|</m:" + Операция + ">
		|	</soap:Body>
		|</soap:Envelope>";
	
	Возврат ТекстОперации;
	
КонецФункции

&НаСервере
Функция ДопустимыеОперации(Операция)
	
	ДопустимыеОперации = Новый Структура("getRefbookUpdate, getVersionList, getRefbook, getRefbookParts, getRefbookPartial, getRefbookList");
	
	Если ДопустимыеОперации.Свойство(Операция) Тогда
		Возврат Операция;
	Иначе
		ВызватьИсключение ("Недопустимая операция: "+ Операция);
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции 

&НаСервере
Функция ВыполнитьОбменДанными(Запрос, ИмяОперации)
	
	АдресСервера = ПолучитьАдресСервера(ТестовыйКонтур);
	РесурсНаСервере = "";
	ПозицияЗавершенияСхемы = СтрНайти(АдресСервера, "://");
	Если ПозицияЗавершенияСхемы > 0 Тогда
		СтрокаURI = Сред(АдресСервера, ПозицияЗавершенияСхемы + 3);
		ПозицияЗавершенияСоединения = СтрНайти(СтрокаURI, "/");
		ДлинаСоединения = ?(ПозицияЗавершенияСоединения > 0, ПозицияЗавершенияСоединения - 1, СтрДлина(СтрокаURI));
		РесурсНаСервере = Сред(АдресСервера, ПозицияЗавершенияСхемы + 3 + ДлинаСоединения);
		АдресСервера = Лев(АдресСервера, ПозицияЗавершенияСхемы + 2 + ДлинаСоединения);
		
		ПозицияПараметров = СтрНайти(РесурсНаСервере, "?");
		ДлинаРесурсаНаСервере = ?(ПозицияПараметров > 0, ПозицияПараметров - 1, СтрДлина(РесурсНаСервере));
		РесурсНаСервере = Лев(РесурсНаСервере, ДлинаРесурсаНаСервере);
	КонецЕсли;
	
	ОписаниеОшибкиУстановкиСоединения = "";
	СоединениеHTTP = УстановитьСоединениеССерверомИнтернета(
		АдресСервера, ОписаниеОшибкиУстановкиСоединения
	);
	Если СоединениеHTTP = Неопределено Тогда
		ТекстОшибки = НСтр("ru = 'Не удалось установить соединение с сервером:
						   |%1'");
		ТекстОшибки = СтрШаблон(ТекстОшибки, ОписаниеОшибкиУстановкиСоединения);
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки);
		Возврат Неопределено;
	КонецЕсли;
	
	ТелоЗапросаSOAP = Запрос;
	
	Попытка
		
		HTTPЗапрос = Новый HTTPЗапрос(РесурсНаСервере);
		HTTPЗапрос.УстановитьТелоИзСтроки(
			ТелоЗапросаSOAP,
			,
			ИспользованиеByteOrderMark.НеИспользовать
		);
		
		ЗаголовкиHTTP = HTTPЗапрос.Заголовки;
		ЗаголовкиHTTP.Вставить("Content-Type", "text/xml; charset=utf-8");
		ЗаголовкиHTTP.Вставить("Proxy-Connection", "Keep-Alive");
		
		HTTPОтвет = СоединениеHTTP.ОтправитьДляОбработки(HTTPЗапрос);
		
	Исключение
		
		ОбщиеМеханизмы.ОбработатьОшибку(ИнформацияОбОшибке());
		Возврат Неопределено;
		
	КонецПопытки;
	
	СтрокаОтвета = HTTPОтвет.ПолучитьТелоКакСтроку();
	
	Если Не ЗначениеЗаполнено(СтрокаОтвета) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = ОбработатьОтветСервиса(ИмяОперации, СтрокаОтвета);
	
	Возврат Результат;
	
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьАдресСервера(ТестовыйКонтур)
	
	Если ТестовыйКонтур Тогда
		Возврат ЗагрузкаКлассификаторовНСИЕГИСЗ.ТестовыйАдресСервераWSDL();
	Иначе                                                         
		Возврат ЗагрузкаКлассификаторовНСИЕГИСЗ.АдресСервераWSDL();
	КонецЕсли;
	
КонецФункции

&НаСервере
Функция ОбработатьОтветСервиса(ИмяОперации, СтрокаОтветаXML)
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаОтветаXML);
	ПостроительDOM = Новый ПостроительDOM;
	ДокументDOM = ПостроительDOM.Прочитать(ЧтениеXML);
	ЭлементыFault = ДокументDOM.ПолучитьЭлементыПоИмени(xmlnssoap(), "Fault");
	Если ЭлементыFault.Количество() <> 0 Тогда
		Сообщить(ЭлементыFault[0].ТекстовоеСодержимое);
		Возврат Неопределено;
	КонецЕсли;
	ЧтениеXML.Закрыть();
	
	ЭлементыBody = ДокументDOM.ПолучитьЭлементыПоИмени(xmlnssoap(), "Body");
	Если Не ЭлементыBody.Количество() = 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПервыйДочернийУBody = ЭлементыBody[0].ПервыйДочерний;
	Если Неопределено = ПервыйДочернийУBody Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПространствоИмен = ПервыйДочернийУBody.URIПространстваИмен;
	ЛокальноеИмя = ПервыйДочернийУBody.ЛокальноеИмя;
	
	Если ПространствоИмен <> "urn:service" Тогда
		ВызватьИсключение("ОбменДаннымиСРосминздравом: Неожиданный ответ сервера");
	КонецЕсли;

	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку("UTF-8");
	
	ЗаписьDOM = Новый ЗаписьDOM;
	ЗаписьDOM.Записать(ПервыйДочернийУBody, ЗаписьXML);
	
	ПервыйДочернийУBodyСтрокой = ЗаписьXML.Закрыть();
	
	ЧтениеXML = Новый ЧтениеXML; 
	ЧтениеXML.УстановитьСтроку(ПервыйДочернийУBodyСтрокой);
	ОбъектXDTO = ФабрикаXDTO.ПрочитатьXML(ЧтениеXML);
	
	Если ОбъектXDTO = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если (ИмяОперации + "Response") <> ЛокальноеИмя Тогда
		ВызватьИсключение("Некорректный ответ сервиса");
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = Неопределено;
	Попытка
		Выполнить("Результат = ОбъектXDTO."+ ИмяОперации + "Return");
	Исключение
		ВызватьИсключение("Не удалось обработать ответ сервиса");
		Возврат Неопределено;
	КонецПопытки;
	
	Если ТипЗнч(Результат) <> Тип("ОбъектXDTO")Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если Результат.Свойства().Получить("item") <> Неопределено И Тип("ОбъектXDTO") = ТипЗнч(Результат.item) Тогда
		Если Не Неопределено = Результат.item.Свойства().Получить("key") 
			И "errors" = Результат.item.key 
			Тогда
			ТекстОшибки = "";
			Ошибки = Результат.item.children.item;
			Если Тип("СписокXDTO") = ТипЗнч(Ошибки) Тогда
				Для Каждого Элемент Из Ошибки Цикл
					ТекстОшибки = ТекстОшибки + 
					?(ЗначениеЗаполнено(ТекстОшибки), Символы.ПС, "") + 
					"Код ошибки: " + Элемент.key + ". " + Элемент.value;
				КонецЦикла; 
			Иначе
				ТекстОшибки = ТекстОшибки + 
				"Код ошибки: " + Ошибки.key + ". " + Ошибки.value;
			КонецЕсли; 
			Сообщение = Новый СообщениеПользователю;
			Сообщение.Текст = ТекстОшибки;
			Сообщение.Сообщить();
			Возврат Неопределено;
		КонецЕсли; 
	КонецЕсли; 
	
	Возврат Результат;
КонецФункции

&НаСервере
Функция xmlnssoap()
	Возврат "http://schemas.xmlsoap.org/soap/envelope/";
КонецФункции

&НаСервере
Функция УстановитьСоединениеССерверомИнтернета(URLСервера, ОписаниеОшибки = "")

	СтруктураURI = ОбщегоНазначенияКлиентСервер.СтруктураURI(URLСервера);
	Схема = ?(ЗначениеЗаполнено(СтруктураURI.Схема), СтруктураURI.Схема, "http");
	Прокси = ПолучениеФайловИзИнтернетаКлиентСервер.ПолучитьПрокси(Схема);
	
	Попытка
		Соединение = Новый HTTPСоединение(
			СтруктураURI.Хост,
			СтруктураURI.Порт,
			СтруктураURI.Логин,
			СтруктураURI.Пароль, 
			Прокси,
			60,
			?(НРег(Схема) = "http", Неопределено, Новый ЗащищенноеСоединениеOpenSSL));
	Исключение
		ВызватьИсключение(ИнформацияОбОшибке());
		Возврат Неопределено;
	КонецПопытки;
	
	Возврат Соединение;
	
КонецФункции

&НаСервере
Функция ПрочитатьДанныеКлассификатораИзXDTO(Результат)
		
	ТЗРеквизитов = Новый ТаблицаЗначений;
	//ТЗРеквизитов.Колонки.Добавить(Реквизит.Имя,Реквизит.Тип);
	
	Если Не ТипЗнч(Результат) = Тип("ОбъектXDTO") Тогда
		Возврат ТЗРеквизитов;
	КонецЕсли; 
	
	Если Результат.Свойства().Получить("item") = Неопределено Тогда
		Возврат ТЗРеквизитов;	
	КонецЕсли; 
	
	СписокЗаписей = Результат.item;
	Если ТипЗнч(СписокЗаписей) <> Тип("СписокXDTO") Тогда
		Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(СписокЗаписей, "children") Тогда
			НовыйСписок = Новый Массив();
			НовыйСписок.Добавить(СписокЗаписей);
			СписокЗаписей = НовыйСписок;
		Иначе
			Возврат ТЗРеквизитов;	
		КонецЕсли; 			
	КонецЕсли;  
	
	ДобавитьКолонки = Истина;
	
	Для Каждого ЭлементВерхнегоУровня Из СписокЗаписей Цикл
		
		СписокПолей = ЭлементВерхнегоУровня.children.item;
		
		Если ТипЗнч(СписокПолей) <> Тип("СписокXDTO") Тогда
			Продолжить;	
		КонецЕсли; 
		
		Если ДобавитьКолонки Тогда
			Для каждого Поле Из СписокПолей Цикл
				НазвКолонки = НРег(СтрЗаменить(Поле.key,"-","_"));
				ТЗРеквизитов.Колонки.Добавить(НазвКолонки, Новый ОписаниеТипов("Строка"));
			КонецЦикла;	
			ДобавитьКолонки = Ложь;
		КонецЕсли; 	
		
		НоваяСтрока = ТЗРеквизитов.Добавить();		
				
		Для Каждого Элемент Из СписокПолей Цикл
			Если ТипЗнч(Элемент.value) <> Тип("ОбъектXDTO") Тогда 	// Исключаем пустые значения
				НазвКолонки = НРег(СтрЗаменить(Элемент.key,"-","_"));
				НоваяСтрока[НазвКолонки] = СокрЛП(Элемент.value)
			КонецЕсли;
		КонецЦикла;
		
	КонецЦикла; 
		
	Возврат ТЗРеквизитов;

КонецФункции

#КонецОбласти 
 
#КонецОбласти


